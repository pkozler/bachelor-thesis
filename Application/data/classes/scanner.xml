<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<codes>
<code lang="C">#ifndef SCANNER_INCLUDED&#13;
#define	SCANNER_INCLUDED&#13;
&#13;
#include "String.h"&#13;
#include &lt;stdint.h&gt;&#13;
&#13;
/**&#13;
 * A simple text scanner which can parse primitive types and strings using regular expressions.&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
&#13;
typedef struct {&#13;
    void *dummy;&#13;
} Scanner;&#13;
&#13;
Scanner *new_Scanner(void *source);&#13;
String *next(Scanner *ptr);&#13;
bool nextBoolean(Scanner *ptr);&#13;
int8_t nextByte(Scanner *ptr);&#13;
int16_t nextShort(Scanner *ptr);&#13;
int32_t nextInt(Scanner *ptr);&#13;
int64_t nextLong(Scanner *ptr);&#13;
float nextFloat(Scanner *ptr);&#13;
double nextDouble(Scanner *ptr);&#13;
String *nextLine(Scanner *ptr);&#13;
&#13;
#endif	/* SCANNER_INCLUDED */&#13;
&#13;
#include "Scanner.h"&#13;
&#13;
#include "String.h"&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;ctype.h&gt;&#13;
&#13;
/**&#13;
 * Constructs a new Scanner that produces values scanned from the specified&#13;
 * input stream.&#13;
 *&#13;
 * @param source An input stream to be scanned&#13;
 */&#13;
Scanner *new_Scanner(void *source) {&#13;
    Scanner *sc = malloc(sizeof(Scanner));&#13;
    return sc;&#13;
}&#13;
&#13;
/**&#13;
 * Finds and returns the next complete token from this scanner.&#13;
 *&#13;
 * @return the next token&#13;
 */&#13;
String *next(Scanner *ptr) {&#13;
    char *s;&#13;
    scanf("%s", s);&#13;
&#13;
    return new_String(s);&#13;
}&#13;
&#13;
/**&#13;
 * Scans the next token of the input into a boolean value and returns that&#13;
 * value.&#13;
 *&#13;
 * @return the boolean scanned from the input&#13;
 */&#13;
bool nextBoolean(Scanner *ptr) {&#13;
    char *b;&#13;
    scanf("%s", b);&#13;
    String *str = new_String(b);&#13;
    String *trueStr = new_String("true");&#13;
    String *falseStr = new_String("false");&#13;
    bool value = false;&#13;
&#13;
    if (equals(toLowerCase(str), trueStr)) {&#13;
        value = true;&#13;
    }&#13;
    else if (equals(toLowerCase(str), falseStr)) {&#13;
        value = false;&#13;
    }&#13;
&#13;
    free(str);&#13;
    free(trueStr);&#13;
    free(falseStr);&#13;
&#13;
    return value;&#13;
}&#13;
&#13;
/**&#13;
 * Scans the next token of the input as a byte.&#13;
 *&#13;
 * @return the byte scanned from the input&#13;
 */&#13;
int8_t nextByte(Scanner *ptr) {&#13;
    int32_t b;&#13;
    scanf("%hd", &amp;b);&#13;
&#13;
    return (int8_t) b;&#13;
}&#13;
&#13;
/**&#13;
 * Scans the next token of the input as a short.&#13;
 *&#13;
 * @return the short scanned from the input&#13;
 */&#13;
int16_t nextShort(Scanner *ptr) {&#13;
    int16_t s;&#13;
    scanf("%hd", &amp;s);&#13;
&#13;
    return s;&#13;
}&#13;
&#13;
/**&#13;
 * Scans the next token of the input as an int.&#13;
 *&#13;
 * @return the int scanned from the input&#13;
 */&#13;
int32_t nextInt(Scanner *ptr) {&#13;
    int32_t i;&#13;
    scanf("%d", &amp;i);&#13;
&#13;
    return i;&#13;
}&#13;
&#13;
/**&#13;
 * Scans the next token of the input as a long.&#13;
 * &#13;
 * @return the long scanned from the input&#13;
 */&#13;
int64_t nextLong(Scanner *ptr) {&#13;
    int64_t l;&#13;
    scanf("%ld", &amp;l);&#13;
&#13;
    return l;&#13;
}&#13;
&#13;
/**&#13;
 * Scans the next token of the input as a float.&#13;
 * &#13;
 * @return the float scanned from the input&#13;
 */&#13;
float nextFloat(Scanner *ptr) {&#13;
    float f;&#13;
    scanf("%f", &amp;f);&#13;
&#13;
    return f;&#13;
}&#13;
&#13;
/**&#13;
 * Scans the next token of the input as a double.&#13;
 * &#13;
 * @return the double scanned from the input&#13;
 */&#13;
double nextDouble(Scanner *ptr) {&#13;
    double d;&#13;
    scanf("%lf", &amp;d);&#13;
&#13;
    return d;&#13;
}&#13;
&#13;
/**&#13;
 * Advances this scanner past the current line and returns the input that was skipped.&#13;
 * &#13;
 * @return the line that was skipped&#13;
 */&#13;
String *nextLine(Scanner *ptr) {&#13;
    char * line = malloc(100);&#13;
    char * linep = line;&#13;
    size_t lenmax = 100, len = lenmax;&#13;
    int32_t c;&#13;
&#13;
    if(line == NULL)&#13;
        return NULL;&#13;
&#13;
    for(;;) {&#13;
        c = fgetc(stdin);&#13;
        if(c == EOF)&#13;
            break;&#13;
&#13;
        if(--len == 0) {&#13;
            len = lenmax;&#13;
            char * linen = realloc(linep, lenmax *= 2);&#13;
&#13;
            if(linen == NULL) {&#13;
                free(linep);&#13;
                return NULL;&#13;
            }&#13;
            line = linen + (line - linep);&#13;
            linep = linen;&#13;
        }&#13;
&#13;
        if((*line++ = c) == '\n')&#13;
            break;&#13;
    }&#13;
    *line = '\0';&#13;
    String *str = new_String(linep);&#13;
    return str;&#13;
}&#13;
</code>
<code lang="C++">#ifndef SCANNER_INCLUDED&#13;
#define	SCANNER_INCLUDED&#13;
&#13;
#include "String.h"&#13;
#include &lt;cstdint&gt;&#13;
&#13;
/**&#13;
 * A simple text scanner which can parse primitive types and strings using regular expressions.&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
class Scanner {&#13;
public:&#13;
    Scanner(void *source);&#13;
    String *next();&#13;
    bool nextBoolean();&#13;
    int8_t nextByte();&#13;
    int16_t nextShort();&#13;
    int32_t nextInt();&#13;
    int64_t nextLong();&#13;
    float nextFloat();&#13;
    double nextDouble();&#13;
    String *nextLine();&#13;
};&#13;
&#13;
#endif	// SCANNER_INCLUDED&#13;
&#13;
#include "Scanner.h"

#include &lt;cstdlib&gt;
#include &lt;sstream&gt;

/**
 * Constructs a new Scanner that produces values scanned from the specified
 * input stream.
 *
 * @param source An input stream to be scanned
 */
Scanner::Scanner(void *source) {
    // really no code
}

/**
 * Finds and returns the next complete token from this scanner.
 *
 * @return the next token
 */
String *Scanner::next() {
    std::string s;
    std::cin &gt;&gt; s;

    return new String(s);
}

/**
 * Scans the next token of the input into a boolean value and returns that
 * value.
 *
 * @return the boolean scanned from the input
 */
bool Scanner::nextBoolean() {
    bool b;
    std::cin &gt;&gt; b;

    return b;
}

/**
 * Scans the next token of the input as a byte.
 *
 * @return the byte scanned from the input
 */
int8_t Scanner::nextByte() {
    int8_t b;
    std::cin &gt;&gt; b;

    return b;
}

/**
 * Scans the next token of the input as a short.
 *
 * @return the short scanned from the input
 */
int16_t Scanner::nextShort() {
    int16_t s;
    std::cin &gt;&gt; s;

    return s;
}

/**
 * Scans the next token of the input as an int.
 *
 * @return the int scanned from the input
 */
int32_t Scanner::nextInt() {
    int32_t i;
    std::cin &gt;&gt; i;

    return i;
}

/**
 * Scans the next token of the input as a long.
 * 
 * @return the long scanned from the input
 */
int64_t Scanner::nextLong() {
    int64_t l;
    std::cin &gt;&gt; l;

    return l;
}

/**
 * Scans the next token of the input as a float.
 * 
 * @return the float scanned from the input
 */
float Scanner::nextFloat() {
    float f;
    std::cin &gt;&gt; f;

    return f;
}

/**
 * Scans the next token of the input as a double.
 * 
 * @return the double scanned from the input
 */
double Scanner::nextDouble() {
    double d;
    std::cin &gt;&gt; d;

    return d;
}

/**
 * Advances this scanner past the current line and returns the input that was skipped.
 * 
 * @return the line that was skipped
 */
String *Scanner::nextLine() {
    std::string s;
    std::getline(std::cin, s);

    return new String(s);
}
</code>
<code lang="C#">ï»¿using System;&#13;
using System.Text.RegularExpressions;&#13;
&#13;
namespace JavaClasses {&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// A simple text scanner which can parse primitive types and strings using regular expressions.&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;author&gt;Petr Kozler (A13B0359P)&lt;/author&gt;&#13;
    public class Scanner {&#13;
&#13;
        // current line&#13;
        private string line = "";&#13;
        &#13;
        /// &lt;summary&gt;&#13;
        /// Constructs a new Scanner that produces values scanned from the specified&#13;
        /// input stream.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="source"&gt;An input stream to be scanned&#13;
        /// &lt;/param&gt;&#13;
        public Scanner(Object source) {&#13;
            // really no code&#13;
        }&#13;
        &#13;
        /*&#13;
             Returns the next token of the current line or reads the new line&#13;
             from the standard input if the current line was completely scanned.&#13;
         */&#13;
        private string nextElement() {&#13;
            // reading the next line if the current is empty&#13;
            if (string.IsNullOrEmpty(line)) {&#13;
                line = Console.ReadLine().TrimStart();&#13;
            }&#13;
&#13;
            // removes the next token (delimited by whitespaces) from the current line&#13;
            Match match = Regex.Match(line, @"(?&lt;=\s)");&#13;
            string token = line.Remove(0, match.Index + match.Length).TrimEnd();&#13;
&#13;
            return token;&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Finds and returns the next complete token from this scanner.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the next token&#13;
        /// &lt;/returns&gt;&#13;
        public String next() {&#13;
            return nextElement();&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Scans the next token of the input into a boolean value and returns that&#13;
        /// value.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the boolean scanned from the input&#13;
        /// &lt;/returns&gt;&#13;
        public bool nextBoolean() {&#13;
            return bool.Parse(nextElement());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Scans the next token of the input as a byte.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the byte scanned from the input&#13;
        /// &lt;/returns&gt;&#13;
        public sbyte nextByte() {&#13;
            return sbyte.Parse(nextElement());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Scans the next token of the input as a short.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the short scanned from the input&#13;
        /// &lt;/returns&gt;&#13;
        public short nextShort() {&#13;
            return short.Parse(nextElement());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Scans the next token of the input as an int.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the int scanned from the input&#13;
        /// &lt;/returns&gt;&#13;
        public int nextInt() {&#13;
            return int.Parse(nextElement());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Scans the next token of the input as a long.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the long scanned from the input&#13;
        /// &lt;/returns&gt;&#13;
        public long nextLong() {&#13;
            return long.Parse(nextElement());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Scans the next token of the input as a float.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the float scanned from the input&#13;
        /// &lt;/returns&gt;&#13;
        public float nextFloat() {&#13;
            return float.Parse(nextElement());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Scans the next token of the input as a double.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the double scanned from the input&#13;
        /// &lt;/returns&gt;&#13;
        public double nextDouble() {&#13;
            return double.Parse(nextElement());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Advances this scanner past the current line and returns the input that was skipped.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the line that was skipped&#13;
        /// &lt;/returns&gt;&#13;
        public String nextLine() {&#13;
            // reading the next line if the current is empty and returning it&#13;
            if (string.IsNullOrEmpty(line)) {&#13;
                return Console.ReadLine();&#13;
            } // reading the rest of the current line if it is not empty&#13;
            else {&#13;
                String str = line;&#13;
                line = "";&#13;
&#13;
                return str;&#13;
            }&#13;
        }&#13;
&#13;
    }&#13;
&#13;
}&#13;
</code>
<code lang="Free Pascal">unit ScannerUnit;

{$mode objfpc}{$H+}

interface

uses
  StringUnit;

type
  (**
   * A simple text scanner which can parse primitive types and strings using regular expressions.
   *
   * @author Petr Kozler (A13B0359P)
   *)
  Scanner = class
    public
      constructor create(source: TObject);
      function next() : String_;
      function nextBoolean() : boolean;
      function nextByte() : shortInt;
      function nextShort() : smallInt;
      function nextInt() : longInt;
      function nextLong() : int64;
      function nextFloat() : single;
      function nextDouble() : double;
      function nextLine() : String_;
  end;

implementation

uses
  SysUtils;

(**
 * Constructs a new Scanner that produces values scanned from the specified
 * input stream.
 *
 * @param source An input stream to be scanned
 *)
constructor Scanner.create(source: TObject);
begin
end;

(**
 * Finds and returns the next complete token from this scanner.
 *
 * @return the next token
 *)
function Scanner.next() : String_;
var
  s: ansiString;
  str: String_;
begin
  read(s);
  str.create(s);
  next := str; // TODO nacist retezec do prvniho bileho znaku
end;

(**
 * Scans the next token of the input into a boolean value and returns that
 * value.
 *
 * @return the boolean scanned from the input
 *)
function Scanner.nextBoolean() : boolean;
var
  s: ansiString;
begin
  read(s);
  nextBoolean := strToBool(s);
end;

(**
 * Scans the next token of the input as a byte.
 *
 * @return the byte scanned from the input
 *)
function Scanner.nextByte() : shortInt;
var
  b: shortInt;
begin
  read(b);
  nextByte := b;
end;

(**
 * Scans the next token of the input as a short.
 *
 * @return the short scanned from the input
 *)
function Scanner.nextShort() : smallInt;
var
  s: smallInt;
begin
  read(s);
  nextShort := s;
end;

(**
 * Scans the next token of the input as an int.
 *
 * @return the int scanned from the input
 *)
function Scanner.nextInt() : longInt;
var
  i: longInt;
begin
  read(i);
  nextInt := i;
end;

(**
 * Scans the next token of the input as a long.
 *
 * @return the long scanned from the input
 *)
function Scanner.nextLong() : int64;
var
  l: int64;
begin
  read(l);
  nextLong := l;
end;

(**
 * Scans the next token of the input as a float.
 *
 * @return the float scanned from the input
 *)
function Scanner.nextFloat() : single;
var
  f: single;
begin
  read(f);
  nextFloat := f;
end;

(**
 * Scans the next token of the input as a double.
 *
 * @return the double scanned from the input
 *)
function Scanner.nextDouble() : double;
var
  d: double;
begin
  read(d);
  nextDouble := d;
end;

(**
 * Advances this scanner past the current line and returns the input that was skipped.
 *
 * @return the line that was skipped
 *)
function Scanner.nextLine() : String_;
var
  s: ansiString;
  str: String_;
begin
  readLn(s);
  str.create(s);
  nextLine := str;
end;

end.

</code>
</codes>
