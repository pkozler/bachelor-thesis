<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<codes>
<code lang="C">#ifndef STRING_INCLUDED&#13;
#define	STRING_INCLUDED&#13;
&#13;
#include &lt;stdbool.h&gt;&#13;
#include &lt;stdint.h&gt;&#13;
&#13;
/**&#13;
 * The String class represents character strings.&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
&#13;
typedef struct {&#13;
    char *s;&#13;
    int32_t len;&#13;
} String;&#13;
&#13;
String *new_StringB(int8_t *value, int32_t length);&#13;
String *new_StringRangeB(int8_t *value, int32_t offset, int32_t length);&#13;
String *new_String(char *original);&#13;
void delete_String(String *ptr);&#13;
int32_t compareTo(String *ptr, String *anotherString);&#13;
bool equals(String *ptr, String *anObject);&#13;
String *substring(String *ptr, int32_t beginIndex);&#13;
String *substringTo(String *ptr, int32_t beginIndex, int32_t endIndex);&#13;
int32_t indexOfC(String *ptr, int32_t ch);&#13;
int32_t indexOfFromC(String *ptr, int32_t ch, int32_t fromIndex);&#13;
int32_t indexOfStr(String *ptr, String *str);&#13;
int32_t indexOfFromStr(String *ptr, String *str, int32_t fromIndex);&#13;
int32_t length(String *ptr);&#13;
String *trim(String *ptr);&#13;
String *toLowerCase(String *ptr);&#13;
String *toUpperCase(String *ptr);&#13;
char charAt(String *ptr, int32_t index);&#13;
String *replace(String *ptr, char oldChar, char newChar);&#13;
bool startsWith(String *ptr, String *prefix);&#13;
bool endsWith(String *ptr, String *suffix);&#13;
bool isEmptyStr(String *ptr);&#13;
char *toString(String *ptr);&#13;
&#13;
#endif	/* STRING_INCLUDED */&#13;
&#13;
#include "String.h"&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;ctype.h&gt;&#13;
&#13;
/**&#13;
 * Constructs a new String by decoding the specified array of bytes using&#13;
 * the platform's default charset.&#13;
 *&#13;
 * @param bytes The bytes to be decoded into characters&#13;
 */&#13;
String *new_StringB(int8_t *value, int32_t length) {&#13;
    return new_StringRangeB(value, 0, length);&#13;
}&#13;
&#13;
/**&#13;
 * Constructs a new String by decoding the specified subarray of bytes using&#13;
 * the platform's default charset.&#13;
 *&#13;
 * @param bytes The bytes to be decoded into characters&#13;
 * @param offset The index of the first byte to decode&#13;
 * @param length The number of bytes to decode&#13;
 */&#13;
String *new_StringRangeB(int8_t *value, int32_t offset, int32_t length) {&#13;
    String *str = malloc(sizeof(String));&#13;
    str-&gt;s[0] = '\0';&#13;
    strncat(str-&gt;s, (char *) value + offset, length);&#13;
&#13;
    return str;&#13;
}&#13;
&#13;
/**&#13;
 * Initializes a newly created String object so that it represents the same&#13;
 * sequence of characters as the argument; in other words, the newly created&#13;
 * string is a copy of the argument string. Unless an explicit copy of&#13;
 * original is needed, use of this constructor is unnecessary since Strings&#13;
 * are immutable.&#13;
 *&#13;
 * @param original A String&#13;
 */&#13;
String *new_String(char *original) {&#13;
    String *str = malloc(sizeof(String));&#13;
    str-&gt;s = strdup(original);&#13;
    str-&gt;len = strlen(str-&gt;s);&#13;
&#13;
    return str;&#13;
}&#13;
&#13;
void delete_String(String *ptr) {&#13;
    free(ptr-&gt;s);&#13;
    free(ptr);&#13;
}&#13;
&#13;
/**&#13;
 * Compares two strings lexicographically.&#13;
 *&#13;
 * @param anotherString the String to be compared.&#13;
 * @return the value 0 if the argument string is equal to this string; a&#13;
 * value less than 0 if this string is lexicographically less than the&#13;
 * string argument; and a value greater than 0 if this string is&#13;
 * lexicographically greater than the string argument.&#13;
 */&#13;
int32_t compareTo(String *ptr, String *anotherString) {&#13;
    return strcmp(ptr-&gt;s, anotherString-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Compares this string to the specified object.&#13;
 *&#13;
 * @param anObject The object to compare this String against&#13;
 * @return true if the given object represents a String equivalent to this&#13;
 * string, false otherwise&#13;
 */&#13;
bool equals(String *ptr, String *anObject) {&#13;
    if (ptr == anObject) {&#13;
        return true;&#13;
    }&#13;
&#13;
    if (anObject == NULL || anObject == NULL) {&#13;
        return false;&#13;
    }&#13;
&#13;
    if (sizeof(*ptr) != sizeof(*anObject)) {&#13;
        return false;&#13;
    }&#13;
&#13;
    return !strcmp(ptr-&gt;s, anObject-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string that is a substring of this string.&#13;
 * &#13;
 * @param beginIndex the beginning index, inclusive.&#13;
 * @return the specified substring.&#13;
 */&#13;
String *substring(String *ptr, int32_t beginIndex) {&#13;
    return substringTo(ptr, 0, strlen(ptr-&gt;s) - 1);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string that is a substring of this string.&#13;
 *&#13;
 * @param beginIndex the beginning index, inclusive.&#13;
 * @param endIndex the ending index, exclusive.&#13;
 * @return the specified substring.&#13;
 */&#13;
String *substringTo(String *ptr, int32_t beginIndex, int32_t endIndex) {&#13;
    int32_t len = endIndex - beginIndex;&#13;
    char *to = (char*) malloc(len);&#13;
    strncpy(to, ptr-&gt;s + beginIndex, (size_t) endIndex - beginIndex);&#13;
&#13;
    String *str = new_String(to);&#13;
    free(to);&#13;
&#13;
    return str;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified character.&#13;
 *&#13;
 * @param ch a character (Unicode code point).&#13;
 * @return the index of the first occurrence of the character in the&#13;
 * character sequence represented by this object, or -1 if the character&#13;
 * does not occur.&#13;
 */&#13;
int32_t indexOfC(String *ptr, int32_t ch) {&#13;
    return indexOfFromC(ptr, ch, 0);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified character, starting the search at the specified index.&#13;
 *&#13;
 * @param ch a character (Unicode code point).&#13;
 * @param fromIndex the index to start the search from.&#13;
 * @return the index of the first occurrence of the character in the&#13;
 * character sequence represented by this object that is greater than or&#13;
 * equal to fromIndex, or -1 if the character does not occur.&#13;
 */&#13;
int32_t indexOfFromC(String *ptr, int32_t ch, int32_t fromIndex) {&#13;
    char* str = ptr-&gt;s + fromIndex;&#13;
&#13;
    char* c = strchr(str, ch);&#13;
    int32_t index = (int32_t)(c - str);&#13;
&#13;
    return index;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified substring.&#13;
 *&#13;
 * @param str the substring to search for.&#13;
 * @return the index of the first occurrence of the specified substring, or&#13;
 * -1 if there is no such occurrence.&#13;
 */&#13;
int32_t indexOfStr(String *ptr, String *str) {&#13;
    return indexOfFromStr(ptr, str, 0);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified substring, starting at the specified index.&#13;
 *&#13;
 * @param str the substring to search for.&#13;
 * @param fromIndex the index from which to start the search.&#13;
 * @return the index of the first occurrence of the specified substring,&#13;
 * starting at the specified index, or -1 if there is no such occurrence.&#13;
 */&#13;
int32_t indexOfFromStr(String *ptr, String *str, int32_t fromIndex) {&#13;
    char* str0 = ptr-&gt;s + fromIndex;&#13;
    int32_t index = (int32_t) strcspn(str0, str-&gt;s);&#13;
&#13;
    return index;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the length of this string.&#13;
 *&#13;
 * @return the length of the sequence of characters represented by this&#13;
 * object.&#13;
 */&#13;
int32_t length(String *ptr) {&#13;
    return ptr-&gt;len;&#13;
}&#13;
&#13;
/**&#13;
 * Returns a copy of the string, with leading and trailing whitespace&#13;
 * omitted.&#13;
 *&#13;
 * @return A copy of this string with leading and trailing white space&#13;
 * removed, or this string if it has no leading or trailing white space.&#13;
 */&#13;
String *trim(String *ptr) {&#13;
    int32_t i, j;&#13;
&#13;
    for (i = 0; isspace(ptr-&gt;s[i]); i++);&#13;
    for (j = ptr-&gt;len - 1; isspace(ptr-&gt;s[j]); j--);&#13;
    int32_t num = j - i + 1;&#13;
&#13;
    char *str = (char *) malloc(num + 1);&#13;
    strncpy(str, ptr-&gt;s + i, num);&#13;
    str[num] = '\0';&#13;
&#13;
    String *changedStr = new_String(str);&#13;
    free(str);&#13;
&#13;
    return changedStr;&#13;
}&#13;
&#13;
/**&#13;
 * Converts all of the characters in this String to lower case using the&#13;
 * rules of the default locale.&#13;
 *&#13;
 * @return the String, converted to lowercase.&#13;
 */&#13;
String *toLowerCase(String *ptr) {&#13;
    char *str = (char*) malloc(ptr-&gt;len);&#13;
&#13;
    int32_t i = 0;&#13;
    char c;&#13;
    while (ptr-&gt;s[i]) {&#13;
        c = ptr-&gt;s[i];&#13;
        str[i] = tolower((int32_t)c);&#13;
        i++;&#13;
    }&#13;
    str[i] = '\0';&#13;
&#13;
    String *changedStr = new_String(str);&#13;
    free(str);&#13;
&#13;
    return changedStr;&#13;
}&#13;
&#13;
/**&#13;
 * Converts all of the characters in this String to upper case using the&#13;
 * rules of the default locale.&#13;
 *&#13;
 * @return the String, converted to uppercase.&#13;
 */&#13;
String *toUpperCase(String *ptr) {&#13;
    char *str = (char*) malloc(ptr-&gt;len);&#13;
&#13;
    int32_t i = 0;&#13;
    char c;&#13;
    while (ptr-&gt;s[i]) {&#13;
        c = ptr-&gt;s[i];&#13;
        str[i] = toupper((int32_t)c);&#13;
        i++;&#13;
    }&#13;
    str[i] = '\0';&#13;
&#13;
    String *changedStr = new_String(str);&#13;
    free(str);&#13;
&#13;
    return changedStr;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the char value at the specified index.&#13;
 *&#13;
 * @param index the index of the char value.&#13;
 * @return the char value at the specified index of this string. The first&#13;
 * char value is at index 0.&#13;
 */&#13;
char charAt(String *ptr, int32_t index) {&#13;
    return ptr-&gt;s[index];&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string resulting from replacing all occurrences of oldChar&#13;
 * in this string with newChar.&#13;
 *&#13;
 * @param oldChar the old character.&#13;
 * @param newChar the new character.&#13;
 * @return a string derived from this string by replacing every occurrence&#13;
 * of oldChar with newChar.&#13;
 */&#13;
String *replace(String *ptr, char oldChar, char newChar) {&#13;
    char *str = (char*) malloc(ptr-&gt;len);&#13;
    int32_t i;&#13;
&#13;
    for (i = 0; ptr-&gt;s[i]; i++) {&#13;
        if (ptr-&gt;s[i] == oldChar) {&#13;
            ptr-&gt;s[i] = newChar;&#13;
        }&#13;
    }&#13;
&#13;
    String *changedStr = new_String(str);&#13;
    free(str);&#13;
&#13;
    return changedStr;&#13;
}&#13;
&#13;
/**&#13;
 * Tests if this string starts with the specified prefix.&#13;
 *&#13;
 * @param prefix the prefix.&#13;
 * @return true if the character sequence represented by the argument is a&#13;
 * prefix of the character sequence represented by this string; false&#13;
 * otherwise. Note also that true will be returned if the argument is an&#13;
 * empty string or is equal to this String object as determined by the&#13;
 * equals(Object) method.&#13;
 */&#13;
bool startsWith(String *ptr, String *prefix) {&#13;
    return ptr-&gt;len &lt; prefix-&gt;len ? false&#13;
            : strncmp(prefix-&gt;s, ptr-&gt;s, prefix-&gt;len) == 0;&#13;
}&#13;
&#13;
/**&#13;
 * Tests if this string ends with the specified suffix.&#13;
 *&#13;
 * @param suffix the suffix.&#13;
 * @return true if the character sequence represented by the argument is a&#13;
 * suffix of the character sequence represented by this object; false&#13;
 * otherwise. Note that the result will be true if the argument is the empty&#13;
 * string or is equal to this String object as determined by the&#13;
 * equals(Object) method.&#13;
 */&#13;
bool endsWith(String *ptr, String *suffix) {&#13;
    return ptr-&gt;len &lt; suffix-&gt;len ? false&#13;
            : strncmp(suffix-&gt;s, ptr-&gt;s + (ptr-&gt;len - suffix-&gt;len), suffix-&gt;len) == 0;&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if, and only if, length() is 0.&#13;
 *&#13;
 * @return true if length() is 0, otherwise false&#13;
 */&#13;
bool isEmptyStr(String *ptr) {&#13;
    return ptr-&gt;len == 0;&#13;
}&#13;
&#13;
char *toString(String *ptr) {&#13;
    return ptr-&gt;s;&#13;
}&#13;
</code>
<code lang="C++">#ifndef STRING_INCLUDED&#13;
#define	STRING_INCLUDED&#13;
&#13;
#include &lt;iostream&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
/**&#13;
 * The String class represents character strings.&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
class String {&#13;
    std::string s;&#13;
public:&#13;
    String(int8_t *value, int32_t length);&#13;
    String(int8_t *value, int32_t offset, int32_t length);&#13;
    String(std::string original);&#13;
    int32_t compareTo(String *anotherString);&#13;
    bool equals(String *anObject);&#13;
    String *substring(int32_t beginIndex);&#13;
    String *substring(int32_t beginIndex, int32_t endIndex);&#13;
    int32_t indexOf(int32_t ch);&#13;
    int32_t indexOf(int32_t ch, int32_t fromIndex);&#13;
    int32_t indexOf(String *str);&#13;
    int32_t indexOf(String *str, int32_t fromIndex);&#13;
    int32_t length();&#13;
    String *trim();&#13;
    String *toLowerCase();&#13;
    String *toUpperCase();&#13;
    char charAt(int32_t index);&#13;
    String *replace(char oldChar, char newChar);&#13;
    bool startsWith(String *prefix);&#13;
    bool endsWith(String *suffix);&#13;
    bool isEmpty();&#13;
    std::string toString();&#13;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, String &amp;str);&#13;
    friend String *operator+(String &amp;s1, String &amp;s2);&#13;
    String *operator=(String &amp;s);&#13;
};&#13;
&#13;
#endif	// STRING_INCLUDED&#13;
&#13;
#include "String.h"&#13;
&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;iostream&gt;&#13;
&#13;
/**&#13;
 * Constructs a new String by decoding the specified array of bytes using&#13;
 * the platform's default charset.&#13;
 *&#13;
 * @param bytes The bytes to be decoded into characters&#13;
 */&#13;
String::String(int8_t *value, int32_t length) {&#13;
    this-&gt;s = ((char *) value, length);&#13;
}&#13;
&#13;
/**&#13;
 * Constructs a new String by decoding the specified subarray of bytes using&#13;
 * the platform's default charset.&#13;
 *&#13;
 * @param bytes The bytes to be decoded into characters&#13;
 * @param offset The index of the first byte to decode&#13;
 * @param length The number of bytes to decode&#13;
 */&#13;
String::String(int8_t *value, int32_t offset, int32_t length) {&#13;
    this-&gt;s = ((char *) (value + offset), length);&#13;
}&#13;
&#13;
/**&#13;
 * Initializes a newly created String object so that it represents the same&#13;
 * sequence of characters as the argument; in other words, the newly created&#13;
 * string is a copy of the argument string. Unless an explicit copy of&#13;
 * original is needed, use of this constructor is unnecessary since Strings&#13;
 * are immutable.&#13;
 *&#13;
 * @param original A String&#13;
 */&#13;
String::String(std::string original) {&#13;
    this-&gt;s = original;&#13;
}&#13;
&#13;
/**&#13;
 * Compares two strings lexicographically.&#13;
 *&#13;
 * @param anotherString the String to be compared.&#13;
 * @return the value 0 if the argument string is equal to this string; a&#13;
 * value less than 0 if this string is lexicographically less than the&#13;
 * string argument; and a value greater than 0 if this string is&#13;
 * lexicographically greater than the string argument.&#13;
 */&#13;
int32_t String::compareTo(String *anotherString) {&#13;
    return this-&gt;s.compare(anotherString-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Compares this string to the specified object.&#13;
 *&#13;
 * @param anObject The object to compare this String against&#13;
 * @return true if the given object represents a String equivalent to this&#13;
 * string, false otherwise&#13;
 */&#13;
bool String::equals(String *anObject) {&#13;
    if (anObject == nullptr) {&#13;
        return false;&#13;
    }&#13;
&#13;
    if (sizeof (*this) != sizeof (*anObject)) {&#13;
        return false;&#13;
    }&#13;
&#13;
    return (bool) !this-&gt;s.compare(anObject-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string that is a substring of this string.&#13;
 * &#13;
 * @param beginIndex the beginning index, inclusive.&#13;
 * @return the specified substring.&#13;
 */&#13;
String *String::substring(int32_t beginIndex) {&#13;
    return new String(this-&gt;s.substr(beginIndex));&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string that is a substring of this string.&#13;
 *&#13;
 * @param beginIndex the beginning index, inclusive.&#13;
 * @param endIndex the ending index, exclusive.&#13;
 * @return the specified substring.&#13;
 */&#13;
String *String::substring(int32_t beginIndex, int32_t endIndex) {&#13;
    return new String(this-&gt;s.substr(beginIndex, endIndex - beginIndex + 1));&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified character.&#13;
 *&#13;
 * @param ch a character (Unicode code point).&#13;
 * @return the index of the first occurrence of the character in the&#13;
 * character sequence represented by this object, or -1 if the character&#13;
 * does not occur.&#13;
 */&#13;
int32_t String::indexOf(int32_t ch) {&#13;
    return this-&gt;s.find((char) ch);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified character, starting the search at the specified index.&#13;
 *&#13;
 * @param ch a character (Unicode code point).&#13;
 * @param fromIndex the index to start the search from.&#13;
 * @return the index of the first occurrence of the character in the&#13;
 * character sequence represented by this object that is greater than or&#13;
 * equal to fromIndex, or -1 if the character does not occur.&#13;
 */&#13;
int32_t String::indexOf(int32_t ch, int32_t fromIndex) {&#13;
    return this-&gt;s.find((char) ch, fromIndex);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified substring.&#13;
 *&#13;
 * @param str the substring to search for.&#13;
 * @return the index of the first occurrence of the specified substring, or&#13;
 * -1 if there is no such occurrence.&#13;
 */&#13;
int32_t String::indexOf(String *str) {&#13;
    return this-&gt;s.find(str-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified substring, starting at the specified index.&#13;
 *&#13;
 * @param str the substring to search for.&#13;
 * @param fromIndex the index from which to start the search.&#13;
 * @return the index of the first occurrence of the specified substring,&#13;
 * starting at the specified index, or -1 if there is no such occurrence.&#13;
 */&#13;
int32_t String::indexOf(String *str, int32_t fromIndex) {&#13;
    return this-&gt;s.find(str-&gt;s, fromIndex);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the length of this string.&#13;
 *&#13;
 * @return the length of the sequence of characters represented by this&#13;
 * object.&#13;
 */&#13;
int32_t String::length() {&#13;
    return this-&gt;s.length();&#13;
}&#13;
&#13;
/**&#13;
 * Returns a copy of the string, with leading and trailing whitespace&#13;
 * omitted.&#13;
 *&#13;
 * @return A copy of this string with leading and trailing white space&#13;
 * removed, or this string if it has no leading or trailing white space.&#13;
 */&#13;
String *String::trim() {&#13;
    const char* white_spaces = " \t\n\r\f";&#13;
&#13;
    int32_t first = this-&gt;s.find_first_not_of(white_spaces);&#13;
&#13;
    if (first == std::string::npos) {&#13;
        return new String(std::string(""));&#13;
    }&#13;
&#13;
    int32_t last = this-&gt;s.find_last_not_of(white_spaces);&#13;
&#13;
    return new String(this-&gt;s.substr(first, last - first + 1));&#13;
}&#13;
&#13;
/**&#13;
 * Converts all of the characters in this String to lower case using the&#13;
 * rules of the default locale.&#13;
 *&#13;
 * @return the String, converted to lowercase.&#13;
 */&#13;
String *String::toLowerCase() {&#13;
    std::string lowerCaseStr = this-&gt;s;&#13;
    std::transform(this-&gt;s.begin(), this-&gt;s.end(), std::back_inserter(lowerCaseStr), ::tolower);&#13;
    return new String(lowerCaseStr);&#13;
}&#13;
&#13;
/**&#13;
 * Converts all of the characters in this String to upper case using the&#13;
 * rules of the default locale.&#13;
 *&#13;
 * @return the String, converted to uppercase.&#13;
 */&#13;
String *String::toUpperCase() {&#13;
    std::string upperCaseStr = this-&gt;s;&#13;
    std::transform(this-&gt;s.begin(), this-&gt;s.end(), std::back_inserter(upperCaseStr), ::toupper);&#13;
    return new String(upperCaseStr);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the char value at the specified index.&#13;
 *&#13;
 * @param index the index of the char value.&#13;
 * @return the char value at the specified index of this string. The first&#13;
 * char value is at index 0.&#13;
 */&#13;
char String::charAt(int32_t index) {&#13;
    return this-&gt;s.at(index);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string resulting from replacing all occurrences of oldChar&#13;
 * in this string with newChar.&#13;
 *&#13;
 * @param oldChar the old character.&#13;
 * @param newChar the new character.&#13;
 * @return a string derived from this string by replacing every occurrence&#13;
 * of oldChar with newChar.&#13;
 */&#13;
String *String::replace(char oldChar, char newChar) {&#13;
    std::string str = this-&gt;s;&#13;
    std::replace(str.begin(), str.end(), oldChar, newChar);&#13;
&#13;
    return new String(str);&#13;
}&#13;
&#13;
/**&#13;
 * Tests if this string starts with the specified prefix.&#13;
 *&#13;
 * @param prefix the prefix.&#13;
 * @return true if the character sequence represented by the argument is a&#13;
 * prefix of the character sequence represented by this string; false&#13;
 * otherwise. Note also that true will be returned if the argument is an&#13;
 * empty string or is equal to this String object as determined by the&#13;
 * equals(Object) method.&#13;
 */&#13;
bool String::startsWith(String *prefix) {&#13;
    return (s.size() &gt;= prefix-&gt;toString().size() &amp;&amp; s.find(prefix-&gt;toString()) == 0);&#13;
}&#13;
&#13;
/**&#13;
 * Tests if this string ends with the specified suffix.&#13;
 *&#13;
 * @param suffix the suffix.&#13;
 * @return true if the character sequence represented by the argument is a&#13;
 * suffix of the character sequence represented by this object; false&#13;
 * otherwise. Note that the result will be true if the argument is the empty&#13;
 * string or is equal to this String object as determined by the&#13;
 * equals(Object) method.&#13;
 */&#13;
bool String::endsWith(String *suffix) {&#13;
    return (s.size() &gt;= suffix-&gt;toString().size() &amp;&amp;&#13;
            s.compare(s.size() - suffix-&gt;toString().size(), suffix-&gt;toString().size(), suffix-&gt;toString()) == 0);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if, and only if, length() is 0.&#13;
 *&#13;
 * @return true if length() is 0, otherwise false&#13;
 */&#13;
bool String::isEmpty() {&#13;
    return (this-&gt;s.length() == 0);&#13;
}&#13;
&#13;
std::string String::toString() {&#13;
    return s;&#13;
}&#13;
&#13;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, String &amp;str) {&#13;
    return s &lt;&lt; str.toString().c_str();&#13;
}&#13;
&#13;
String *operator+(String &amp;s1, String &amp;s2) {&#13;
    return new String(s1.toString() + s2.toString());&#13;
}&#13;
&#13;
String *String::operator=(String &amp;s) {&#13;
    return new String(s.toString());&#13;
}&#13;
</code>
<code lang="C#">ï»¿using System;&#13;
using System.Text;&#13;
&#13;
namespace JavaClasses {&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// The String class represents character strings.&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;author&gt;Petr Kozler (A13B0359P)&lt;/author&gt;&#13;
    public class String {&#13;
&#13;
        private string s;&#13;
        &#13;
        /// &lt;summary&gt;&#13;
        /// Constructs a new String by decoding the specified array of bytes using&#13;
        /// the platform's default charset.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="bytes"&gt;The bytes to be decoded into characters&#13;
        /// &lt;/param&gt;&#13;
        public String(sbyte[] bytes) {&#13;
            // parsing to the unsigned byte array&#13;
            byte[] unsigned = (byte[]) (Array) bytes;&#13;
            s = Encoding.Default.GetString(unsigned);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Constructs a new String by decoding the specified subarray of bytes using&#13;
        /// the platform's default charset.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="bytes"&gt;The bytes to be decoded into characters&#13;
        /// &lt;/param&gt;&lt;param name="offset"&gt;The index of the first byte to decode&#13;
        /// &lt;/param&gt;&lt;param name="length"&gt;The number of bytes to decode&#13;
        /// &lt;/param&gt;&#13;
        public String(sbyte[] bytes, int offset, int length) {&#13;
            byte[] unsigned = (byte[]) (Array) bytes;&#13;
            s = Encoding.Default.GetString(unsigned, offset, length);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Initializes a newly created String object so that it represents the same&#13;
        /// sequence of characters as the argument; in other words, the newly created&#13;
        /// string is a copy of the argument string. Unless an explicit copy of&#13;
        /// original is needed, use of this constructor is unnecessary since Strings&#13;
        /// are immutable.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;A String&#13;
        /// &lt;/param&gt;&#13;
        public String(string original) {&#13;
            s = original;&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Compares two strings lexicographically.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="anotherString"&gt;the String to be compared.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the value 0 if the argument string is equal to this string; a&#13;
        /// value less than 0 if this string is lexicographically less than the&#13;
        /// string argument; and a value greater than 0 if this string is&#13;
        /// lexicographically greater than the string argument.&#13;
        /// &lt;/returns&gt;&#13;
        public int compareTo(String anotherString) {&#13;
            return s.CompareTo(anotherString.s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Compares this string to the specified object.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="anObject"&gt;The object to compare this String against&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the given object represents a String equivalent to this&#13;
        /// string, false otherwise&#13;
        /// &lt;/returns&gt;&#13;
        public bool equals(Object anObject) {&#13;
            if (anObject == null) {&#13;
                return false;&#13;
            }&#13;
&#13;
            if (GetType() != anObject.GetType()) {&#13;
                return false;&#13;
            }&#13;
&#13;
            return s.Equals((anObject as  String).s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a new string that is a substring of this string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="beginIndex"&gt;the beginning index, inclusive.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the specified substring.&#13;
        /// &lt;/returns&gt;&#13;
        public String substring(int beginIndex) {&#13;
            return s.Substring(beginIndex);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a new string that is a substring of this string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="beginIndex"&gt;the beginning index, inclusive.&#13;
        /// &lt;/param&gt;&lt;param name="endIndex"&gt;the ending index, exclusive.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the specified substring.&#13;
        /// &lt;/returns&gt;&#13;
        public String substring(int beginIndex, int endIndex) {&#13;
            // calculating the length from the specified end index&#13;
            return s.Substring(beginIndex, endIndex - beginIndex);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the index within this string of the first occurrence of the&#13;
        /// specified character.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="ch"&gt;a character (Unicode code point).&#13;
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the character in the&#13;
        /// character sequence represented by this object, or -1 if the character&#13;
        /// does not occur.&#13;
        /// &lt;/returns&gt;&#13;
        public int indexOf(int ch) {&#13;
            return s.IndexOf((char) ch);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the index within this string of the first occurrence of the&#13;
        /// specified character, starting the search at the specified index.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="ch"&gt;a character (Unicode code point).&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index to start the search from.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the character in the&#13;
        /// character sequence represented by this object that is greater than or&#13;
        /// equal to fromIndex, or -1 if the character does not occur.&#13;
        /// &lt;/returns&gt;&#13;
        public int indexOf(int ch, int fromIndex) {&#13;
            return s.IndexOf((char) ch, fromIndex);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the index within this string of the first occurrence of the&#13;
        /// specified substring.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="str"&gt;the substring to search for.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the specified substring, or&#13;
        /// -1 if there is no such occurrence.&#13;
        /// &lt;/returns&gt;&#13;
        public int indexOf(String str) {&#13;
            return s.IndexOf(str.s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the index within this string of the first occurrence of the&#13;
        /// specified substring, starting at the specified index.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="str"&gt;the substring to search for.&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index from which to start the search.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the specified substring,&#13;
        /// starting at the specified index, or -1 if there is no such occurrence.&#13;
        /// &lt;/returns&gt;&#13;
        public int indexOf(String str, int fromIndex) {&#13;
            return s.IndexOf(str.s, fromIndex);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the length of this string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the length of the sequence of characters represented by this&#13;
        /// object.&#13;
        /// &lt;/returns&gt;&#13;
        public int length() {&#13;
            return s.Length;&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a copy of the string, with leading and trailing whitespace&#13;
        /// omitted.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;A copy of this string with leading and trailing white space&#13;
        /// removed, or this string if it has no leading or trailing white space.&#13;
        /// &lt;/returns&gt;&#13;
        public String trim() {&#13;
            return s.Trim();&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Converts all of the characters in this String to lower case using the&#13;
        /// rules of the default locale.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the String, converted to lowercase.&#13;
        /// &lt;/returns&gt;&#13;
        public String toLowerCase() {&#13;
            return s.ToLower();&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Converts all of the characters in this String to upper case using the&#13;
        /// rules of the default locale.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the String, converted to uppercase.&#13;
        /// &lt;/returns&gt;&#13;
        public String toUpperCase() {&#13;
            return s.ToUpper();&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the char value at the specified index.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="index"&gt;the index of the char value.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the char value at the specified index of this string. The first&#13;
        /// char value is at index 0.&#13;
        /// &lt;/returns&gt;&#13;
        public char charAt(int index) {&#13;
            return s[index];&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a new string resulting from replacing all occurrences of oldChar&#13;
        /// in this string with newChar.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="oldChar"&gt;the old character.&#13;
        /// &lt;/param&gt;&lt;param name="newChar"&gt;the new character.&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string derived from this string by replacing every occurrence&#13;
        /// of oldChar with newChar.&#13;
        /// &lt;/returns&gt;&#13;
        public String replace(char oldChar, char newChar) {&#13;
            return s.Replace(oldChar, newChar);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Tests if this string starts with the specified prefix.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="prefix"&gt;the prefix.&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the character sequence represented by the argument is a&#13;
        /// prefix of the character sequence represented by this string; false&#13;
        /// otherwise. Note also that true will be returned if the argument is an&#13;
        /// empty string or is equal to this String object as determined by the&#13;
        /// equals(Object) method.&#13;
        /// &lt;/returns&gt;&#13;
        public bool startsWith(String prefix) {&#13;
            return s.StartsWith(prefix.s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Tests if this string ends with the specified suffix.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="suffix"&gt;the suffix.&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the character sequence represented by the argument is a&#13;
        /// suffix of the character sequence represented by this object; false&#13;
        /// otherwise. Note that the result will be true if the argument is the empty&#13;
        /// string or is equal to this String object as determined by the&#13;
        /// equals(Object) method.&#13;
        /// &lt;/returns&gt;&#13;
        public bool endsWith(String suffix) {&#13;
            return s.EndsWith(suffix.s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if, and only if, length() is 0.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;true if length() is 0, otherwise false&#13;
        /// &lt;/returns&gt;&#13;
        public bool isEmpty() {&#13;
            return s.Length == 0;&#13;
        }&#13;
&#13;
        /*&#13;
            Returns the inner string value for processing by standard library classes.&#13;
        */&#13;
        public override string ToString() {&#13;
            return s;&#13;
        }&#13;
&#13;
        /*&#13;
            Defines the implicit operator so it is possible to instantiate&#13;
            this class by standard string value assignment.&#13;
        */&#13;
        public static implicit operator String(string original) {&#13;
            return new String(original);&#13;
        }&#13;
&#13;
        /*&#13;
            Defines the operator of concatenation so it is posible&#13;
            to use the plus operator the same way as for the standard strings.&#13;
        */&#13;
        public static String operator +(String s1, String s2) {&#13;
            return s1.s + s2.s;&#13;
        }&#13;
&#13;
    }&#13;
&#13;
}&#13;
</code>
<code lang="Free Pascal">unit StringUnit;

{$mode objfpc}{$H+}

interface

type
  (**
   * The String class represents character strings.
   *
   * @author Petr Kozler (A13B0359P)
   *)
  String_ = class
    private
      var str: ansiString;
    public
      constructor create(bytes: array of shortInt);
      constructor create(bytes: array of shortInt; offset: longInt; length: longInt);
      constructor create(original: ansiString);
      function compareTo(anotherString: String_) : longInt;
      function equals(anObject: TObject) : boolean; override;
      function substring(beginIndex: longInt) : String_;
      function substring(beginIndex: longInt; endIndex: longInt) : String_;
      function indexOf(ch: longInt) : longInt;
      function indexOf(ch: longInt; fromIndex: longInt) : longInt;
      function indexOf(s: String_) : longInt;
      function indexOf(s: String_; fromIndex: longInt) : longInt;
      function length() : longInt;
      function trim() : String_;
      function toLowerCase() : String_;
      function toUpperCase() : String_;
      function charAt(index: longInt) : ansiChar;
      function replace(oldChar: ansiChar; newChar: ansiChar) : String_;
      function startsWith(prefix: String_) : boolean;
      function endsWith(suffix: String_) : boolean;
      function isEmpty() : boolean;
      function toString() : ansiString; override;
  end;

operator := (original: ansiString) s: String_;
operator + (s1: String_; s2: String_) s: String_;

implementation

uses
  SysUtils, StrUtils;

(**
 * Constructs a new String by decoding the specified array of bytes using
 * the platform's default charset.
 *
 * @param bytes The bytes to be decoded into characters
 *)
constructor String_.create(bytes: array of shortInt);
begin
  setString(str, @bytes[0], System.length(bytes));
end;

(**
 * Constructs a new String by decoding the specified subarray of bytes using
 * the platform's default charset.
 *
 * @param bytes The bytes to be decoded into characters
 * @param offset The index of the first byte to decode
 * @param length The number of bytes to decode
 *)
constructor String_.create(bytes: array of shortInt; offset: longInt; length: longInt);
begin
  setString(str, @bytes[offset], length);
end;

(**
 * Initializes a newly created String object so that it represents the same
 * sequence of characters as the argument; in other words, the newly created
 * string is a copy of the argument string. Unless an explicit copy of
 * original is needed, use of this constructor is unnecessary since Strings
 * are immutable.
 *
 * @param original A String
 *)
constructor String_.create(original: ansiString);
begin
  str := original;
end;

(**
 * Compares two strings lexicographically.
 *
 * @param anotherString the String to be compared.
 * @return the value 0 if the argument string is equal to this string; a
 * value less than 0 if this string is lexicographically less than the
 * string argument; and a value greater than 0 if this string is
 * lexicographically greater than the string argument.
 *)
function String_.compareTo(anotherString: String_) : longInt;
begin
  compareTo := ansiCompareStr(str, anotherString.str);
end;

(**
 * Compares this string to the specified object.
 *
 * @param anObject The object to compare this String against
 * @return true if the given object represents a String equivalent to this
 * string, false otherwise
 *)
function String_.equals(anObject: TObject) : boolean;
begin
  if anObject = nil then begin
    exit(false);
  end;

  if typeOf(self) &lt;&gt; typeOf(anObject) then begin
    exit(false);
  end;

  equals := (ansiCompareStr(self.str, String_(anObject).str) = 0);
end;

(**
 * Returns a new string that is a substring of this string.
 *
 * @param beginIndex the beginning index, inclusive.
 * @return the specified substring.
 *)
function String_.substring(beginIndex: longInt) : String_;
begin
  substring := substring(beginIndex, System.length(str));
end;

(**
 * Returns a new string that is a substring of this string.
 *
 * @param beginIndex the beginning index, inclusive.
 * @param endIndex the ending index, exclusive.
 * @return the specified substring.
 *)
function String_.substring(beginIndex: longInt; endIndex: longInt) : String_;
var
  s: String_;
begin
  s.create(copy(str, beginIndex + 1, endIndex - beginIndex));
  substring := s;
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified character.
 *
 * @param ch a character (Unicode code point).
 * @return the index of the first occurrence of the character in the
 * character sequence represented by this object, or -1 if the character
 * does not occur.
 *)
function String_.indexOf(ch: longInt) : longInt;
begin
  indexOf := indexOf(ch, 0);
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified character, starting the search at the specified index.
 *
 * @param ch a character (Unicode code point).
 * @param fromIndex the index to start the search from.
 * @return the index of the first occurrence of the character in the
 * character sequence represented by this object that is greater than or
 * equal to fromIndex, or -1 if the character does not occur.
 *)
function String_.indexOf(ch: longInt; fromIndex: longInt) : longInt;
var
  substr: ansiString;
begin
  substr := copy(str, fromIndex + 1, System.length(str) - fromIndex);
  indexOf := pos(ansiChar(ch), substr);
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified substring.
 *
 * @param str the substring to search for.
 * @return the index of the first occurrence of the specified substring, or
 * -1 if there is no such occurrence.
 *)
function String_.indexOf(s: String_) : longInt;
begin
  indexOf := indexOf(s, 0);
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified substring, starting at the specified index.
 *
 * @param str the substring to search for.
 * @param fromIndex the index from which to start the search.
 * @return the index of the first occurrence of the specified substring,
 * starting at the specified index, or -1 if there is no such occurrence.
 *)
function String_.indexOf(s: String_; fromIndex: longInt) : longInt;
var
  substr: ansiString;
begin
  substr := copy(str, fromIndex + 1, System.length(str) - fromIndex + 1);
  indexOf := pos(s.str, substr);
end;

(**
 * Returns the length of this string.
 *
 * @return the length of the sequence of characters represented by this
 * object.
 *)
function String_.length() : longInt;
begin
  length := System.length(str);
end;

(**
 * Returns a copy of the string, with leading and trailing whitespace
 * omitted.
 *
 * @return A copy of this string with leading and trailing white space
 * removed, or this string if it has no leading or trailing white space.
 *)
function String_.trim() : String_;
var
  s: String_;
begin
  s.create(SysUtils.trim(str));
  trim := s;
end;

(**
 * Converts all of the characters in this String to lower case using the
 * rules of the default locale.
 *
 * @return the String, converted to lowercase.
 *)
function String_.toLowerCase() : String_;
var
  s: String_;
begin
  s.create(lowerCase(str));
  toLowerCase := s;
end;

(**
 * Converts all of the characters in this String to upper case using the
 * rules of the default locale.
 *
 * @return the String, converted to uppercase.
 *)
function String_.toUpperCase() : String_;
var
  s: String_;
begin
  s.create(upperCase(str));
  toUpperCase := s;
end;

(**
 * Returns the char value at the specified index.
 *
 * @param index the index of the char value.
 * @return the char value at the specified index of this string. The first
 * char value is at index 0.
 *)
function String_.charAt(index: longInt) : ansiChar;
begin
  charAt := str[index];
end;

(**
 * Returns a new string resulting from replacing all occurrences of oldChar
 * in this string with newChar.
 *
 * @param oldChar the old character.
 * @param newChar the new character.
 * @return a string derived from this string by replacing every occurrence
 * of oldChar with newChar.
 *)
function String_.replace(oldChar: ansiChar; newChar: ansiChar) : String_;
begin
  replace := replaceStr(str, oldChar, newChar);
end;

(**
 * Tests if this string starts with the specified prefix.
 *
 * @param prefix the prefix.
 * @return true if the character sequence represented by the argument is a
 * prefix of the character sequence represented by this string; false
 * otherwise. Note also that true will be returned if the argument is an
 * empty string or is equal to this String object as determined by the
 * equals(Object) method.
 *)
function String_.startsWith(prefix: String_) : boolean;
begin
  startsWith := ansiStartsStr(prefix.toString(), str);
end;

(**
 * Tests if this string ends with the specified suffix.
 *
 * @param suffix the suffix.
 * @return true if the character sequence represented by the argument is a
 * suffix of the character sequence represented by this object; false
 * otherwise. Note that the result will be true if the argument is the empty
 * string or is equal to this String object as determined by the
 * equals(Object) method.
 *)
function String_.endsWith(suffix: String_) : boolean;
begin
  endsWith := ansiEndsStr(suffix.toString(), str);
end;

(**
 * Returns true if, and only if, length() is 0.
 *
 * @return true if length() is 0, otherwise false
 *)
function String_.isEmpty() : boolean;
begin
  isEmpty := (self.length() = 0);
end;

function String_.toString() : ansiString;
begin
  toString := str;
end;

operator := (original: ansiString) s: String_;
begin
  s.create(original);
end;

operator + (s1: String_; s2: String_) s: String_;
begin
  s.create(s1.str + s2.str);
end;

end.

</code>
</codes>
