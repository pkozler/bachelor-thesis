<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<codes>
<code lang="C">#ifndef STRING_INCLUDED&#13;
#define STRING_INCLUDED&#13;
&#13;
#include &lt;stdbool.h&gt;&#13;
#include &lt;stdint.h&gt;&#13;
&#13;
/**&#13;
 * The String struct represents character strings.&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
&#13;
typedef struct {&#13;
    char *s;&#13;
    int32_t len;&#13;
} String;&#13;
&#13;
String *new_StringB(int8_t *value, int32_t length);&#13;
String *new_StringRangeB(int8_t *value, int32_t offset, int32_t length);&#13;
String *new_String(char *original);&#13;
void delete_String(String *ptr);&#13;
int32_t compareToStr(String *ptr, String *anotherString);&#13;
bool equalsStr(String *ptr, String *anObject);&#13;
String *substring(String *ptr, int32_t beginIndex);&#13;
String *substringTo(String *ptr, int32_t beginIndex, int32_t endIndex);&#13;
int32_t indexOfC(String *ptr, int32_t ch);&#13;
int32_t indexOfFromC(String *ptr, int32_t ch, int32_t fromIndex);&#13;
int32_t indexOfStr(String *ptr, String *str);&#13;
int32_t indexOfFromStr(String *ptr, String *str, int32_t fromIndex);&#13;
int32_t length(String *ptr);&#13;
String *trim(String *ptr);&#13;
String *toLowerCase(String *ptr);&#13;
String *toUpperCase(String *ptr);&#13;
char charAt(String *ptr, int32_t index);&#13;
String *replace(String *ptr, char oldChar, char newChar);&#13;
bool startsWith(String *ptr, String *prefix);&#13;
bool endsWith(String *ptr, String *suffix);&#13;
bool isEmptyStr(String *ptr);&#13;
String *toStringStr(String *ptr);&#13;
&#13;
#endif	/* STRING_INCLUDED */&#13;
&#13;
&#13;
#include "String.h"&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;ctype.h&gt;&#13;
#include &lt;wchar.h&gt;&#13;
&#13;
/**&#13;
 * Constructs a new String by decoding the specified array of bytes using&#13;
 * the ANSI charset.&#13;
 *&#13;
 * @param bytes The bytes to be decoded into characters&#13;
 * @param length The array length&#13;
 */&#13;
String *new_StringB(int8_t *value, int32_t length) {&#13;
    return new_StringRangeB(value, 0, length);&#13;
}&#13;
&#13;
/**&#13;
 * Constructs a new String by decoding the specified subarray of bytes using&#13;
 * the ANSI charset.&#13;
 *&#13;
 * @param bytes The bytes to be decoded into characters&#13;
 * @param offset The index of the first byte to decode&#13;
 * @param length The number of bytes to decode&#13;
 */&#13;
String *new_StringRangeB(int8_t *value, int32_t offset, int32_t length) {&#13;
    String *str = malloc(sizeof(String));&#13;
    str-&gt;s = malloc(sizeof(char) * (length + 1));&#13;
    str-&gt;s[0] = '\0';&#13;
    strncat(str-&gt;s, (char *) value + offset, length);&#13;
    str-&gt;len = strlen(str-&gt;s);&#13;
&#13;
    return str;&#13;
}&#13;
&#13;
/**&#13;
 * Initializes a newly created String structure so that it represents the same&#13;
 * sequence of characters as the argument; in other words, the inner null terminated&#13;
 * char array of the newly created String structure instance is a copy of the argument array.&#13;
 *&#13;
 * @param original A String&#13;
 */&#13;
String *new_String(char *original) {&#13;
    String *str = malloc(sizeof(String));&#13;
    str-&gt;s = strdup(original);&#13;
    str-&gt;len = strlen(str-&gt;s);&#13;
&#13;
    return str;&#13;
}&#13;
&#13;
void delete_String(String *ptr) {&#13;
    free(ptr-&gt;s);&#13;
    free(ptr);&#13;
}&#13;
&#13;
/**&#13;
 * Compares two strings lexicographically.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param anotherString the String to be compared.&#13;
 * @return the value 0 if the first string is equal to the second string; a&#13;
 * value less than 0 if the first string is lexicographically less than the&#13;
 * second string; and a value greater than 0 if the first string is&#13;
 * lexicographically greater than the second string.&#13;
 */&#13;
int32_t compareToStr(String *ptr, String *anotherString) {&#13;
    return strcmp(ptr-&gt;s, anotherString-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Compares the one specified string to the other.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param anObject The String to compare the first one against&#13;
 * @return true if the second given String represents a String equivalent to the first&#13;
 * string, false otherwise&#13;
 */&#13;
bool equalsStr(String *ptr, String *anObject) {&#13;
    if (ptr == NULL || anObject == NULL) {&#13;
        return false;&#13;
    }&#13;
&#13;
    if (sizeof(*ptr) != sizeof(*anObject)) {&#13;
        return false;&#13;
    }&#13;
    &#13;
    return !strcmp(ptr-&gt;s, anObject-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string that is a substring of the specified string.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param beginIndex the beginning index, inclusive.&#13;
 * @return the specified substring.&#13;
 */&#13;
String *substring(String *ptr, int32_t beginIndex) {&#13;
    return substringTo(ptr, beginIndex, ptr-&gt;len);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string that is a substring of the specified string.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param beginIndex the beginning index, inclusive.&#13;
 * @param endIndex the ending index, exclusive.&#13;
 * @return the specified substring.&#13;
 */&#13;
String *substringTo(String *ptr, int32_t beginIndex, int32_t endIndex) {&#13;
    int32_t len = endIndex - beginIndex;&#13;
    char *to = (char*) malloc(len * sizeof(char));&#13;
    to[0] = '\0';&#13;
    &#13;
    strncat(to, ptr-&gt;s + beginIndex, (size_t) len);&#13;
&#13;
    String *str = new_String(to);&#13;
    free(to);&#13;
&#13;
    return str;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within the specified string of the first occurrence of the&#13;
 * specified character.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param ch a character (Unicode code point).&#13;
 * @return the index of the first occurrence of the character in the&#13;
 * character sequence represented by the specified string, or -1 if the character&#13;
 * does not occur.&#13;
 */&#13;
int32_t indexOfC(String *ptr, int32_t ch) {&#13;
    return indexOfFromC(ptr, ch, 0);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within the specified string of the first occurrence of the&#13;
 * specified character, starting the search at the specified index.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param ch a character (Unicode code point).&#13;
 * @param fromIndex the index to start the search from.&#13;
 * @return the index of the first occurrence of the character in the&#13;
 * character sequence represented by the specified string that is greater than or&#13;
 * equal to fromIndex, or -1 if the character does not occur.&#13;
 */&#13;
int32_t indexOfFromC(String *ptr, int32_t ch, int32_t fromIndex) {&#13;
    char* str = ptr-&gt;s + fromIndex;&#13;
    char* c = strchr(str, ch);&#13;
    &#13;
    if (c == NULL) {&#13;
        return -1;&#13;
    }&#13;
    &#13;
    size_t index = (size_t)(c - ptr-&gt;s);&#13;
&#13;
    return (int32_t) index;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within the specified string of the first occurrence of the&#13;
 * specified substring.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param str the substring to search for.&#13;
 * @return the index of the first occurrence of the specified substring, or&#13;
 * -1 if there is no such occurrence.&#13;
 */&#13;
int32_t indexOfStr(String *ptr, String *str) {&#13;
    return indexOfFromStr(ptr, str, 0);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within the specified string of the first occurrence of the&#13;
 * specified substring, starting at the specified index.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param str the substring to search for.&#13;
 * @param fromIndex the index from which to start the search.&#13;
 * @return the index of the first occurrence of the specified substring,&#13;
 * starting at the specified index, or -1 if there is no such occurrence.&#13;
 */&#13;
int32_t indexOfFromStr(String *ptr, String *str, int32_t fromIndex) {&#13;
    char* str0 = ptr-&gt;s + fromIndex;&#13;
    char* s = strstr(str0, str-&gt;s);&#13;
&#13;
    if (s == NULL) {&#13;
        return -1;&#13;
    }&#13;
    &#13;
    size_t index = (size_t)(s - ptr-&gt;s);&#13;
&#13;
    return (int32_t) index;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the length of the specified string.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @return the length of the sequence of characters represented by the specified&#13;
 * string.&#13;
 */&#13;
int32_t length(String *ptr) {&#13;
    return ptr-&gt;len;&#13;
}&#13;
&#13;
/**&#13;
 * Returns a copy of the string, with leading and trailing whitespace&#13;
 * omitted.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @return A copy of the specified string with leading and trailing white space&#13;
 * removed, or the specified string if it has no leading or trailing white space.&#13;
 */&#13;
String *trim(String *ptr) {&#13;
    int32_t i, j;&#13;
&#13;
    for (i = 0; isspace(ptr-&gt;s[i]); i++);&#13;
    for (j = ptr-&gt;len - 1; isspace(ptr-&gt;s[j]); j--);&#13;
    int32_t num = j - i + 1;&#13;
&#13;
    char *str = (char *) malloc(num + 1);&#13;
    strncpy(str, ptr-&gt;s + i, num);&#13;
    str[num] = '\0';&#13;
&#13;
    String *changedStr = new_String(str);&#13;
    free(str);&#13;
&#13;
    return changedStr;&#13;
}&#13;
&#13;
/**&#13;
 * Converts all of the characters in the specified String to lower case using the&#13;
 * rules of the default locale.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @return the String, converted to lowercase.&#13;
 */&#13;
String *toLowerCase(String *ptr) {&#13;
    char *str = (char*) malloc(ptr-&gt;len);&#13;
&#13;
    int32_t i = 0;&#13;
    char c;&#13;
    while (ptr-&gt;s[i]) {&#13;
        c = ptr-&gt;s[i];&#13;
        str[i] = tolower((int32_t)c);&#13;
        i++;&#13;
    }&#13;
    str[i] = '\0';&#13;
&#13;
    String *changedStr = new_String(str);&#13;
    free(str);&#13;
&#13;
    return changedStr;&#13;
}&#13;
&#13;
/**&#13;
 * Converts all of the characters in the specified String to upper case using the&#13;
 * rules of the default locale.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @return the String, converted to uppercase.&#13;
 */&#13;
String *toUpperCase(String *ptr) {&#13;
    char *str = (char*) malloc(ptr-&gt;len);&#13;
&#13;
    int32_t i = 0;&#13;
    char c;&#13;
    while (ptr-&gt;s[i]) {&#13;
        c = ptr-&gt;s[i];&#13;
        str[i] = toupper((int32_t)c);&#13;
        i++;&#13;
    }&#13;
    str[i] = '\0';&#13;
&#13;
    String *changedStr = new_String(str);&#13;
    free(str);&#13;
&#13;
    return changedStr;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the char value at the specified index.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param index the index of the char value.&#13;
 * @return the char value at the specified index of the specified string. The first&#13;
 * char value is at index 0.&#13;
 */&#13;
char charAt(String *ptr, int32_t index) {&#13;
    return ptr-&gt;s[index];&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string resulting from replacing all occurrences of oldChar&#13;
 * in the specified string with newChar.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param oldChar the old character.&#13;
 * @param newChar the new character.&#13;
 * @return a string derived from the specified string by replacing every occurrence&#13;
 * of oldChar with newChar.&#13;
 */&#13;
String *replace(String *ptr, char oldChar, char newChar) {&#13;
    char *str = strdup(ptr-&gt;s);&#13;
    int32_t i;&#13;
&#13;
    for (i = 0; str[i]; i++) {&#13;
        if (str[i] == oldChar) {&#13;
            str[i] = newChar;&#13;
        }&#13;
    }&#13;
&#13;
    String *replacedStr = new_String(str);&#13;
    free(str);&#13;
&#13;
    return replacedStr;&#13;
}&#13;
&#13;
/**&#13;
 * Tests if the specified string starts with the specified prefix.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param prefix the prefix.&#13;
 * @return true if the character sequence represented by the second string is a&#13;
 * prefix of the character sequence represented by the first string; false&#13;
 * otherwise. Note also that true will be returned if the second string is an&#13;
 * empty string or is equal to the first String structure as determined by the&#13;
 * equalsStr(String *, String *) function.&#13;
 */&#13;
bool startsWith(String *ptr, String *prefix) {&#13;
    return ptr-&gt;len &lt; prefix-&gt;len ? false&#13;
            : strncmp(prefix-&gt;s, ptr-&gt;s, prefix-&gt;len) == 0;&#13;
}&#13;
&#13;
/**&#13;
 * Tests if the specified string ends with the specified suffix.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @param suffix the suffix.&#13;
 * @return true if the character sequence represented by the second string is a&#13;
 * suffix of the character sequence represented by the first string; false&#13;
 * otherwise. Note that the result will be true if the second string is the empty&#13;
 * string or is equal to the first String structure as determined by the&#13;
 * equalsStr(String *, String *) function.&#13;
 */&#13;
bool endsWith(String *ptr, String *suffix) {&#13;
    return ptr-&gt;len &lt; suffix-&gt;len ? false&#13;
            : strncmp(suffix-&gt;s, ptr-&gt;s + (ptr-&gt;len - suffix-&gt;len), suffix-&gt;len) == 0;&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if, and only if, length() is 0.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @return true if length() is 0, otherwise false&#13;
 */&#13;
bool isEmptyStr(String *ptr) {&#13;
    return ptr-&gt;len == 0;&#13;
}&#13;
&#13;
/**&#13;
 * The specified structure (which is already a string!) is itself returned.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @return the string itself.&#13;
 */&#13;
String *toStringStr(String *ptr) {&#13;
    return new_String(ptr-&gt;s);&#13;
}&#13;
</code>
<code lang="C++">#ifndef STRING_INCLUDED&#13;
#define	STRING_INCLUDED&#13;
&#13;
#include &lt;iostream&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
class String;&#13;
&#13;
/**&#13;
 * Class Object is the root of the class hierarchy.&#13;
 */&#13;
class Object {&#13;
public:&#13;
    virtual bool equals(Object *obj);&#13;
    virtual String *toString();&#13;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, Object &amp;o);&#13;
};&#13;
&#13;
/**&#13;
 * This abstract class imposes a total ordering on the objects of each class that implements it.&#13;
 */&#13;
class Comparable : public Object {&#13;
public:&#13;
    /**&#13;
     * Compares this object with the specified object for order.&#13;
     *&#13;
     * @param o the object to be compared.&#13;
     * @return a negative integer, zero, or a positive integer as this object&#13;
     * is less than, equal to, or greater than the specified object.&#13;
     */&#13;
    virtual int32_t compareTo(Object *o) = 0;&#13;
};&#13;
&#13;
/**&#13;
 * A comparison function, which imposes a total ordering on some collection of objects.&#13;
 */&#13;
class Comparator : public Object {&#13;
public:&#13;
    /**&#13;
     * Compares its two arguments for order.&#13;
     *&#13;
     * @param o1 the first object to be compared.&#13;
     * @param o2 the second object to be compared.&#13;
     * @return a negative integer, zero, or a positive integer as the&#13;
     * first argument is less than, equal to, or greater than the second.&#13;
     */&#13;
    virtual int32_t compare(Object *o1, Object *o2) = 0;&#13;
};&#13;
&#13;
/**&#13;
 * The String class represents character strings.&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
class String : public Comparable {&#13;
    std::string s;&#13;
    void init(int8_t *value, int32_t offset, int32_t length);&#13;
public:&#13;
    const std::string _s() const { return s; }&#13;
    String(int8_t *value, int32_t length);&#13;
    String(int8_t *value, int32_t offset, int32_t length);&#13;
    String(std::string original);&#13;
    int32_t compareTo(Object *anotherString);&#13;
    bool equals(Object *anObject);&#13;
    String *substring(int32_t beginIndex);&#13;
    String *substring(int32_t beginIndex, int32_t endIndex);&#13;
    int32_t indexOf(int32_t ch);&#13;
    int32_t indexOf(int32_t ch, int32_t fromIndex);&#13;
    int32_t indexOf(String *str);&#13;
    int32_t indexOf(String *str, int32_t fromIndex);&#13;
    int32_t length();&#13;
    String *trim();&#13;
    String *toLowerCase();&#13;
    String *toUpperCase();&#13;
    char charAt(int32_t index);&#13;
    String *replace(char oldChar, char newChar);&#13;
    bool startsWith(String *prefix);&#13;
    bool endsWith(String *suffix);&#13;
    bool isEmpty();&#13;
    String *toString();&#13;
    String *operator=(std::string &amp;s);&#13;
};&#13;
&#13;
#endif	// STRING_INCLUDED&#13;
&#13;
&#13;
#include "String_.h"&#13;
&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;sstream&gt;&#13;
#include &lt;iomanip&gt;&#13;
&#13;
/**&#13;
 * Indicates whether some other object is "equal to" this one.&#13;
 *&#13;
 * @param obj the pointer object with which to compare.&#13;
 * @return true if this object is the same as the obj argument; false otherwise.&#13;
 */&#13;
bool Object::equals(Object *obj) {&#13;
    return this == obj;&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the object.&#13;
 *&#13;
 * @return a string representation of the object.&#13;
 */&#13;
String *Object::toString() {&#13;
    std::stringstream stream;&#13;
    stream &lt;&lt; std::hex &lt;&lt; this;&#13;
    return new String(stream.str());&#13;
}&#13;
&#13;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, Object &amp;o) {&#13;
    return s &lt;&lt; o.toString()-&gt;_s();&#13;
}&#13;
&#13;
void String::init(int8_t *value, int32_t offset, int32_t length) {&#13;
    char *s = new char[length + 1];&#13;
    &#13;
    int32_t i;&#13;
    for (i = 0; i &lt; length; i++) {&#13;
        s[i] = value[i + offset];&#13;
    }&#13;
    &#13;
    s[i] = '\0';&#13;
    this-&gt;s = s;&#13;
    delete[] s;&#13;
}&#13;
&#13;
/**&#13;
 * Constructs a new String by decoding the specified array of bytes using&#13;
 * the ANSI charset.&#13;
 *&#13;
 * @param bytes The bytes to be decoded into characters&#13;
 * @param length The array length&#13;
 */&#13;
String::String(int8_t *value, int32_t length) {&#13;
    init(value, 0, length);&#13;
}&#13;
&#13;
/**&#13;
 * Constructs a new String by decoding the specified subarray of bytes using&#13;
 * the ANSI charset.&#13;
 *&#13;
 * @param bytes The bytes to be decoded into characters&#13;
 * @param offset The index of the first byte to decode&#13;
 * @param length The number of bytes to decode&#13;
 */&#13;
String::String(int8_t *value, int32_t offset, int32_t length) {&#13;
    init(value, offset, length);&#13;
}&#13;
&#13;
/**&#13;
 * Initializes a newly created String object so that it represents the same&#13;
 * sequence of characters as the argument; in other words, the inner string of the&#13;
 * newly created String object is a copy of the argument string.&#13;
 *&#13;
 * @param original A String&#13;
 */&#13;
String::String(std::string original) {&#13;
    this-&gt;s = original;&#13;
}&#13;
&#13;
/**&#13;
 * Compares two strings lexicographically.&#13;
 *&#13;
 * @param anotherString the String to be compared.&#13;
 * @return the value 0 if the argument string is equal to this string; a&#13;
 * value less than 0 if this string is lexicographically less than the&#13;
 * string argument; and a value greater than 0 if this string is&#13;
 * lexicographically greater than the string argument.&#13;
 */&#13;
int32_t String::compareTo(Object *anotherString) {&#13;
    return this-&gt;s.compare(((String *)anotherString)-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Compares this string to the specified object.&#13;
 *&#13;
 * @param anObject The object to compare this String against&#13;
 * @return true if the given object represents a String equivalent to this&#13;
 * string, false otherwise&#13;
 */&#13;
bool String::equals(Object *anObject) {&#13;
    if (anObject == nullptr) {&#13;
        return false;&#13;
    }&#13;
&#13;
    if (sizeof(this) != sizeof(*anObject)) {&#13;
        return false;&#13;
    }&#13;
    &#13;
    return !this-&gt;s.compare(((String *)anObject)-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string that is a substring of this string.&#13;
 * &#13;
 * @param beginIndex the beginning index, inclusive.&#13;
 * @return the specified substring.&#13;
 */&#13;
String *String::substring(int32_t beginIndex) {&#13;
    return new String(this-&gt;s.substr(beginIndex));&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string that is a substring of this string.&#13;
 *&#13;
 * @param beginIndex the beginning index, inclusive.&#13;
 * @param endIndex the ending index, exclusive.&#13;
 * @return the specified substring.&#13;
 */&#13;
String *String::substring(int32_t beginIndex, int32_t endIndex) {&#13;
    return new String(this-&gt;s.substr(beginIndex, endIndex - beginIndex));&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified character.&#13;
 *&#13;
 * @param ch a character (Unicode code point).&#13;
 * @return the index of the first occurrence of the character in the&#13;
 * character sequence represented by this object, or -1 if the character&#13;
 * does not occur.&#13;
 */&#13;
int32_t String::indexOf(int32_t ch) {&#13;
    return this-&gt;s.find((char) ch);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified character, starting the search at the specified index.&#13;
 *&#13;
 * @param ch a character (Unicode code point).&#13;
 * @param fromIndex the index to start the search from.&#13;
 * @return the index of the first occurrence of the character in the&#13;
 * character sequence represented by this object that is greater than or&#13;
 * equal to fromIndex, or -1 if the character does not occur.&#13;
 */&#13;
int32_t String::indexOf(int32_t ch, int32_t fromIndex) {&#13;
    return this-&gt;s.find((char) ch, fromIndex);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified substring.&#13;
 *&#13;
 * @param str the substring to search for.&#13;
 * @return the index of the first occurrence of the specified substring, or&#13;
 * -1 if there is no such occurrence.&#13;
 */&#13;
int32_t String::indexOf(String *str) {&#13;
    return this-&gt;s.find(str-&gt;s);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the index within this string of the first occurrence of the&#13;
 * specified substring, starting at the specified index.&#13;
 *&#13;
 * @param str the substring to search for.&#13;
 * @param fromIndex the index from which to start the search.&#13;
 * @return the index of the first occurrence of the specified substring,&#13;
 * starting at the specified index, or -1 if there is no such occurrence.&#13;
 */&#13;
int32_t String::indexOf(String *str, int32_t fromIndex) {&#13;
    return this-&gt;s.find(str-&gt;s, fromIndex);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the length of this string.&#13;
 *&#13;
 * @return the length of the sequence of characters represented by this&#13;
 * object.&#13;
 */&#13;
int32_t String::length() {&#13;
    return this-&gt;s.length();&#13;
}&#13;
&#13;
/**&#13;
 * Returns a copy of the string, with leading and trailing whitespace&#13;
 * omitted.&#13;
 *&#13;
 * @return A copy of this string with leading and trailing white space&#13;
 * removed, or this string if it has no leading or trailing white space.&#13;
 */&#13;
String *String::trim() {&#13;
    const char* white_spaces = " \t\n\x0b\r\f";&#13;
&#13;
    int32_t first = this-&gt;s.find_first_not_of(white_spaces);&#13;
&#13;
    if (first == std::string::npos) {&#13;
        return new String(std::string(""));&#13;
    }&#13;
&#13;
    int32_t last = this-&gt;s.find_last_not_of(white_spaces);&#13;
&#13;
    return new String(this-&gt;s.substr(first, last - first + 1));&#13;
}&#13;
&#13;
/**&#13;
 * Converts all of the characters in this String to lower case using the&#13;
 * rules of the default locale.&#13;
 *&#13;
 * @return the String, converted to lowercase.&#13;
 */&#13;
String *String::toLowerCase() {&#13;
    std::string lowerCaseStr = this-&gt;s;&#13;
    std::transform(lowerCaseStr.begin(), lowerCaseStr.end(), lowerCaseStr.begin(), ::tolower);&#13;
    return new String(lowerCaseStr);&#13;
}&#13;
&#13;
/**&#13;
 * Converts all of the characters in this String to upper case using the&#13;
 * rules of the default locale.&#13;
 *&#13;
 * @return the String, converted to uppercase.&#13;
 */&#13;
String *String::toUpperCase() {&#13;
    std::string upperCaseStr = this-&gt;s;&#13;
    std::transform(upperCaseStr.begin(), upperCaseStr.end(), upperCaseStr.begin(), ::toupper);&#13;
    return new String(upperCaseStr);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the char value at the specified index.&#13;
 *&#13;
 * @param index the index of the char value.&#13;
 * @return the char value at the specified index of this string. The first&#13;
 * char value is at index 0.&#13;
 */&#13;
char String::charAt(int32_t index) {&#13;
    return this-&gt;s.at(index);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a new string resulting from replacing all occurrences of oldChar&#13;
 * in this string with newChar.&#13;
 *&#13;
 * @param oldChar the old character.&#13;
 * @param newChar the new character.&#13;
 * @return a string derived from this string by replacing every occurrence&#13;
 * of oldChar with newChar.&#13;
 */&#13;
String *String::replace(char oldChar, char newChar) {&#13;
    std::string str = this-&gt;s;&#13;
    std::replace(str.begin(), str.end(), oldChar, newChar);&#13;
&#13;
    return new String(str);&#13;
}&#13;
&#13;
/**&#13;
 * Tests if this string starts with the specified prefix.&#13;
 *&#13;
 * @param prefix the prefix.&#13;
 * @return true if the character sequence represented by the argument is a&#13;
 * prefix of the character sequence represented by this string; false&#13;
 * otherwise. Note also that true will be returned if the argument is an&#13;
 * empty string or is equal to this String object as determined by the&#13;
 * equals(Object) method.&#13;
 */&#13;
bool String::startsWith(String *prefix) {&#13;
    return (s.size() &gt;= prefix-&gt;_s().size() &amp;&amp; s.find(prefix-&gt;_s()) == 0);&#13;
}&#13;
&#13;
/**&#13;
 * Tests if this string ends with the specified suffix.&#13;
 *&#13;
 * @param suffix the suffix.&#13;
 * @return true if the character sequence represented by the argument is a&#13;
 * suffix of the character sequence represented by this object; false&#13;
 * otherwise. Note that the result will be true if the argument is the empty&#13;
 * string or is equal to this String object as determined by the&#13;
 * equals(Object) method.&#13;
 */&#13;
bool String::endsWith(String *suffix) {&#13;
    return (s.size() &gt;= suffix-&gt;_s().size() &amp;&amp;&#13;
            s.compare(s.size() - suffix-&gt;_s().size(), suffix-&gt;_s().size(), suffix-&gt;_s()) == 0);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if, and only if, length() is 0.&#13;
 *&#13;
 * @return true if length() is 0, otherwise false&#13;
 */&#13;
bool String::isEmpty() {&#13;
    return (this-&gt;s.length() == 0);&#13;
}&#13;
&#13;
/**&#13;
 * This object (which is already a string!) is itself returned.&#13;
 *&#13;
 * @return the string itself.&#13;
 */&#13;
String *String::toString() {&#13;
    return new String(s);&#13;
}&#13;
&#13;
String *String::operator=(std::string &amp;s) {&#13;
    return new String(s);&#13;
}&#13;
</code>
<code lang="C#">ï»¿using System;&#13;
using System.Collections.Generic;&#13;
using System.Text;&#13;
&#13;
namespace JavaClasses&#13;
{&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// Class Object is the root of the class hierarchy.&#13;
    /// &lt;/summary&gt;&#13;
    public class Object&#13;
    {&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Indicates whether some other object is "equal to" this one.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="obj"&gt;the reference object with which to compare.&lt;/param&gt;&#13;
        /// &lt;returns&gt;true if this object is the same as the obj argument; false otherwise.&lt;/returns&gt;&#13;
        public virtual bool equals(Object obj)&#13;
        {&#13;
            return this == obj;&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the object.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;a string representation of the object.&lt;/returns&gt;&#13;
        public virtual String toString()&#13;
        {&#13;
            return new String(base.ToString());&#13;
        }&#13;
&#13;
        public override bool Equals(object obj)&#13;
        {&#13;
            return equals(obj as Object);&#13;
        }&#13;
&#13;
        public override string ToString()&#13;
        {&#13;
            return toString().s;&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// This abstract class imposes a total ordering on the objects of each class that implements it.&#13;
    /// &lt;/summary&gt;&#13;
    public abstract class Comparable : Object, IComparable&lt;Object&gt;&#13;
    {&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Compares this object with the specified object for order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="o"&gt;the object to be compared.&lt;/param&gt;&#13;
        /// &lt;returns&gt;a negative integer, zero, or a positive integer as this object&#13;
        /// is less than, equal to, or greater than the specified object.&lt;/returns&gt;&#13;
        public abstract int compareTo(Object o);&#13;
&#13;
        public int CompareTo(Object o)&#13;
        {&#13;
            return compareTo(o);&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// A comparison function, which imposes a total ordering on some collection of objects.&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;&#13;
    public abstract class Comparator : Object, IComparer&lt;Object&gt;&#13;
    {&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Compares its two arguments for order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="o1"&gt;the first object to be compared.&lt;/param&gt;&#13;
        /// &lt;param name="o2"&gt;the second object to be compared.&lt;/param&gt;&#13;
        /// &lt;returns&gt;negative integer, zero, or a positive integer as the&#13;
        /// first argument is less than, equal to, or greater than the second.&lt;/returns&gt;&#13;
        public abstract int compare(Object o1, Object o2);&#13;
&#13;
        public int Compare(Object o1, Object o2)&#13;
        {&#13;
            return compare(o1, o2);&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// The String class represents character strings.&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;author&gt;Petr Kozler (A13B0359P)&lt;/author&gt;&#13;
    public class String : Comparable&#13;
    {&#13;
&#13;
        // an inner string&#13;
        public string s { get; private set; }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Constructs a new String by decoding the specified array of bytes using&#13;
        /// the platform's default charset.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="bytes"&gt;The bytes to be decoded into characters&#13;
        /// &lt;/param&gt;&#13;
        public String(sbyte[] bytes)&#13;
        {&#13;
            // parsing to the unsigned byte array&#13;
            byte[] unsigned = (byte[])(Array)bytes;&#13;
            s = Encoding.Default.GetString(unsigned);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Constructs a new String by decoding the specified subarray of bytes using&#13;
        /// the platform's default charset.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="bytes"&gt;The bytes to be decoded into characters&#13;
        /// &lt;/param&gt;&lt;param name="offset"&gt;The index of the first byte to decode&#13;
        /// &lt;/param&gt;&lt;param name="length"&gt;The number of bytes to decode&#13;
        /// &lt;/param&gt;&#13;
        public String(sbyte[] bytes, int offset, int length)&#13;
        {&#13;
            byte[] unsigned = (byte[])(Array)bytes;&#13;
            s = Encoding.Default.GetString(unsigned, offset, length);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Initializes a newly created String object so that it represents the same&#13;
        /// sequence of characters as the argument; in other words, the inner string of the&#13;
        /// newly created String object is a copy of the argument string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;A String&#13;
        /// &lt;/param&gt;&#13;
        public String(string original)&#13;
        {&#13;
            s = original;&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Compares two strings lexicographically.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="anotherString"&gt;the String to be compared.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the value 0 if the argument string is equal to this string; a&#13;
        /// value less than 0 if this string is lexicographically less than the&#13;
        /// string argument; and a value greater than 0 if this string is&#13;
        /// lexicographically greater than the string argument.&#13;
        /// &lt;/returns&gt;&#13;
        public override int compareTo(Object anotherString)&#13;
        {&#13;
            return s.CompareTo((anotherString as String).s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Compares this string to the specified object.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="anObject"&gt;The object to compare this String against&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the given object represents a String equivalent to this&#13;
        /// string, false otherwise&#13;
        /// &lt;/returns&gt;&#13;
        public override bool equals(Object anObject)&#13;
        {&#13;
            if (anObject == null)&#13;
            {&#13;
                return false;&#13;
            }&#13;
&#13;
            if (GetType() != anObject.GetType())&#13;
            {&#13;
                return false;&#13;
            }&#13;
&#13;
            return s.Equals((anObject as String).s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a new string that is a substring of this string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="beginIndex"&gt;the beginning index, inclusive.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the specified substring.&#13;
        /// &lt;/returns&gt;&#13;
        public String substring(int beginIndex)&#13;
        {&#13;
            return new String(s.Substring(beginIndex));&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a new string that is a substring of this string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="beginIndex"&gt;the beginning index, inclusive.&#13;
        /// &lt;/param&gt;&lt;param name="endIndex"&gt;the ending index, exclusive.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the specified substring.&#13;
        /// &lt;/returns&gt;&#13;
        public String substring(int beginIndex, int endIndex)&#13;
        {&#13;
            // calculating the length from the specified end index&#13;
            return new String(s.Substring(beginIndex, endIndex - beginIndex));&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the index within this string of the first occurrence of the&#13;
        /// specified character.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="ch"&gt;a character (Unicode code point).&#13;
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the character in the&#13;
        /// character sequence represented by this object, or -1 if the character&#13;
        /// does not occur.&#13;
        /// &lt;/returns&gt;&#13;
        public int indexOf(int ch)&#13;
        {&#13;
            return s.IndexOf((char)ch);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the index within this string of the first occurrence of the&#13;
        /// specified character, starting the search at the specified index.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="ch"&gt;a character (Unicode code point).&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index to start the search from.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the character in the&#13;
        /// character sequence represented by this object that is greater than or&#13;
        /// equal to fromIndex, or -1 if the character does not occur.&#13;
        /// &lt;/returns&gt;&#13;
        public int indexOf(int ch, int fromIndex)&#13;
        {&#13;
            return s.IndexOf((char)ch, fromIndex);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the index within this string of the first occurrence of the&#13;
        /// specified substring.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="str"&gt;the substring to search for.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the specified substring, or&#13;
        /// -1 if there is no such occurrence.&#13;
        /// &lt;/returns&gt;&#13;
        public int indexOf(String str)&#13;
        {&#13;
            return s.IndexOf(str.s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the index within this string of the first occurrence of the&#13;
        /// specified substring, starting at the specified index.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="str"&gt;the substring to search for.&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index from which to start the search.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the specified substring,&#13;
        /// starting at the specified index, or -1 if there is no such occurrence.&#13;
        /// &lt;/returns&gt;&#13;
        public int indexOf(String str, int fromIndex)&#13;
        {&#13;
            return s.IndexOf(str.s, fromIndex);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the length of this string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the length of the sequence of characters represented by this&#13;
        /// object.&#13;
        /// &lt;/returns&gt;&#13;
        public int length()&#13;
        {&#13;
            return s.Length;&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a copy of the string, with leading and trailing whitespace&#13;
        /// omitted.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;A copy of this string with leading and trailing white space&#13;
        /// removed, or this string if it has no leading or trailing white space.&#13;
        /// &lt;/returns&gt;&#13;
        public String trim()&#13;
        {&#13;
            return new String(s.Trim());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Converts all of the characters in this String to lower case using the&#13;
        /// rules of the default locale.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the String, converted to lowercase.&#13;
        /// &lt;/returns&gt;&#13;
        public String toLowerCase()&#13;
        {&#13;
            return new String(s.ToLower());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Converts all of the characters in this String to upper case using the&#13;
        /// rules of the default locale.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the String, converted to uppercase.&#13;
        /// &lt;/returns&gt;&#13;
        public String toUpperCase()&#13;
        {&#13;
            return new String(s.ToUpper());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the char value at the specified index.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="index"&gt;the index of the char value.&#13;
        /// &lt;/param&gt;&lt;returns&gt;the char value at the specified index of this string. The first&#13;
        /// char value is at index 0.&#13;
        /// &lt;/returns&gt;&#13;
        public char charAt(int index)&#13;
        {&#13;
            return s[index];&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a new string resulting from replacing all occurrences of oldChar&#13;
        /// in this string with newChar.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="oldChar"&gt;the old character.&#13;
        /// &lt;/param&gt;&lt;param name="newChar"&gt;the new character.&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string derived from this string by replacing every occurrence&#13;
        /// of oldChar with newChar.&#13;
        /// &lt;/returns&gt;&#13;
        public String replace(char oldChar, char newChar)&#13;
        {&#13;
            return new String(s.Replace(oldChar, newChar));&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Tests if this string starts with the specified prefix.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="prefix"&gt;the prefix.&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the character sequence represented by the argument is a&#13;
        /// prefix of the character sequence represented by this string; false&#13;
        /// otherwise. Note also that true will be returned if the argument is an&#13;
        /// empty string or is equal to this String object as determined by the&#13;
        /// equals(Object) method.&#13;
        /// &lt;/returns&gt;&#13;
        public bool startsWith(String prefix)&#13;
        {&#13;
            return s.StartsWith(prefix.s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Tests if this string ends with the specified suffix.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="suffix"&gt;the suffix.&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the character sequence represented by the argument is a&#13;
        /// suffix of the character sequence represented by this object; false&#13;
        /// otherwise. Note that the result will be true if the argument is the empty&#13;
        /// string or is equal to this String object as determined by the&#13;
        /// equals(Object) method.&#13;
        /// &lt;/returns&gt;&#13;
        public bool endsWith(String suffix)&#13;
        {&#13;
            return s.EndsWith(suffix.s);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if, and only if, length() is 0.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;true if length() is 0, otherwise false&#13;
        /// &lt;/returns&gt;&#13;
        public bool isEmpty()&#13;
        {&#13;
            return s.Length == 0;&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// This object (which is already a string!) is itself returned.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the string itself.&lt;/returns&gt;&#13;
        public override String toString()&#13;
        {&#13;
            return new String(s);&#13;
        }&#13;
        &#13;
        public static implicit operator String(string original)&#13;
        {&#13;
            return new String(original);&#13;
        }&#13;
        &#13;
    }&#13;
&#13;
}&#13;
</code>
<code lang="Free Pascal">unit StringUnit;

{$mode objfpc}{$H+}

interface

type
  String_ = class;

  (**
   * Class Object is the root of the class hierarchy.
   *)
  Object_ = class
    public
      function equals_(obj: Object_) : boolean; virtual;
      function toString_() : String_; virtual;
      function equals(obj: TObject) : boolean; override;
      function toString() : ansiString; override;
  end;

  (**
   * This abstract class imposes a total ordering on the objects of each class that implements it.
   *)
  Comparable = class(Object_)
    public
      (**
       * Compares this object with the specified object for order.
       *
       * @param o the object to be compared.
       * @return a negative integer, zero, or a positive integer as this object
       * is less than, equal to, or greater than the specified object.
       *)
      function compareTo(o: Object_) : longInt; virtual; abstract;
  end;

  (**
   * A comparison function, which imposes a total ordering on some collection of objects.
   *)
  Comparator = class(Object_)
    public
      (**
       * Compares its two arguments for order.
       *
       * @param o1 the first object to be compared.
       * @param o2 the second object to be compared.
       * @return a negative integer, zero, or a positive integer as the
       * first argument is less than, equal to, or greater than the second.
       *)
      function compare(o1, o2: Object_) : longInt; virtual; abstract;
  end;

  (**
   * The String class represents character strings.
   *
   * @author Petr Kozler (A13B0359P)
   *)
  String_ = class(Comparable)
    private
      var str: ansiString;
    public
      property strProperty: ansiString read str;
      constructor create(bytes: array of shortInt);
      constructor create(bytes: array of shortInt; offset: longInt; length: longInt);
      constructor create(original: ansiString);
      function compareTo(anotherString: Object_) : longInt; override;
      function equals_(anObject: Object_) : boolean; override;
      function substring(beginIndex: longInt) : String_;
      function substring(beginIndex: longInt; endIndex: longInt) : String_;
      function indexOf(ch: longInt) : longInt;
      function indexOf(ch: longInt; fromIndex: longInt) : longInt;
      function indexOf(s: String_) : longInt;
      function indexOf(s: String_; fromIndex: longInt) : longInt;
      function length() : longInt;
      function trim() : String_;
      function toLowerCase() : String_;
      function toUpperCase() : String_;
      function charAt(index: longInt) : ansiChar;
      function replace(oldChar: ansiChar; newChar: ansiChar) : String_;
      function startsWith(prefix: String_) : boolean;
      function endsWith(suffix: String_) : boolean;
      function isEmpty() : boolean;
      function toString_() : String_; override;
  end;

operator := (original: ansiString) s: String_;

implementation

uses
  SysUtils, StrUtils;

(**
 * Indicates whether some other object is "equal to" this one.
 *
 * @param obj the reference object with which to compare.
 * @return true if this object is the same as the obj argument; false otherwise.
 *)
function Object_.equals_(obj: Object_) : boolean;
begin
  equals_ := self = obj;
end;

(**
 * Returns a string representation of the object.
 *
 * @return a string representation of the object.
 *)
function Object_.toString_() : String_;
begin
  toString_ := String_.create(inherited toString());
end;

function Object_.equals(obj: TObject) : boolean;
begin
  equals := self.equals_(Object_(obj));
end;

function Object_.toString() : ansiString;
begin
  toString := toString_().str;
end;

(**
 * Constructs a new String by decoding the specified array of bytes using
 * the ANSI charset.
 *
 * @param bytes The bytes to be decoded into characters
 *)
constructor String_.create(bytes: array of shortInt);
begin
  setString(str, @bytes[0], System.length(bytes));
end;

(**
 * Constructs a new String by decoding the specified subarray of bytes using
 * the ANSI charset.
 *
 * @param bytes The bytes to be decoded into characters
 * @param offset The index of the first byte to decode
 * @param length The number of bytes to decode
 *)
constructor String_.create(bytes: array of shortInt; offset: longInt; length: longInt);
begin
  setString(str, @bytes[offset], length);
end;

(**
 * Initializes a newly created String object so that it represents the same
 * sequence of characters as the argument; in other words, the inner string of the
 * newly created String object is a copy of the argument string.
 *
 * @param original A String
 *)
constructor String_.create(original: ansiString);
begin
  str := original;
end;

(**
 * Compares two strings lexicographically.
 *
 * @param anotherString the String to be compared.
 * @return the value 0 if the argument string is equal to this string; a
 * value less than 0 if this string is lexicographically less than the
 * string argument; and a value greater than 0 if this string is
 * lexicographically greater than the string argument.
 *)
function String_.compareTo(anotherString: Object_) : longInt;
begin
  compareTo := ansiCompareStr(str, (anotherString as String_).str);
end;

(**
 * Compares this string to the specified object.
 *
 * @param anObject The object to compare this String against
 * @return true if the given object represents a String equivalent to this
 * string, false otherwise
 *)
function String_.equals_(anObject: Object_) : boolean;
begin
  if anObject = nil then begin
    exit(false);
  end;

  if typeOf(self) &lt;&gt; typeOf(anObject) then begin
    exit(false);
  end;

  equals_ := (ansiCompareStr(self.str, (anObject as String_).str) = 0);
end;

(**
 * Returns a new string that is a substring of this string.
 *
 * @param beginIndex the beginning index, inclusive.
 * @return the specified substring.
 *)
function String_.substring(beginIndex: longInt) : String_;
begin
  substring := substring(beginIndex, System.length(str));
end;

(**
 * Returns a new string that is a substring of this string.
 *
 * @param beginIndex the beginning index, inclusive.
 * @param endIndex the ending index, exclusive.
 * @return the specified substring.
 *)
function String_.substring(beginIndex: longInt; endIndex: longInt) : String_;
var
  s: String_;
begin
  s := String_.create(copy(str, beginIndex + 1, endIndex - beginIndex));
  substring := s;
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified character.
 *
 * @param ch a character (Unicode code point).
 * @return the index of the first occurrence of the character in the
 * character sequence represented by this object, or -1 if the character
 * does not occur.
 *)
function String_.indexOf(ch: longInt) : longInt;
begin
  indexOf := indexOf(ch, 0);
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified character, starting the search at the specified index.
 *
 * @param ch a character (Unicode code point).
 * @param fromIndex the index to start the search from.
 * @return the index of the first occurrence of the character in the
 * character sequence represented by this object that is greater than or
 * equal to fromIndex, or -1 if the character does not occur.
 *)
function String_.indexOf(ch: longInt; fromIndex: longInt) : longInt;
var
  substr: ansiString;
  i: longInt;
begin
  substr := copy(str, fromIndex + 1, System.length(str) - fromIndex);
  i := pos(ansiChar(ch), substr) - 1;

  if i &lt; 0 then begin
    exit(-1);
  end;

  indexOf := i + fromIndex;
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified substring.
 *
 * @param str the substring to search for.
 * @return the index of the first occurrence of the specified substring, or
 * -1 if there is no such occurrence.
 *)
function String_.indexOf(s: String_) : longInt;
begin
  indexOf := indexOf(s, 0);
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified substring, starting at the specified index.
 *
 * @param str the substring to search for.
 * @param fromIndex the index from which to start the search.
 * @return the index of the first occurrence of the specified substring,
 * starting at the specified index, or -1 if there is no such occurrence.
 *)
function String_.indexOf(s: String_; fromIndex: longInt) : longInt;
var
  substr: ansiString;
  i: longInt;
begin
  substr := copy(str, fromIndex + 1, System.length(str) - fromIndex + 1);
  i := pos(s.str, substr) - 1;

  if i &lt; 0 then begin
    exit(-1);
  end;

  indexOf := i + fromIndex;
end;

(**
 * Returns the length of this string.
 *
 * @return the length of the sequence of characters represented by this
 * object.
 *)
function String_.length() : longInt;
begin
  length := System.length(str);
end;

(**
 * Returns a copy of the string, with leading and trailing whitespace
 * omitted.
 *
 * @return A copy of this string with leading and trailing white space
 * removed, or this string if it has no leading or trailing white space.
 *)
function String_.trim() : String_;
var
  s: String_;
begin
  s := String_.create(SysUtils.trim(str));
  trim := s;
end;

(**
 * Converts all of the characters in this String to lower case using the
 * rules of the default locale.
 *
 * @return the String, converted to lowercase.
 *)
function String_.toLowerCase() : String_;
var
  s: String_;
begin
  s := String_.create(lowerCase(str));
  toLowerCase := s;
end;

(**
 * Converts all of the characters in this String to upper case using the
 * rules of the default locale.
 *
 * @return the String, converted to uppercase.
 *)
function String_.toUpperCase() : String_;
var
  s: String_;
begin
  s.create(upperCase(str));
  toUpperCase := s;
end;

(**
 * Returns the char value at the specified index.
 *
 * @param index the index of the char value.
 * @return the char value at the specified index of this string. The first
 * char value is at index 0.
 *)
function String_.charAt(index: longInt) : ansiChar;
begin
  charAt := str[index + 1];
end;

(**
 * Returns a new string resulting from replacing all occurrences of oldChar
 * in this string with newChar.
 *
 * @param oldChar the old character.
 * @param newChar the new character.
 * @return a string derived from this string by replacing every occurrence
 * of oldChar with newChar.
 *)
function String_.replace(oldChar: ansiChar; newChar: ansiChar) : String_;
begin
  replace := replaceStr(str, oldChar, newChar);
end;

(**
 * Tests if this string starts with the specified prefix.
 *
 * @param prefix the prefix.
 * @return true if the character sequence represented by the argument is a
 * prefix of the character sequence represented by this string; false
 * otherwise. Note also that true will be returned if the argument is an
 * empty string or is equal to this String object as determined by the
 * equals(Object) method.
 *)
function String_.startsWith(prefix: String_) : boolean;
begin
  startsWith := ansiStartsStr(prefix.toString(), str);
end;

(**
 * Tests if this string ends with the specified suffix.
 *
 * @param suffix the suffix.
 * @return true if the character sequence represented by the argument is a
 * suffix of the character sequence represented by this object; false
 * otherwise. Note that the result will be true if the argument is the empty
 * string or is equal to this String object as determined by the
 * equals(Object) method.
 *)
function String_.endsWith(suffix: String_) : boolean;
begin
  endsWith := ansiEndsStr(suffix.toString(), str);
end;

(**
 * Returns true if, and only if, length() is 0.
 *
 * @return true if length() is 0, otherwise false
 *)
function String_.isEmpty() : boolean;
begin
  isEmpty := (self.length() = 0);
end;

(**
 * This object (which is already a string!) is itself returned.
 *
 * @return the string itself.
 *)
function String_.toString_() : String_;
begin
  toString_ := String_.create(str);
end;

operator := (original: ansiString) s: String_;
begin
  s := String_.create(original);
end;

end.

</code>

</codes>
