<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<codes>
<code lang="C">#ifndef ARRAYS_INCLUDED&#13;
#define	ARRAYS_INCLUDED&#13;
&#13;
#include "String.h"&#13;
#include &lt;stdbool.h&gt;&#13;
#include &lt;stdint.h&gt;&#13;
&#13;
/**&#13;
 * This module contains various functions for manipulating arrays (such as sorting and searching).&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
&#13;
int32_t Arrays_binarySearchB(int8_t *a, int32_t length, int8_t key);&#13;
int32_t Arrays_binarySearchRangeB(int8_t *a, int32_t fromIndex, int32_t toIndex, int8_t key);&#13;
int32_t Arrays_binarySearchC(char *a, int32_t length, char key);&#13;
int32_t Arrays_binarySearchRangeC(char *a, int32_t fromIndex, int32_t toIndex, char key);&#13;
int32_t Arrays_binarySearchD(double *a, int32_t length, double key);&#13;
int32_t Arrays_binarySearchRangeD(double *a, int32_t fromIndex, int32_t toIndex, double key);&#13;
int32_t Arrays_binarySearchF(float *a, int32_t length, float key);&#13;
int32_t Arrays_binarySearchRangeF(float *a, int32_t fromIndex, int32_t toIndex, float key);&#13;
int32_t Arrays_binarySearchI(int32_t *a, int32_t length, int32_t key);&#13;
int32_t Arrays_binarySearchRangeI(int32_t *a, int32_t fromIndex, int32_t toIndex, int32_t key);&#13;
int32_t Arrays_binarySearchL(int64_t *a, int32_t length, int64_t key);&#13;
int32_t Arrays_binarySearchRangeL(int64_t *a, int32_t fromIndex, int32_t toIndex, int64_t key);&#13;
int32_t Arrays_binarySearchObj(void **a, int32_t length, void *key, int32_t(*c)(const void *, const void *));&#13;
int32_t Arrays_binarySearchRangeObj(void **a, int32_t fromIndex, int32_t toIndex, void *key, int32_t(*c)(const void *, const void *));&#13;
int32_t Arrays_binarySearchS(int16_t *a, int32_t length, int16_t key);&#13;
int32_t Arrays_binarySearchRangeS(int16_t *a, int32_t fromIndex, int32_t toIndex, int16_t key);&#13;
bool *Arrays_copyOfBool(bool *original, int32_t length, int32_t newLength);&#13;
int8_t *Arrays_copyOfB(int8_t *original, int32_t length, int32_t newLength);&#13;
char *Arrays_copyOfC(char *original, int32_t length, int32_t newLength);&#13;
double *Arrays_copyOfD(double *original, int32_t length, int32_t newLength);&#13;
float *Arrays_copyOfF(float *original, int32_t length, int32_t newLength);&#13;
int32_t *Arrays_copyOfI(int32_t *original, int32_t length, int32_t newLength);&#13;
int64_t *Arrays_copyOfL(int64_t *original, int32_t length, int32_t newLength);&#13;
int16_t *Arrays_copyOfS(int16_t *original, int32_t length, int32_t newLength);&#13;
void **Arrays_copyOfObj(void **original, int32_t length, int32_t newLength);&#13;
bool *Arrays_copyOfRangeBool(bool *original, int32_t length, int32_t from, int32_t to);&#13;
int8_t *Arrays_copyOfRangeB(int8_t *original, int32_t length, int32_t from, int32_t to);&#13;
char *Arrays_copyOfRangeC(char *original, int32_t length, int32_t from, int32_t to);&#13;
double *Arrays_copyOfRangeD(double *original, int32_t length, int32_t from, int32_t to);&#13;
float *Arrays_copyOfRangeF(float *original, int32_t length, int32_t from, int32_t to);&#13;
int32_t *Arrays_copyOfRangeI(int32_t *original, int32_t length, int32_t from, int32_t to);&#13;
int64_t *Arrays_copyOfRangeL(int64_t *original, int32_t length, int32_t from, int32_t to);&#13;
int16_t *Arrays_copyOfRangeS(int16_t *original, int32_t length, int32_t from, int32_t to);&#13;
void **Arrays_copyOfRangeObj(void **original, int32_t length, int32_t from, int32_t to);&#13;
bool Arrays_equalsBool(bool *a, int32_t length, bool *a2, int32_t length2);&#13;
bool Arrays_equalsB(int8_t *a, int32_t length, int8_t *a2, int32_t length2);&#13;
bool Arrays_equalsC(char *a, int32_t length, char *a2, int32_t length2);&#13;
bool Arrays_equalsD(double *a, int32_t length, double *a2, int32_t length2);&#13;
bool Arrays_equalsF(float *a, int32_t length, float *a2, int32_t length2);&#13;
bool Arrays_equalsI(int32_t *a, int32_t length, int32_t *a2, int32_t length2);&#13;
bool Arrays_equalsL(int64_t *a, int32_t length, int64_t *a2, int32_t length2);&#13;
bool Arrays_equalsObj(void **a, int32_t length, void **a2, int32_t length2, bool (*equals)(const void *, const void *));&#13;
bool Arrays_equalsS(int16_t *a, int32_t length, int16_t *a2, int32_t length2);&#13;
void Arrays_fillBool(bool *a, int32_t length, bool val);&#13;
void Arrays_fillRangeBool(bool *a, int32_t fromIndex, int32_t toIndex, bool val);&#13;
void Arrays_fillB(int8_t *a, int32_t length, int8_t val);&#13;
void Arrays_fillRangeB(int8_t *a, int32_t fromIndex, int32_t toIndex, int8_t val);&#13;
void Arrays_fillC(char *a, int32_t length, char val);&#13;
void Arrays_fillRangeC(char *a, int32_t fromIndex, int32_t toIndex, char val);&#13;
void Arrays_fillD(double *a, int32_t length, double val);&#13;
void Arrays_fillRangeD(double *a, int32_t fromIndex, int32_t toIndex, double val);&#13;
void Arrays_fillF(float *a, int32_t length, float val);&#13;
void Arrays_fillRangeF(float *a, int32_t fromIndex, int32_t toIndex, float val);&#13;
void Arrays_fillI(int32_t *a, int32_t length, int32_t val);&#13;
void Arrays_fillRangeI(int32_t *a, int32_t fromIndex, int32_t toIndex, int32_t val);&#13;
void Arrays_fillL(int64_t *a, int32_t length, int64_t val);&#13;
void Arrays_fillRangeL(int64_t *a, int32_t fromIndex, int32_t toIndex, int64_t val);&#13;
void Arrays_fillObj(void **a, int32_t length, void *val);&#13;
void Arrays_fillRangeObj(void **a, int32_t fromIndex, int32_t toIndex, void *val);&#13;
void Arrays_fillS(int16_t *a, int32_t length, int16_t val);&#13;
void Arrays_fillRangeS(int16_t *a, int32_t fromIndex, int32_t toIndex, int16_t val);&#13;
void Arrays_sortC(char *a, int32_t length);&#13;
void Arrays_sortRangeC(char *a, int32_t fromIndex, int32_t toIndex);&#13;
void Arrays_sortB(int8_t *a, int32_t length);&#13;
void Arrays_sortRangeB(int8_t *a, int32_t fromIndex, int32_t toIndex);&#13;
void Arrays_sortD(double *a, int32_t length);&#13;
void Arrays_sortRangeD(double *a, int32_t fromIndex, int32_t toIndex);&#13;
void Arrays_sortF(float *a, int32_t length);&#13;
void Arrays_sortRangeF(float *a, int32_t fromIndex, int32_t toIndex);&#13;
void Arrays_sortI(int32_t *a, int32_t length);&#13;
void Arrays_sortRangeI(int32_t *a, int32_t fromIndex, int32_t toIndex);&#13;
void Arrays_sortL(int64_t *a, int32_t length);&#13;
void Arrays_sortRangeL(int64_t *a, int32_t fromIndex, int32_t toIndex);&#13;
void Arrays_sortObj(void **a, int32_t length, int32_t(*c)(const void *, const void *));&#13;
void Arrays_sortRangeObj(void **a, int32_t fromIndex, int32_t toIndex, int32_t(*c)(const void *, const void *));&#13;
void Arrays_sortS(int16_t *a, int32_t length);&#13;
void Arrays_sortRangeS(int16_t *a, int32_t fromIndex, int32_t toIndex);&#13;
String *Arrays_toStringBool(bool *a, int32_t length);&#13;
String *Arrays_toStringB(int8_t *a, int32_t length);&#13;
String *Arrays_toStringC(char *a, int32_t length);&#13;
String *Arrays_toStringD(double *a, int32_t length);&#13;
String *Arrays_toStringF(float *a, int32_t length);&#13;
String *Arrays_toStringI(int32_t *a, int32_t length);&#13;
String *Arrays_toStringL(int64_t *a, int32_t length);&#13;
String *Arrays_toStringObj(void **a, int32_t length, String *(*toString)(const void *));&#13;
String *Arrays_toStringS(int16_t *a, int32_t length);&#13;
&#13;
#endif	/* ARRAYS_INCLUDED */&#13;
&#13;
&#13;
#include "Arrays.h"&#13;
&#13;
#include "System.h"&#13;
#include "Boolean.h"&#13;
#include "Byte.h"&#13;
#include "Character.h"&#13;
#include "Double.h"&#13;
#include "Float.h"&#13;
#include "Integer.h"&#13;
#include "Long.h"&#13;
#include "Short.h"&#13;
#include "String.h"&#13;
#include "StringBuilder.h"&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
&#13;
bool _defaultBool = false;&#13;
int8_t _defaultByte = 0;&#13;
char _defaultChar = '\0';&#13;
double _defaultDouble = 0.0;&#13;
float _defaultFloat = 0.0f;&#13;
int32_t _defaultInt = 0;&#13;
int64_t _defaultLong = 0LL;&#13;
void *_defaultPointer = NULL;&#13;
int16_t _defaultShort = 0;&#13;
&#13;
int32_t _compareB(const void *a, const void *b) {&#13;
    return Byte_compare(*(int8_t*)a, *(int8_t*)b);&#13;
}&#13;
&#13;
int32_t _compareC(const void *a, const void *b) {&#13;
    return Character_compare(*(char*)a, *(char*)b);&#13;
}&#13;
&#13;
int32_t _compareD(const void *a, const void *b) {&#13;
    return Double_compare(*(double*)a, *(double*)b);&#13;
}&#13;
&#13;
int32_t _compareF(const void *a, const void *b) {&#13;
    return Float_compare(*(float*)a, *(float*)b);&#13;
}&#13;
&#13;
int32_t _compareI(const void *a, const void *b) {&#13;
    return Integer_compare(*(int32_t*)a, *(int32_t*)b);&#13;
}&#13;
&#13;
int32_t _compareL(const void *a, const void *b) {&#13;
    return Long_compare(*(int64_t*)a, *(int64_t*)b);&#13;
}&#13;
&#13;
int32_t _compareS(const void *a, const void *b) {&#13;
    return Short_compare(*(int16_t*)a, *(int16_t*)b);&#13;
}&#13;
&#13;
bool _equalsBool(const void *a, const void *b) {&#13;
    Boolean *x = new_Boolean(*(bool*)a);&#13;
    Boolean *y = new_Boolean(*(bool*)b);&#13;
    bool equal = equalsBool(x, y);&#13;
    free(x);&#13;
    free(y);&#13;
&#13;
    return equal;&#13;
}&#13;
&#13;
bool _equalsB(const void *a, const void *b) {&#13;
    Byte *x = new_Byte(*(int8_t*)a);&#13;
    Byte *y = new_Byte(*(int8_t*)b);&#13;
    bool equal = equalsB(x, y);&#13;
    free(x);&#13;
    free(y);&#13;
&#13;
    return equal;&#13;
}&#13;
&#13;
bool _equalsC(const void *a, const void *b) {&#13;
    Character *x = new_Character(*(char*)a);&#13;
    Character *y = new_Character(*(char*)b);&#13;
    bool equal = equalsC(x, y);&#13;
    free(x);&#13;
    free(y);&#13;
&#13;
    return equal;&#13;
}&#13;
&#13;
bool _equalsD(const void *a, const void *b) {&#13;
    Double *x = new_Double(*(double*)a);&#13;
    Double *y = new_Double(*(double*)b);&#13;
    bool equal = equalsD(x, y);&#13;
    free(x);&#13;
    free(y);&#13;
&#13;
    return equal;&#13;
}&#13;
&#13;
bool _equalsF(const void *a, const void *b) {&#13;
    Float *x = new_Float(*(float*)a);&#13;
    Float *y = new_Float(*(float*)b);&#13;
    bool equal = equalsF(x, y);&#13;
    free(x);&#13;
    free(y);&#13;
&#13;
    return equal;&#13;
}&#13;
&#13;
bool _equalsI(const void *a, const void *b) {&#13;
    Integer *x = new_Integer(*(int32_t*)a);&#13;
    Integer *y = new_Integer(*(int32_t*)b);&#13;
    bool equal = equalsI(x, y);&#13;
    free(x);&#13;
    free(y);&#13;
&#13;
    return equal;&#13;
}&#13;
&#13;
bool _equalsL(const void *a, const void *b) {&#13;
    Long *x = new_Long(*(int64_t*)a);&#13;
    Long *y = new_Long(*(int64_t*)b);&#13;
    bool equal = equalsL(x, y);&#13;
    free(x);&#13;
    free(y);&#13;
&#13;
    return equal;&#13;
}&#13;
&#13;
bool _equalsS(const void *a, const void *b) {&#13;
    Short *x = new_Short(*(int16_t*)a);&#13;
    Short *y = new_Short(*(int16_t*)b);&#13;
    bool equal = equalsS(x, y);&#13;
    free(x);&#13;
    free(y);&#13;
&#13;
    return equal;&#13;
}&#13;
&#13;
String *_toStringBool(const void *a) {&#13;
    return Boolean_toString(*(bool*)a);&#13;
}&#13;
&#13;
String *_toStringB(const void *a) {&#13;
    return Byte_toString(*(int8_t*)a);&#13;
}&#13;
&#13;
String *_toStringC(const void *a) {&#13;
    return Character_toString(*(char*)a);&#13;
}&#13;
&#13;
String *_toStringD(const void *a) {&#13;
    return Double_toString(*(double*)a);&#13;
}&#13;
&#13;
String *_toStringF(const void *a) {&#13;
    return Float_toString(*(float*)a);&#13;
}&#13;
&#13;
String *_toStringI(const void *a) {&#13;
    return Integer_toString(*(int32_t*)a);&#13;
}&#13;
&#13;
String *_toStringL(const void *a) {&#13;
    return Long_toString(*(int64_t*)a);&#13;
}&#13;
&#13;
String *_toStringS(const void *a) {&#13;
    return Short_toString(*(int16_t*)a);&#13;
}&#13;
&#13;
int32_t _binarySearchPointer(void *a, int32_t fromIndex, int32_t toIndex, int32_t size, void *key, int32_t (*c)(const void *, const void *), bool isObjectArray) {&#13;
    int32_t lower = fromIndex;&#13;
    int32_t upper = toIndex - 1;&#13;
&#13;
    while (lower &lt;= upper) {&#13;
        int32_t middle = ((uint32_t)lower + (uint32_t)upper) &gt;&gt; 1;&#13;
        int32_t cmp; &#13;
        &#13;
        if (isObjectArray) {&#13;
            void **o1 = a + middle * size;&#13;
            void **o2 = key;&#13;
            cmp = c(*o1, *o2);&#13;
        }&#13;
        else {&#13;
            void *o1 = a + middle * size;&#13;
            void *o2 = key;&#13;
            cmp = c(o1, o2);&#13;
        }&#13;
        &#13;
        if (cmp &lt; 0) {&#13;
            lower = middle + 1;&#13;
        }&#13;
        else if (cmp &gt; 0) {&#13;
            upper = middle - 1;&#13;
        }&#13;
        else {&#13;
            return middle;&#13;
        }&#13;
    }&#13;
&#13;
    return -(lower + 1);&#13;
}&#13;
&#13;
void *_copyOfRangePointer(void *original, int32_t length, int32_t size, int32_t from, int32_t to, void *defaultValue) {&#13;
    void *a = calloc(to - from, size);&#13;
    int32_t i;&#13;
&#13;
    if (to &gt; length) {&#13;
        for (i = from; i &lt; length; i++) {&#13;
            memcpy(a + (i - from) * size, original + i * size, size);&#13;
        }&#13;
&#13;
        for (i = length; i &lt; to; i++) {&#13;
            memcpy(a + (i - from) * size, defaultValue, size);&#13;
        }&#13;
    }&#13;
    else {&#13;
        for (i = from; i &lt; to; i++) {&#13;
            memcpy(a + (i - from) * size, original + i * size, size);&#13;
        }&#13;
    }&#13;
&#13;
    return a;&#13;
}&#13;
&#13;
bool _equalsPointer(void *a, int32_t length, void *a2, int32_t length2, int32_t size, bool (*equals)(const void *, const void *), bool isObjectArray) {&#13;
    if (a == a2) {&#13;
        return true;&#13;
    }&#13;
    &#13;
    if (a == NULL || a2 == NULL) {&#13;
        return false;&#13;
    }&#13;
&#13;
    if (length2 != length) {&#13;
        return false;&#13;
    }&#13;
    &#13;
    int32_t i;&#13;
    for (i = 0; i &lt; length; i++) {&#13;
        bool e;&#13;
        &#13;
        if (isObjectArray) {&#13;
            void **o1 = a + i * size;&#13;
            void **o2 = a2 + i * size;&#13;
            e = *o1 == NULL ? *o2 == NULL : equals(*o1, *o2);&#13;
        }&#13;
        else {&#13;
            void *o1 = a + i * size;&#13;
            void *o2 = a2 + i * size;&#13;
            e = equals(o1, o2);&#13;
        }&#13;
        &#13;
        if (!e) {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    return true;&#13;
}&#13;
&#13;
void _fillPointer(void *a, int32_t fromIndex, int32_t toIndex, int32_t size, void *val) {&#13;
    int32_t i;&#13;
    for (i = fromIndex; i &lt; toIndex; i++) {&#13;
        memcpy(a + i * size, val, size);&#13;
    }&#13;
}&#13;
&#13;
void _sortPointer(void *a, int32_t fromIndex, int32_t toIndex, int32_t size, int32_t (*c)(const void *, const void *), bool isObjectArray) {&#13;
    if (!isObjectArray) {&#13;
        qsort(a + fromIndex * size, toIndex - fromIndex, size, c);&#13;
    }&#13;
    else {&#13;
        void **aux = malloc(sizeof(void *) * (toIndex - fromIndex));&#13;
        _mergeSort((void **)a, aux, fromIndex, toIndex - 1, c);&#13;
        free(aux);&#13;
    }&#13;
}&#13;
&#13;
String *_toStringPointer(void *a, int32_t length, int32_t size, String *(*toString)(const void *), bool isObjectArray) {&#13;
    StringBuilder *sb = new_StringBuilder();&#13;
    String *str = new_String("[");&#13;
    append(sb, str);&#13;
    delete_String(str);&#13;
&#13;
    if (length &gt; 0) {&#13;
        if (isObjectArray) {&#13;
            void **o = a;&#13;
            str = *o == NULL ? new_String("null") : toString(*o);&#13;
        }&#13;
        else  {&#13;
            void *o = a;&#13;
            str = toString(o);&#13;
        }&#13;
        &#13;
        append(sb, str);&#13;
        delete_String(str);&#13;
    }&#13;
&#13;
    int32_t i;&#13;
    for (i = 1; i &lt; length; i++) {&#13;
        str = new_String(", ");&#13;
        append(sb, str);&#13;
        delete_String(str);&#13;
        &#13;
        if (isObjectArray) {&#13;
            void **o = a + i * size;&#13;
            str = *o == NULL ? new_String("null") : toString(*o);&#13;
        }&#13;
        else  {&#13;
            void *o = a + i * size;&#13;
            str = toString(o);&#13;
        }&#13;
        &#13;
        append(sb, str);&#13;
        delete_String(str);&#13;
    }&#13;
&#13;
    str = new_String("]");&#13;
    append(sb, str);&#13;
    delete_String(str);&#13;
    str = toStringSb(sb);&#13;
    delete_StringBuilder(sb);&#13;
&#13;
    return str;&#13;
}&#13;
&#13;
/**&#13;
 * Searches the specified array of bytes for the specified value using the&#13;
 * binary search algorithm&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param length The array length&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array;&#13;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
 * the point at which the key would be inserted into the array: the index of&#13;
 * the first element greater than the key, or a.length if all elements in&#13;
 * the array are less than the specified key. Note that this guarantees that&#13;
 * the return value will be &gt;= 0 if and only if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchB(int8_t *a, int32_t length, int8_t key) {&#13;
    return _binarySearchPointer(a, 0, length, sizeof(int8_t), &amp;key, _compareC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches a range of the specified array of bytes for the specified value&#13;
 * using the binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param fromIndex the index of the first element (inclusive) to be&#13;
 * searched&#13;
 * @param toIndex the index of the last element (exclusive) to be searched&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array within&#13;
 * the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
 * point is defined as the point at which the key would be inserted into the&#13;
 * array: the index of the first element in the range greater than the key,&#13;
 * or toIndex if all elements in the range are less than the specified key.&#13;
 * Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
 * if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchRangeB(int8_t *a, int32_t fromIndex, int32_t toIndex, int8_t key) {&#13;
    return _binarySearchPointer(a, fromIndex, toIndex, sizeof(int8_t), &amp;key, _compareC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches the specified array of chars for the specified value using the&#13;
 * binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param length The array length&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array;&#13;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
 * the point at which the key would be inserted into the array: the index of&#13;
 * the first element greater than the key, or a.length if all elements in&#13;
 * the array are less than the specified key. Note that this guarantees that&#13;
 * the return value will be &gt;= 0 if and only if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchC(char *a, int32_t length, char key) {&#13;
    return _binarySearchPointer(a, 0, length, sizeof(char), &amp;key, _compareC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches a range of the specified array of chars for the specified value&#13;
 * using the binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param fromIndex the index of the first element (inclusive) to be&#13;
 * searched&#13;
 * @param toIndex the index of the last element (exclusive) to be searched&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array within&#13;
 * the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
 * point is defined as the point at which the key would be inserted into the&#13;
 * array: the index of the first element in the range greater than the key,&#13;
 * or toIndex if all elements in the range are less than the specified key.&#13;
 * Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
 * if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchRangeC(char *a, int32_t fromIndex, int32_t toIndex, char key) {&#13;
    return _binarySearchPointer(a, fromIndex, toIndex, sizeof(char), &amp;key, _compareC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches the specified array of doubles for the specified value using the&#13;
 * binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param length The array length&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array;&#13;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
 * the point at which the key would be inserted into the array: the index of&#13;
 * the first element greater than the key, or a.length if all elements in&#13;
 * the array are less than the specified key. Note that this guarantees that&#13;
 * the return value will be &gt;= 0 if and only if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchD(double *a, int32_t length, double key) {&#13;
    return _binarySearchPointer(a, 0, length, sizeof(double), &amp;key, _compareD, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches a range of the specified array of doubles for the specified&#13;
 * value using the binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param fromIndex the index of the first element (inclusive) to be&#13;
 * searched&#13;
 * @param toIndex the index of the last element (exclusive) to be searched&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array within&#13;
 * the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
 * point is defined as the point at which the key would be inserted into the&#13;
 * array: the index of the first element in the range greater than the key,&#13;
 * or toIndex if all elements in the range are less than the specified key.&#13;
 * Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
 * if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchRangeD(double *a, int32_t fromIndex, int32_t toIndex, double key) {&#13;
    return _binarySearchPointer(a, fromIndex, toIndex, sizeof(double), &amp;key, _compareD, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches the specified array of floats for the specified value using the&#13;
 * binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param length The array length&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array;&#13;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
 * the point at which the key would be inserted into the array: the index of&#13;
 * the first element greater than the key, or a.length if all elements in&#13;
 * the array are less than the specified key. Note that this guarantees that&#13;
 * the return value will be &gt;= 0 if and only if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchF(float *a, int32_t length, float key) {&#13;
    return _binarySearchPointer(a, 0, length, sizeof(float), &amp;key, _compareF, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches a range of the specified array of floats for the specified value&#13;
 * using the binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param fromIndex the index of the first element (inclusive) to be&#13;
 * searched&#13;
 * @param toIndex the index of the last element (exclusive) to be searched&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array within&#13;
 * the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
 * point is defined as the point at which the key would be inserted into the&#13;
 * array: the index of the first element in the range greater than the key,&#13;
 * or toIndex if all elements in the range are less than the specified key.&#13;
 * Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
 * if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchRangeF(float *a, int32_t fromIndex, int32_t toIndex, float key) {&#13;
    return _binarySearchPointer(a, fromIndex, toIndex, sizeof(float), &amp;key, _compareF, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches the specified array of ints for the specified value using the&#13;
 * binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param length The array length&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array;&#13;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
 * the point at which the key would be inserted into the array: the index of&#13;
 * the first element greater than the key, or a.length if all elements in&#13;
 * the array are less than the specified key. Note that this guarantees that&#13;
 * the return value will be &gt;= 0 if and only if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchI(int32_t *a, int32_t length, int32_t key) {&#13;
    return _binarySearchPointer(a, 0, length, sizeof(int32_t), &amp;key, _compareI, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches a range of the specified array of ints for the specified value&#13;
 * using the binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param fromIndex the index of the first element (inclusive) to be&#13;
 * searched&#13;
 * @param toIndex the index of the last element (exclusive) to be searched&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array within&#13;
 * the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
 * point is defined as the point at which the key would be inserted into the&#13;
 * array: the index of the first element in the range greater than the key,&#13;
 * or toIndex if all elements in the range are less than the specified key.&#13;
 * Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
 * if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchRangeI(int32_t *a, int32_t fromIndex, int32_t toIndex, int32_t key) {&#13;
    return _binarySearchPointer(a, fromIndex, toIndex, sizeof(int32_t), &amp;key, _compareI, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches the specified array of longs for the specified value using the&#13;
 * binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param length The array length&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array;&#13;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
 * the point at which the key would be inserted into the array: the index of&#13;
 * the first element greater than the key, or a.length if all elements in&#13;
 * the array are less than the specified key. Note that this guarantees that&#13;
 * the return value will be &gt;= 0 if and only if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchL(int64_t *a, int32_t length, int64_t key) {&#13;
    return _binarySearchPointer(a, 0, length, sizeof(int64_t), &amp;key, _compareL, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches a range of the specified array of longs for the specified value&#13;
 * using the binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param fromIndex the index of the first element (inclusive) to be&#13;
 * searched&#13;
 * @param toIndex the index of the last element (exclusive) to be searched&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array within&#13;
 * the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
 * point is defined as the point at which the key would be inserted into the&#13;
 * array: the index of the first element in the range greater than the key,&#13;
 * or toIndex if all elements in the range are less than the specified key.&#13;
 * Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
 * if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchRangeL(int64_t *a, int32_t fromIndex, int32_t toIndex, int64_t key) {&#13;
    return _binarySearchPointer(a, fromIndex, toIndex, sizeof(int64_t), &amp;key, _compareL, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches the specified array for the specified structure using the binary&#13;
 * search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param length The array length&#13;
 * @param key the value to be searched for&#13;
 * @param c The structure compare function&#13;
 * @return index of the search key, if it is contained in the array;&#13;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
 * the point at which the key would be inserted into the array: the index of&#13;
 * the first element greater than the key, or a.length if all elements in&#13;
 * the array are less than the specified key. Note that this guarantees that&#13;
 * the return value will be &gt;= 0 if and only if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchObj(void **a, int32_t length, void *key, int32_t (*c)(const void *, const void *)) {&#13;
    return _binarySearchPointer(a, 0, length, sizeof(void *), &amp;key, c, true);&#13;
}&#13;
&#13;
/**&#13;
 * Searches a range of the specified array for the specified structure using&#13;
 * the binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param fromIndex the index of the first element (inclusive) to be&#13;
 * searched&#13;
 * @param toIndex the index of the last element (exclusive) to be searched&#13;
 * @param key the value to be searched for&#13;
 * @param c The structure compare function&#13;
 * @return index of the search key, if it is contained in the array within&#13;
 * the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
 * point is defined as the point at which the key would be inserted into the&#13;
 * array: the index of the first element in the range greater than the key,&#13;
 * or toIndex if all elements in the range are less than the specified key.&#13;
 * Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
 * if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchRangeObj(void **a, int32_t fromIndex, int32_t toIndex, void *key, int32_t (*c)(const void *, const void *)) {&#13;
    return _binarySearchPointer(a, fromIndex, toIndex, sizeof(void *), &amp;key, c, true);&#13;
}&#13;
&#13;
/**&#13;
 * Searches the specified array of shorts for the specified value using the&#13;
 * binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param length The array length&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array;&#13;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
 * the point at which the key would be inserted into the array: the index of&#13;
 * the first element greater than the key, or a.length if all elements in&#13;
 * the array are less than the specified key. Note that this guarantees that&#13;
 * the return value will be &gt;= 0 if and only if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchS(int16_t *a, int32_t length, int16_t key) {&#13;
    return _binarySearchPointer(a, 0, length, sizeof(int16_t), &amp;key, _compareS, false);&#13;
}&#13;
&#13;
/**&#13;
 * Searches a range of the specified array of shorts for the specified value&#13;
 * using the binary search algorithm.&#13;
 *&#13;
 * @param a the array to be searched&#13;
 * @param fromIndex the index of the first element (inclusive) to be&#13;
 * searched&#13;
 * @param toIndex the index of the last element (exclusive) to be searched&#13;
 * @param key the value to be searched for&#13;
 * @return index of the search key, if it is contained in the array within&#13;
 * the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
 * point is defined as the point at which the key would be inserted into the&#13;
 * array: the index of the first element in the range greater than the key,&#13;
 * or toIndex if all elements in the range are less than the specified key.&#13;
 * Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
 * if the key is found.&#13;
 */&#13;
int32_t Arrays_binarySearchRangeS(int16_t *a, int32_t fromIndex, int32_t toIndex, int16_t key) {&#13;
    return _binarySearchPointer(a, fromIndex, toIndex, sizeof(int16_t), &amp;key, _compareS, false);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified array, truncating or padding with false (if&#13;
 * necessary) so the copy has the specified length.&#13;
 *&#13;
 * @param original the array to be copied&#13;
 * @param length The array length&#13;
 * @param newLength the length of the copy to be returned&#13;
 * @return a copy of the original array, truncated or padded with false&#13;
 * elements to obtain the specified length&#13;
 */&#13;
bool *Arrays_copyOfBool(bool *original, int32_t length, int32_t newLength) {&#13;
    return _copyOfRangePointer(original, length, sizeof(bool), 0, newLength, &amp;_defaultBool);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified array, truncating or padding with zeros (if&#13;
 * necessary) so the copy has the specified length.&#13;
 *&#13;
 * @param original the array to be copied&#13;
 * @param length The array length&#13;
 * @param newLength the length of the copy to be returned&#13;
 * @return a copy of the original array, truncated or padded with zeros to&#13;
 * obtain the specified length&#13;
 */&#13;
int8_t *Arrays_copyOfB(int8_t *original, int32_t length, int32_t newLength) {&#13;
    return _copyOfRangePointer(original, length, sizeof(int8_t), 0, newLength, &amp;_defaultByte);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified array, truncating or padding with null characters&#13;
 * (if necessary) so the copy has the specified length.&#13;
 *&#13;
 * @param original the array to be copied&#13;
 * @param length The array length&#13;
 * @param newLength the length of the copy to be returned&#13;
 * @return a copy of the original array, truncated or padded with null&#13;
 * characters to obtain the specified length&#13;
 */&#13;
char *Arrays_copyOfC(char *original, int32_t length, int32_t newLength) {&#13;
    return _copyOfRangePointer(original, length, sizeof(char), 0, newLength, &amp;_defaultChar);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified array, truncating or padding with zeros (if&#13;
 * necessary) so the copy has the specified length.&#13;
 *&#13;
 * @param original the array to be copied&#13;
 * @param length The array length&#13;
 * @param newLength the length of the copy to be returned&#13;
 * @return a copy of the original array, truncated or padded with zeros to&#13;
 * obtain the specified length&#13;
 */&#13;
double *Arrays_copyOfD(double *original, int32_t length, int32_t newLength) {&#13;
    return _copyOfRangePointer(original, length, sizeof(double), 0, newLength, &amp;_defaultDouble);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified array, truncating or padding with zeros (if&#13;
 * necessary) so the copy has the specified length.&#13;
 *&#13;
 * @param original the array to be copied&#13;
 * @param length The array length&#13;
 * @param newLength the length of the copy to be returned&#13;
 * @return a copy of the original array, truncated or padded with zeros to&#13;
 * obtain the specified length&#13;
 */&#13;
float *Arrays_copyOfF(float *original, int32_t length, int32_t newLength) {&#13;
    return _copyOfRangePointer(original, length, sizeof(float), 0, newLength, &amp;_defaultFloat);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified array, truncating or padding with zeros (if&#13;
 * necessary) so the copy has the specified length.&#13;
 *&#13;
 * @param original the array to be copied&#13;
 * @param length The array length&#13;
 * @param newLength the length of the copy to be returned&#13;
 * @return a copy of the original array, truncated or padded with zeros to&#13;
 * obtain the specified length&#13;
 */&#13;
int32_t *Arrays_copyOfI(int32_t *original, int32_t length, int32_t newLength) {&#13;
    return _copyOfRangePointer(original, length, sizeof(int32_t), 0, newLength, &amp;_defaultInt);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified array, truncating or padding with zeros (if&#13;
 * necessary) so the copy has the specified length.&#13;
 *&#13;
 * @param original the array to be copied&#13;
 * @param length The array length&#13;
 * @param newLength the length of the copy to be returned&#13;
 * @return a copy of the original array, truncated or padded with zeros to&#13;
 * obtain the specified length&#13;
 */&#13;
int64_t *Arrays_copyOfL(int64_t *original, int32_t length, int32_t newLength) {&#13;
    return _copyOfRangePointer(original, length, sizeof(int64_t), 0, newLength, &amp;_defaultLong);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified array, truncating or padding with zeros (if&#13;
 * necessary) so the copy has the specified length.&#13;
 *&#13;
 * @param original the array to be copied&#13;
 * @param length The array length&#13;
 * @param newLength the length of the copy to be returned&#13;
 * @return a copy of the original array, truncated or padded with zeros to&#13;
 * obtain the specified length&#13;
 */&#13;
int16_t *Arrays_copyOfS(int16_t *original, int32_t length, int32_t newLength) {&#13;
    return _copyOfRangePointer(original, length, sizeof(int16_t), 0, newLength, &amp;_defaultShort);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified array, truncating or padding with nulls (if&#13;
 * necessary) so the copy has the specified length.&#13;
 *&#13;
 * @param original the array to be copied&#13;
 * @param length The array length&#13;
 * @param newLength the length of the copy to be returned&#13;
 * @return a copy of the original array, truncated or padded with nulls to&#13;
 * obtain the specified length&#13;
 */&#13;
void **Arrays_copyOfObj(void **original, int32_t length, int32_t newLength) {&#13;
    return _copyOfRangePointer(original, length, sizeof(void *), 0, newLength, &amp;_defaultPointer);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified range of the specified array into a new array.&#13;
 *&#13;
 * @param original the array from which a range is to be copied&#13;
 * @param length The array length&#13;
 * @param from the initial index of the range to be copied, inclusive&#13;
 * @param to the final index of the range to be copied, exclusive. (This&#13;
 * index may lie outside the array.)&#13;
 * @return a new array containing the specified range from the original&#13;
 * array, truncated or padded with false elements to obtain the required&#13;
 * length&#13;
 */&#13;
bool *Arrays_copyOfRangeBool(bool *original, int32_t length, int32_t from, int32_t to) {&#13;
    return _copyOfRangePointer(original, length, sizeof(bool), from, to, &amp;_defaultBool);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified range of the specified array into a new array.&#13;
 *&#13;
 * @param original the array from which a range is to be copied&#13;
 * @param length The array length&#13;
 * @param from the initial index of the range to be copied, inclusive&#13;
 * @param to the final index of the range to be copied, exclusive. (This&#13;
 * index may lie outside the array.)&#13;
 * @return a new array containing the specified range from the original&#13;
 * array, truncated or padded with zeros to obtain the required length&#13;
 */&#13;
int8_t *Arrays_copyOfRangeB(int8_t *original, int32_t length, int32_t from, int32_t to) {&#13;
    return _copyOfRangePointer(original, length, sizeof(int8_t), from, to, &amp;_defaultByte);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified range of the specified array into a new array.&#13;
 *&#13;
 * @param original the array from which a range is to be copied&#13;
 * @param length The array length&#13;
 * @param from the initial index of the range to be copied, inclusive&#13;
 * @param to the final index of the range to be copied, exclusive. (This&#13;
 * index may lie outside the array.)&#13;
 * @return a new array containing the specified range from the original&#13;
 * array, truncated or padded with null characters to obtain the required&#13;
 * length&#13;
 */&#13;
char *Arrays_copyOfRangeC(char *original, int32_t length, int32_t from, int32_t to) {&#13;
    return _copyOfRangePointer(original, length, sizeof(char), from, to, &amp;_defaultChar);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified range of the specified array into a new array.&#13;
 *&#13;
 * @param original the array from which a range is to be copied&#13;
 * @param length The array length&#13;
 * @param from the initial index of the range to be copied, inclusive&#13;
 * @param to the final index of the range to be copied, exclusive. (This&#13;
 * index may lie outside the array.)&#13;
 * @return a new array containing the specified range from the original&#13;
 * array, truncated or padded with zeros to obtain the required length&#13;
 */&#13;
double *Arrays_copyOfRangeD(double *original, int32_t length, int32_t from, int32_t to) {&#13;
    return _copyOfRangePointer(original, length, sizeof(double), from, to, &amp;_defaultDouble);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified range of the specified array into a new array.&#13;
 *&#13;
 * @param original the array from which a range is to be copied&#13;
 * @param length The array length&#13;
 * @param from the initial index of the range to be copied, inclusive&#13;
 * @param to the final index of the range to be copied, exclusive. (This&#13;
 * index may lie outside the array.)&#13;
 * @return a new array containing the specified range from the original&#13;
 * array, truncated or padded with zeros to obtain the required length&#13;
 */&#13;
float *Arrays_copyOfRangeF(float *original, int32_t length, int32_t from, int32_t to) {&#13;
    return _copyOfRangePointer(original, length, sizeof(float), from, to, &amp;_defaultFloat);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified range of the specified array into a new array.&#13;
 *&#13;
 * @param original the array from which a range is to be copied&#13;
 * @param length The array length&#13;
 * @param from the initial index of the range to be copied, inclusive&#13;
 * @param to the final index of the range to be copied, exclusive. (This&#13;
 * index may lie outside the array.)&#13;
 * @return a new array containing the specified range from the original&#13;
 * array, truncated or padded with zeros to obtain the required length&#13;
 */&#13;
int32_t *Arrays_copyOfRangeI(int32_t *original, int32_t length, int32_t from, int32_t to) {&#13;
    return _copyOfRangePointer(original, length, sizeof(int32_t), from, to, &amp;_defaultInt);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified range of the specified array into a new array.&#13;
 *&#13;
 * @param original the array from which a range is to be copied&#13;
 * @param length The array length&#13;
 * @param from the initial index of the range to be copied, inclusive&#13;
 * @param to the final index of the range to be copied, exclusive. (This&#13;
 * index may lie outside the array.)&#13;
 * @return a new array containing the specified range from the original&#13;
 * array, truncated or padded with zeros to obtain the required length&#13;
 */&#13;
int64_t *Arrays_copyOfRangeL(int64_t *original, int32_t length, int32_t from, int32_t to) {&#13;
    return _copyOfRangePointer(original, length, sizeof(int64_t), from, to, &amp;_defaultLong);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified range of the specified array into a new array.&#13;
 *&#13;
 * @param original the array from which a range is to be copied&#13;
 * @param length The array length&#13;
 * @param from the initial index of the range to be copied, inclusive&#13;
 * @param to the final index of the range to be copied, exclusive. (This&#13;
 * index may lie outside the array.)&#13;
 * @return a new array containing the specified range from the original&#13;
 * array, truncated or padded with zeros to obtain the required length&#13;
 */&#13;
int16_t *Arrays_copyOfRangeS(int16_t *original, int32_t length, int32_t from, int32_t to) {&#13;
    return _copyOfRangePointer(original, length, sizeof(int16_t), from, to, &amp;_defaultShort);&#13;
}&#13;
&#13;
/**&#13;
 * Copies the specified range of the specified array into a new array.&#13;
 *&#13;
 * @param original the array from which a range is to be copied&#13;
 * @param length The array length&#13;
 * @param from the initial index of the range to be copied, inclusive&#13;
 * @param to the final index of the range to be copied, exclusive. (This&#13;
 * index may lie outside the array.)&#13;
 * @return a new array containing the specified range from the original&#13;
 * array, truncated or padded with nulls to obtain the required length&#13;
 */&#13;
void **Arrays_copyOfRangeObj(void **original, int32_t length, int32_t from, int32_t to) {&#13;
    return _copyOfRangePointer(original, length, sizeof(void *), from, to, &amp;_defaultPointer);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if the two specified arrays of booleans are equal to one&#13;
 * another.&#13;
 *&#13;
 * @param a one array to be tested for equality&#13;
 * @param length The array length&#13;
 * @param a2 the other array to be tested for equality&#13;
 * @param length2 The other array length&#13;
 * @return true if the two arrays are equal&#13;
 */&#13;
bool Arrays_equalsBool(bool *a, int32_t length, bool *a2, int32_t length2) {&#13;
    return _equalsPointer(a, length, a2, length2, sizeof(bool), _equalsBool, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if the two specified arrays of bytes are equal to one&#13;
 * another.&#13;
 *&#13;
 * @param a one array to be tested for equality&#13;
 * @param length The array length&#13;
 * @param a2 the other array to be tested for equality&#13;
 * @param length2 The other array length&#13;
 * @return true if the two arrays are equal&#13;
 */&#13;
bool Arrays_equalsB(int8_t *a, int32_t length, int8_t *a2, int32_t length2) {&#13;
    return _equalsPointer(a, length, a2, length2, sizeof(int8_t), _equalsC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if the two specified arrays of chars are equal to one&#13;
 * another.&#13;
 *&#13;
 * @param a one array to be tested for equality&#13;
 * @param length The array length&#13;
 * @param a2 the other array to be tested for equality&#13;
 * @param length2 The other array length&#13;
 * @return true if the two arrays are equal&#13;
 */&#13;
bool Arrays_equalsC(char *a, int32_t length, char *a2, int32_t length2) {&#13;
    return _equalsPointer(a, length, a2, length2, sizeof(char), _equalsC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if the two specified arrays of doubles are equal to one&#13;
 * another.&#13;
 *&#13;
 * @param a one array to be tested for equality&#13;
 * @param length The array length&#13;
 * @param a2 the other array to be tested for equality&#13;
 * @param length2 The other array length&#13;
 * @return true if the two arrays are equal&#13;
 */&#13;
bool Arrays_equalsD(double *a, int32_t length, double *a2, int32_t length2) {&#13;
    return _equalsPointer(a, length, a2, length2, sizeof(double), _equalsD, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if the two specified arrays of floats are equal to one&#13;
 * another.&#13;
 *&#13;
 * @param a one array to be tested for equality&#13;
 * @param length The array length&#13;
 * @param a2 the other array to be tested for equality&#13;
 * @param length2 The other array length&#13;
 * @return true if the two arrays are equal&#13;
 */&#13;
bool Arrays_equalsF(float *a, int32_t length, float *a2, int32_t length2) {&#13;
    return _equalsPointer(a, length, a2, length2, sizeof(float), _equalsF, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if the two specified arrays of ints are equal to one&#13;
 * another.&#13;
 *&#13;
 * @param a one array to be tested for equality&#13;
 * @param length The array length&#13;
 * @param a2 the other array to be tested for equality&#13;
 * @param length2 The other array length&#13;
 * @return true if the two arrays are equal&#13;
 */&#13;
bool Arrays_equalsI(int32_t *a, int32_t length, int32_t *a2, int32_t length2) {&#13;
    return _equalsPointer(a, length, a2, length2, sizeof(int32_t), _equalsI, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if the two specified arrays of longs are equal to one&#13;
 * another.&#13;
 *&#13;
 * @param a one array to be tested for equality&#13;
 * @param length The array length&#13;
 * @param a2 the other array to be tested for equality&#13;
 * @param length2 The other array length&#13;
 * @return true if the two arrays are equal&#13;
 */&#13;
bool Arrays_equalsL(int64_t *a, int32_t length, int64_t *a2, int32_t length2) {&#13;
    return _equalsPointer(a, length, a2, length2, sizeof(int64_t), _equalsL, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if the two specified arrays of structures are equal to one&#13;
 * another.&#13;
 *&#13;
 * @param a one array to be tested for equality&#13;
 * @param length The array length&#13;
 * @param a2 the other array to be tested for equality&#13;
 * @param length2 The other array length&#13;
 * @param equals The structure equals function&#13;
 * @return true if the two arrays are equal&#13;
 */&#13;
bool Arrays_equalsObj(void **a, int32_t length, void **a2, int32_t length2, bool (*equals)(const void *, const void *)) {&#13;
    return _equalsPointer(a, length, a2, length2, sizeof(void *), equals, true);&#13;
}&#13;
&#13;
/**&#13;
 * Returns true if the two specified arrays of shorts are equal to one&#13;
 * another.&#13;
 *&#13;
 * @param a one array to be tested for equality&#13;
 * @param length The array length&#13;
 * @param a2 the other array to be tested for equality&#13;
 * @param length2 The other array length&#13;
 * @return true if the two arrays are equal&#13;
 */&#13;
bool Arrays_equalsS(int16_t *a, int32_t length, int16_t *a2, int32_t length2) {&#13;
    return _equalsPointer(a, length, a2, length2, sizeof(int16_t), _equalsS, false);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified boolean value to each element of the specified&#13;
 * array of booleans.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param length The array length&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillBool(bool *a, int32_t length, bool val) {&#13;
    _fillPointer(a, 0, length, sizeof(bool), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified boolean value to each element of the specified&#13;
 * range of the specified array of booleans.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param fromIndex the index of the first element (inclusive) to be filled&#13;
 * with the specified value&#13;
 * @param toIndex the index of the last element (exclusive) to be filled&#13;
 * with the specified value&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillRangeBool(bool *a, int32_t fromIndex, int32_t toIndex, bool val) {&#13;
    _fillPointer(a, fromIndex, toIndex, sizeof(bool), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified byte value to each element of the specified array&#13;
 * of bytes.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param length The array length&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillB(int8_t *a, int32_t length, int8_t val) {&#13;
    _fillPointer(a, 0, length, sizeof(int8_t), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified byte value to each element of the specified range&#13;
 * of the specified array of bytes.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param fromIndex the index of the first element (inclusive) to be filled&#13;
 * with the specified value&#13;
 * @param toIndex the index of the last element (exclusive) to be filled&#13;
 * with the specified value&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillRangeB(int8_t *a, int32_t fromIndex, int32_t toIndex, int8_t val) {&#13;
    _fillPointer(a, fromIndex, toIndex, sizeof(int8_t), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified char value to each element of the specified array&#13;
 * of chars.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param length The array length&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillC(char *a, int32_t length, char val) {&#13;
    _fillPointer(a, 0, length, sizeof(char), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified char value to each element of the specified range&#13;
 * of the specified array of chars.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param fromIndex the index of the first element (inclusive) to be filled&#13;
 * with the specified value&#13;
 * @param toIndex the index of the last element (exclusive) to be filled&#13;
 * with the specified value&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillRangeC(char *a, int32_t fromIndex, int32_t toIndex, char val) {&#13;
    _fillPointer(a, fromIndex, toIndex, sizeof(char), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified double value to each element of the specified array&#13;
 * of doubles.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param length The array length&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillD(double *a, int32_t length, double val) {&#13;
    _fillPointer(a, 0, length, sizeof(double), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified double value to each element of the specified range&#13;
 * of the specified array of doubles.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param fromIndex the index of the first element (inclusive) to be filled&#13;
 * with the specified value&#13;
 * @param toIndex the index of the last element (exclusive) to be filled&#13;
 * with the specified value&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillRangeD(double *a, int32_t fromIndex, int32_t toIndex, double val) {&#13;
    _fillPointer(a, fromIndex, toIndex, sizeof(double), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified float value to each element of the specified array&#13;
 * of floats.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param length The array length&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillF(float *a, int32_t length, float val) {&#13;
    _fillPointer(a, 0, length, sizeof(float), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified float value to each element of the specified range&#13;
 * of the specified array of floats.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param fromIndex the index of the first element (inclusive) to be filled&#13;
 * with the specified value&#13;
 * @param toIndex the index of the last element (exclusive) to be filled&#13;
 * with the specified value&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillRangeF(float *a, int32_t fromIndex, int32_t toIndex, float val) {&#13;
    _fillPointer(a, fromIndex, toIndex, sizeof(float), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified int value to each element of the specified array of&#13;
 * ints.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param length The array length&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillI(int32_t *a, int32_t length, int32_t val) {&#13;
    _fillPointer(a, 0, length, sizeof(int32_t), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified int value to each element of the specified range of&#13;
 * the specified array of ints.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param fromIndex the index of the first element (inclusive) to be filled&#13;
 * with the specified value&#13;
 * @param toIndex the index of the last element (exclusive) to be filled&#13;
 * with the specified value&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillRangeI(int32_t *a, int32_t fromIndex, int32_t toIndex, int32_t val) {&#13;
    _fillPointer(a, fromIndex, toIndex, sizeof(int32_t), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified long value to each element of the specified array&#13;
 * of longs.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param length The array length&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillL(int64_t *a, int32_t length, int64_t val) {&#13;
    _fillPointer(a, 0, length, sizeof(int64_t), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified long value to each element of the specified range&#13;
 * of the specified array of longs.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param fromIndex the index of the first element (inclusive) to be filled&#13;
 * with the specified value&#13;
 * @param toIndex the index of the last element (exclusive) to be filled&#13;
 * with the specified value&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillRangeL(int64_t *a, int32_t fromIndex, int32_t toIndex, int64_t val) {&#13;
    _fillPointer(a, fromIndex, toIndex, sizeof(int64_t), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified structure pointer to each element of the specified&#13;
 * array of structures.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param length The array length&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillObj(void **a, int32_t length, void *val) {&#13;
    _fillPointer(a, 0, length, sizeof(void *), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified structure pointer to each element of the specified&#13;
 * range of the specified array of structures.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param fromIndex the index of the first element (inclusive) to be filled&#13;
 * with the specified value&#13;
 * @param toIndex the index of the last element (exclusive) to be filled&#13;
 * with the specified value&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillRangeObj(void **a, int32_t fromIndex, int32_t toIndex, void *val) {&#13;
    _fillPointer(a, fromIndex, toIndex, sizeof(void *), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified short value to each element of the specified array&#13;
 * of shorts.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param length The array length&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillS(int16_t *a, int32_t length, int16_t val) {&#13;
    _fillPointer(a, 0, length, sizeof(int16_t), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Assigns the specified short value to each element of the specified range&#13;
 * of the specified array of shorts.&#13;
 *&#13;
 * @param a the array to be filled&#13;
 * @param fromIndex the index of the first element (inclusive) to be filled&#13;
 * with the specified value&#13;
 * @param toIndex the index of the last element (exclusive) to be filled&#13;
 * with the specified value&#13;
 * @param val the value to be stored in all elements of the array&#13;
 */&#13;
void Arrays_fillRangeS(int16_t *a, int32_t fromIndex, int32_t toIndex, int16_t val) {&#13;
    _fillPointer(a, fromIndex, toIndex, sizeof(int16_t), &amp;val);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified array into ascending numerical order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param length The array length&#13;
 */&#13;
void Arrays_sortB(int8_t *a, int32_t length) {&#13;
    _sortPointer(a, 0, length, sizeof(int8_t), _compareC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified range of the array into ascending order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param fromIndex the index of the first element (inclusive) to be sorted&#13;
 * @param toIndex the index of the last element (exclusive) to be sorted&#13;
 */&#13;
void Arrays_sortRangeB(int8_t *a, int32_t fromIndex, int32_t toIndex) {&#13;
    _sortPointer(a, fromIndex, toIndex, sizeof(int8_t), _compareC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified array into ascending numerical order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param length The array length&#13;
 */&#13;
void Arrays_sortC(char *a, int32_t length) {&#13;
    _sortPointer(a, 0, length, sizeof(char), _compareC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified range of the array into ascending order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param fromIndex the index of the first element (inclusive) to be sorted&#13;
 * @param toIndex the index of the last element (exclusive) to be sorted&#13;
 */&#13;
void Arrays_sortRangeC(char *a, int32_t fromIndex, int32_t toIndex) {&#13;
    _sortPointer(a, fromIndex, toIndex, sizeof(char), _compareC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified array into ascending numerical order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param length The array length&#13;
 */&#13;
void Arrays_sortD(double *a, int32_t length) {&#13;
    _sortPointer(a, 0, length, sizeof(double), _compareD, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified range of the array into ascending order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param fromIndex the index of the first element (inclusive) to be sorted&#13;
 * @param toIndex the index of the last element (exclusive) to be sorted&#13;
 */&#13;
void Arrays_sortRangeD(double *a, int32_t fromIndex, int32_t toIndex) {&#13;
    _sortPointer(a, fromIndex, toIndex, sizeof(double), _compareD, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified array into ascending numerical order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param length The array length&#13;
 */&#13;
void Arrays_sortF(float *a, int32_t length) {&#13;
    _sortPointer(a, 0, length, sizeof(float), _compareF, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified range of the array into ascending order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param fromIndex the index of the first element (inclusive) to be sorted&#13;
 * @param toIndex the index of the last element (exclusive) to be sorted&#13;
 */&#13;
void Arrays_sortRangeF(float *a, int32_t fromIndex, int32_t toIndex) {&#13;
    _sortPointer(a, fromIndex, toIndex, sizeof(float), _compareF, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified array into ascending numerical order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param length The array length&#13;
 */&#13;
void Arrays_sortI(int32_t *a, int32_t length) {&#13;
    _sortPointer(a, 0, length, sizeof(int32_t), _compareI, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified range of the array into ascending order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param fromIndex the index of the first element (inclusive) to be sorted&#13;
 * @param toIndex the index of the last element (exclusive) to be sorted&#13;
 */&#13;
void Arrays_sortRangeI(int32_t *a, int32_t fromIndex, int32_t toIndex) {&#13;
    _sortPointer(a, fromIndex, toIndex, sizeof(int32_t), _compareI, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified array into ascending numerical order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param length The array length&#13;
 */&#13;
void Arrays_sortL(int64_t *a, int32_t length) {&#13;
    _sortPointer(a, 0, length, sizeof(int64_t), _compareL, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified range of the array into ascending order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param fromIndex the index of the first element (inclusive) to be sorted&#13;
 * @param toIndex the index of the last element (exclusive) to be sorted&#13;
 */&#13;
void Arrays_sortRangeL(int64_t *a, int32_t fromIndex, int32_t toIndex) {&#13;
    _sortPointer(a, fromIndex, toIndex, sizeof(int64_t), _compareL, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified array of structures into ascending order, according to&#13;
 * the natural ordering of its elements.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param length The array length&#13;
 * @param c The structure compare function&#13;
 */&#13;
void Arrays_sortObj(void **a, int32_t length, int32_t (*c)(const void *, const void *)) {&#13;
    _sortPointer(a, 0, length, sizeof(void *), c, true);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified range of the specified array of structures into&#13;
 * ascending order, according to the natural ordering of its elements.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param fromIndex the index of the first element (inclusive) to be sorted&#13;
 * @param toIndex the index of the last element (exclusive) to be sorted&#13;
 * @param c The structure compare function&#13;
 */&#13;
void Arrays_sortRangeObj(void **a, int32_t fromIndex, int32_t toIndex, int32_t (*c)(const void *, const void *)) {&#13;
    _sortPointer(a, fromIndex, toIndex, sizeof(void *), c, true);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified array into ascending numerical order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param length The array length&#13;
 */&#13;
void Arrays_sortS(int16_t *a, int32_t length) {&#13;
    _sortPointer(a, 0, length, sizeof(int16_t), _compareS, false);&#13;
}&#13;
&#13;
/**&#13;
 * Sorts the specified range of the array into ascending order.&#13;
 *&#13;
 * @param a the array to be sorted&#13;
 * @param fromIndex the index of the first element (inclusive) to be sorted&#13;
 * @param toIndex the index of the last element (exclusive) to be sorted&#13;
 */&#13;
void Arrays_sortRangeS(int16_t *a, int32_t fromIndex, int32_t toIndex) {&#13;
    _sortPointer(a, fromIndex, toIndex, sizeof(int16_t), _compareS, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the contents of the specified array.&#13;
 *&#13;
 * @param a the array whose string representation to return&#13;
 * @param length The array length&#13;
 * @return a string representation of a&#13;
 */&#13;
String *Arrays_toStringBool(bool *a, int32_t length) {&#13;
    return _toStringPointer(a, length, sizeof(bool), _toStringBool, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the contents of the specified array.&#13;
 *&#13;
 * @param a the array whose string representation to return&#13;
 * @param length The array length&#13;
 * @return a string representation of a&#13;
 */&#13;
String *Arrays_toStringB(int8_t *a, int32_t length) {&#13;
    return _toStringPointer(a, length, sizeof(int8_t), _toStringB, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the contents of the specified array.&#13;
 *&#13;
 * @param a the array whose string representation to return&#13;
 * @param length The array length&#13;
 * @return a string representation of a&#13;
 */&#13;
String *Arrays_toStringC(char *a, int32_t length) {&#13;
    return _toStringPointer(a, length, sizeof(char), _toStringC, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the contents of the specified array.&#13;
 *&#13;
 * @param a the array whose string representation to return&#13;
 * @param length The array length&#13;
 * @return a string representation of a&#13;
 */&#13;
String *Arrays_toStringD(double *a, int32_t length) {&#13;
    return _toStringPointer(a, length, sizeof(double), _toStringD, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the contents of the specified array.&#13;
 *&#13;
 * @param a the array whose string representation to return&#13;
 * @param length The array length&#13;
 * @return a string representation of a&#13;
 */&#13;
String *Arrays_toStringF(float *a, int32_t length) {&#13;
    return _toStringPointer(a, length, sizeof(float), _toStringF, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the contents of the specified array.&#13;
 *&#13;
 * @param a the array whose string representation to return&#13;
 * @param length The array length&#13;
 * @return a string representation of a&#13;
 */&#13;
String *Arrays_toStringI(int32_t *a, int32_t length) {&#13;
    return _toStringPointer(a, length, sizeof(int32_t), _toStringI, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the contents of the specified array.&#13;
 *&#13;
 * @param a the array whose string representation to return&#13;
 * @param length The array length&#13;
 * @return a string representation of a&#13;
 */&#13;
String *Arrays_toStringL(int64_t *a, int32_t length) {&#13;
    return _toStringPointer(a, length, sizeof(int64_t), _toStringL, false);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the contents of the specified array.&#13;
 *&#13;
 * @param a the array whose string representation to return&#13;
 * @param length The array length&#13;
 * @param toString The structure toString function&#13;
 * @return a string representation of a&#13;
 */&#13;
String *Arrays_toStringObj(void **a, int32_t length, String *(*toString)(const void *)) {&#13;
    return _toStringPointer(a, length, sizeof(void *), toString, true);&#13;
}&#13;
&#13;
/**&#13;
 * Returns a string representation of the contents of the specified array.&#13;
 *&#13;
 * @param a the array whose string representation to return&#13;
 * @param length The array length&#13;
 * @return a string representation of a&#13;
 */&#13;
String *Arrays_toStringS(int16_t *a, int32_t length) {&#13;
    return _toStringPointer(a, length, sizeof(int16_t), _toStringS, false);&#13;
}&#13;
</code>
<code lang="C++">#ifndef ARRAYS_INCLUDED&#13;
#define	ARRAYS_INCLUDED&#13;
&#13;
#include "String_.h"&#13;
#include "System.h"&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;sstream&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
/**&#13;
 * This class contains various methods for manipulating arrays (such as sorting and searching).&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
class Arrays {&#13;
    static bool defaultBool;&#13;
    static int8_t defaultByte;&#13;
    static char defaultChar;&#13;
    static double defaultDouble;&#13;
    static float defaultFloat;&#13;
    static int32_t defaultInt;&#13;
    static int64_t defaultLong;&#13;
    static Object *defaultPointer;&#13;
    static int16_t defaultShort;&#13;
    static void *currentComparator; // hack to make the Comparator compare function call work&#13;
    static bool equalsBool(bool a, bool b);&#13;
    static bool equalsB(int8_t a, int8_t b);&#13;
    static bool equalsC(char a, char b);&#13;
    static bool equalsD(double a, double b);&#13;
    static bool equalsF(float a, float b);&#13;
    static bool equalsI(int32_t a, int32_t b);&#13;
    static bool equalsL(int64_t a, int64_t b);&#13;
    static bool equalsS(int16_t a, int16_t b);&#13;
    static bool equalsObj(Object *a, Object *b);&#13;
    static String *toStringObj(Object *a);&#13;
    static bool compareB(int8_t a, int8_t b);&#13;
    static bool compareC(char a, char b);&#13;
    static bool compareD(double a, double b);&#13;
    static bool compareF(float a, float b);&#13;
    static bool compareI(int32_t a, int32_t b);&#13;
    static bool compareL(int64_t a, int64_t b);&#13;
    static bool compareS(int16_t a, int16_t b);&#13;
    static bool compareObj(Object *a, Object *b);&#13;
    static bool compareObjComp(Object *a, Object *b);&#13;
    static int32_t compareBI(int8_t a, int8_t b);&#13;
    static int32_t compareCI(char a, char b);&#13;
    static int32_t compareDI(double a, double b);&#13;
    static int32_t compareFI(float a, float b);&#13;
    static int32_t compareII(int32_t a, int32_t b);&#13;
    static int32_t compareLI(int64_t a, int64_t b);&#13;
    static int32_t compareSI(int16_t a, int16_t b);&#13;
    static int32_t compareObjI(Object *a, Object *b);&#13;
    static int32_t compareObjCompI(Object *a, Object *b);&#13;
    template &lt;typename T&gt; static int32_t binarySearchGeneric(T *a, int32_t fromIndex, int32_t toIndex, T key, int32_t (*c)(T, T));&#13;
    template &lt;typename T&gt; static T *copyOfRangeGeneric(T *original, int32_t length, int32_t from, int32_t to, T defaultValue);&#13;
    template &lt;typename T&gt; static bool equalsGeneric(T *a, int32_t length, T *a2, int32_t length2, bool (*equals)(T, T), bool isObjectArray);&#13;
    template &lt;typename T&gt; static void fillGeneric(T *a, int32_t fromIndex, int32_t toIndex, T val);&#13;
    template &lt;typename T&gt; static void sortGeneric(T *a, int32_t fromIndex, int32_t toIndex, bool (*c)(T, T), bool isObjectArray = false);&#13;
    template &lt;typename T&gt; static String *toStringGeneric(T *a, int32_t length, String *(*toString)(T), bool isObjectArray);&#13;
public:&#13;
    static int32_t binarySearch(int8_t *a, int32_t length, int8_t key);&#13;
    static int32_t binarySearch(int8_t *a, int32_t fromIndex, int32_t toIndex, int8_t key);&#13;
    static int32_t binarySearch(char *a, int32_t length, char key);&#13;
    static int32_t binarySearch(char *a, int32_t fromIndex, int32_t toIndex, char key);&#13;
    static int32_t binarySearch(double *a, int32_t length, double key);&#13;
    static int32_t binarySearch(double *a, int32_t fromIndex, int32_t toIndex, double key);&#13;
    static int32_t binarySearch(float *a, int32_t length, float key);&#13;
    static int32_t binarySearch(float *a, int32_t fromIndex, int32_t toIndex, float key);&#13;
    static int32_t binarySearch(int32_t *a, int32_t length, int32_t key);&#13;
    static int32_t binarySearch(int32_t *a, int32_t fromIndex, int32_t toIndex, int32_t key);&#13;
    static int32_t binarySearch(int64_t *a, int32_t length, int64_t key);&#13;
    static int32_t binarySearch(int64_t *a, int32_t fromIndex, int32_t toIndex, int64_t key);&#13;
    static int32_t binarySearch(Object **a, int32_t length, Object *key);&#13;
    static int32_t binarySearch(Object **a, int32_t fromIndex, int32_t toIndex, Object *key);&#13;
    static int32_t binarySearch(int16_t *a, int32_t length, int16_t key);&#13;
    static int32_t binarySearch(int16_t *a, int32_t fromIndex, int32_t toIndex, int16_t key);&#13;
    static int32_t binarySearch(Object **a, int32_t length, Object *key, Comparator *c);&#13;
    static int32_t binarySearch(Object **a, int32_t fromIndex, int32_t toIndex, Object *key, Comparator *c);&#13;
    static bool *copyOf(bool *original, int32_t length, int32_t newLength);&#13;
    static int8_t *copyOf(int8_t *original, int32_t length, int32_t newLength);&#13;
    static char *copyOf(char *original, int32_t length, int32_t newLength);&#13;
    static double *copyOf(double *original, int32_t length, int32_t newLength);&#13;
    static float *copyOf(float *original, int32_t length, int32_t newLength);&#13;
    static int32_t *copyOf(int32_t *original, int32_t length, int32_t newLength);&#13;
    static int64_t *copyOf(int64_t *original, int32_t length, int32_t newLength);&#13;
    static int16_t *copyOf(int16_t *original, int32_t length, int32_t newLength);&#13;
    static Object **copyOf(Object **original, int32_t length, int32_t newLength);&#13;
    static bool *copyOfRange(bool *original, int32_t length, int32_t from, int32_t to);&#13;
    static int8_t *copyOfRange(int8_t *original, int32_t length, int32_t from, int32_t to);&#13;
    static char *copyOfRange(char *original, int32_t length, int32_t from, int32_t to);&#13;
    static double *copyOfRange(double *original, int32_t length, int32_t from, int32_t to);&#13;
    static float *copyOfRange(float *original, int32_t length, int32_t from, int32_t to);&#13;
    static int32_t *copyOfRange(int32_t *original, int32_t length, int32_t from, int32_t to);&#13;
    static int64_t *copyOfRange(int64_t *original, int32_t length, int32_t from, int32_t to);&#13;
    static int16_t *copyOfRange(int16_t *original, int32_t length, int32_t from, int32_t to);&#13;
    static Object **copyOfRange(Object **original, int32_t length, int32_t from, int32_t to);&#13;
    static bool equals(bool *a, int32_t length, bool *a2, int32_t length2);&#13;
    static bool equals(int8_t *a, int32_t length, int8_t *a2, int32_t length2);&#13;
    static bool equals(char *a, int32_t length, char *a2, int32_t length2);&#13;
    static bool equals(double *a, int32_t length, double *a2, int32_t length2);&#13;
    static bool equals(float *a, int32_t length, float *a2, int32_t length2);&#13;
    static bool equals(int32_t *a, int32_t length, int32_t *a2, int32_t length2);&#13;
    static bool equals(int64_t *a, int32_t length, int64_t *a2, int32_t length2);&#13;
    static bool equals(Object **a, int32_t length, Object **a2, int32_t length2);&#13;
    static bool equals(int16_t *a, int32_t length, int16_t *a2, int32_t length2);&#13;
    static void fill(bool *a, int32_t length, bool val);&#13;
    static void fill(bool *a, int32_t fromIndex, int32_t toIndex, bool val);&#13;
    static void fill(int8_t *a, int32_t length, int8_t val);&#13;
    static void fill(int8_t *a, int32_t fromIndex, int32_t toIndex, int8_t val);&#13;
    static void fill(char *a, int32_t length, char val);&#13;
    static void fill(char *a, int32_t fromIndex, int32_t toIndex, char val);&#13;
    static void fill(double *a, int32_t length, double val);&#13;
    static void fill(double *a, int32_t fromIndex, int32_t toIndex, double val);&#13;
    static void fill(float *a, int32_t length, float val);&#13;
    static void fill(float *a, int32_t fromIndex, int32_t toIndex, float val);&#13;
    static void fill(int32_t *a, int32_t length, int32_t val);&#13;
    static void fill(int32_t *a, int32_t fromIndex, int32_t toIndex, int32_t val);&#13;
    static void fill(int64_t *a, int32_t length, int64_t val);&#13;
    static void fill(int64_t *a, int32_t fromIndex, int32_t toIndex, int64_t val);&#13;
    static void fill(Object **a, int32_t length, Object *val);&#13;
    static void fill(Object **a, int32_t fromIndex, int32_t toIndex, Object *val);&#13;
    static void fill(int16_t *a, int32_t length, int16_t val);&#13;
    static void fill(int16_t *a, int32_t fromIndex, int32_t toIndex, int16_t val);&#13;
    static void sort(int8_t *a, int32_t length);&#13;
    static void sort(int8_t *a, int32_t fromIndex, int32_t toIndex);&#13;
    static void sort(char *a, int32_t length);&#13;
    static void sort(char *a, int32_t fromIndex, int32_t toIndex);&#13;
    static void sort(double *a, int32_t length);&#13;
    static void sort(double *a, int32_t fromIndex, int32_t toIndex);&#13;
    static void sort(float *a, int32_t length);&#13;
    static void sort(float *a, int32_t fromIndex, int32_t toIndex);&#13;
    static void sort(int32_t *a, int32_t length);&#13;
    static void sort(int32_t *a, int32_t fromIndex, int32_t toIndex);&#13;
    static void sort(int64_t *a, int32_t length);&#13;
    static void sort(int64_t *a, int32_t fromIndex, int32_t toIndex);&#13;
    static void sort(Object **a, int32_t length);&#13;
    static void sort(Object **a, int32_t fromIndex, int32_t toIndex);&#13;
    static void sort(int16_t *a, int32_t length);&#13;
    static void sort(int16_t *a, int32_t fromIndex, int32_t toIndex);&#13;
    static void sort(Object **a, int32_t length, Comparator *c);&#13;
    static void sort(Object **a, int32_t fromIndex, int32_t toIndex, Comparator *c);&#13;
    static String *toString(bool *a, int32_t length);&#13;
    static String *toString(int8_t *a, int32_t length);&#13;
    static String *toString(char *a, int32_t length);&#13;
    static String *toString(double *a, int32_t length);&#13;
    static String *toString(float *a, int32_t length);&#13;
    static String *toString(int32_t *a, int32_t length);&#13;
    static String *toString(int64_t *a, int32_t length);&#13;
    static String *toString(Object **a, int32_t length);&#13;
    static String *toString(int16_t *a, int32_t length);&#13;
};&#13;
&#13;
template &lt;typename T&gt; int32_t Arrays::binarySearchGeneric(T *a, int32_t fromIndex, int32_t toIndex, T key, int32_t (*c)(T, T)) {&#13;
    int32_t lower = fromIndex;&#13;
    int32_t upper = toIndex - 1;&#13;
&#13;
    while (lower &lt;= upper) {&#13;
        int32_t middle = ((uint32_t)lower + (uint32_t)upper) &gt;&gt; 1;&#13;
        T middleValue = a[middle];&#13;
&#13;
        if (c(middleValue, key) &lt; 0) {&#13;
            lower = middle + 1;&#13;
        }&#13;
        else if (c(middleValue, key) &gt; 0) {&#13;
            upper = middle - 1;&#13;
        }&#13;
        else {&#13;
            return middle;&#13;
        }&#13;
    }&#13;
    &#13;
    return -(lower + 1);&#13;
}&#13;
&#13;
template &lt;typename T&gt; T *Arrays::copyOfRangeGeneric(T *original, int32_t length, int32_t from, int32_t to, T defaultValue) {&#13;
    T *a = new T[to - from]();&#13;
&#13;
    if (to &gt; length) {&#13;
        for (int32_t i = from; i &lt; length; i++) {&#13;
            a[i - from] = original[i];&#13;
        }&#13;
&#13;
        for (int32_t i = length; i &lt; to; i++) {&#13;
            a[i - from] = defaultValue;&#13;
        }&#13;
    }&#13;
    else {&#13;
        for (int32_t i = from; i &lt; to; i++) {&#13;
            a[i - from] = original[i];&#13;
        }&#13;
    }&#13;
&#13;
    return a;&#13;
}&#13;
&#13;
template &lt;typename T&gt; bool Arrays::equalsGeneric(T *a, int32_t length, T *a2, int32_t length2, bool (*equals)(T, T), bool isObjectArray) {&#13;
    if (a == a2) {&#13;
        return true;&#13;
    }&#13;
&#13;
    if (a == nullptr || a2 == nullptr) {&#13;
        return false;&#13;
    }&#13;
&#13;
    if (length2 != length) {&#13;
        return false;&#13;
    }&#13;
&#13;
    for (int32_t i = 0; i &lt; length; i++) {&#13;
        bool e;&#13;
        &#13;
        if (isObjectArray) {&#13;
            e = a[i] == 0 ? a2[i] == 0 : equals(a[i], a2[i]);&#13;
        }&#13;
        else {&#13;
            e = equals(a[i], a2[i]);&#13;
        }&#13;
        &#13;
        if (!e) {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    return true;&#13;
}&#13;
&#13;
template &lt;typename T&gt; void Arrays::fillGeneric(T *a, int32_t fromIndex, int32_t toIndex, T val) {&#13;
    for (int32_t i = fromIndex; i &lt; toIndex; i++) {&#13;
        a[i] = val;&#13;
    }&#13;
}&#13;
&#13;
template &lt;typename T&gt; void Arrays::sortGeneric(T *a, int32_t fromIndex, int32_t toIndex, bool (*c)(T, T), bool isObjectArray) {&#13;
    if (c == nullptr) {&#13;
        std::sort(a + fromIndex, a + toIndex, c);&#13;
    }&#13;
    else {&#13;
        if (!isObjectArray) {&#13;
            std::sort(a + fromIndex, a + toIndex, c);&#13;
        }&#13;
        else {&#13;
            std::stable_sort(a + fromIndex, a + toIndex, c);&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
template &lt;typename T&gt; String *Arrays::toStringGeneric(T *a, int32_t length, String *(*toString)(T), bool isObjectArray) {&#13;
    std::ostringstream oss("");&#13;
    oss &lt;&lt; "[";&#13;
    String *str;&#13;
&#13;
    if (length &gt; 0) {&#13;
        if (isObjectArray) {&#13;
            str = a[0] == 0 ? new String("null") : toString(a[0]);&#13;
        }&#13;
        else  {&#13;
            str = toString(a[0]);&#13;
        }&#13;
        &#13;
        oss &lt;&lt; str-&gt;_s();&#13;
        delete str;&#13;
    }&#13;
&#13;
    for (int32_t i = 1; i &lt; length; i++) {&#13;
        if (isObjectArray) {&#13;
            str = a[i] == 0 ? new String("null") : toString(a[i]);&#13;
        }&#13;
        else  {&#13;
            str = toString(a[i]);&#13;
        }&#13;
        &#13;
        oss &lt;&lt; ", " &lt;&lt; str-&gt;_s();&#13;
        delete str;&#13;
    }&#13;
&#13;
    oss &lt;&lt; "]";&#13;
&#13;
    return new String(oss.str());&#13;
}&#13;
&#13;
#endif	// ARRAYS_INCLUDED&#13;
&#13;
&#13;
#include "Arrays.h"

#include "Boolean.h"
#include "Byte.h"
#include "Character.h"
#include "Double.h"
#include "Float.h"
#include "Integer.h"
#include "Long.h"
#include "Short.h"

bool Arrays::defaultBool = false;
int8_t Arrays::defaultByte = 0;
char Arrays::defaultChar = '\0';
double Arrays::defaultDouble = 0.0;
float Arrays::defaultFloat = 0.0f;
int32_t Arrays::defaultInt = 0;
int64_t Arrays::defaultLong = 0LL;
Object *Arrays::defaultPointer = 0;
int16_t Arrays::defaultShort = 0;
void *Arrays::currentComparator = nullptr;

bool Arrays::equalsBool(bool a, bool b) {
    Boolean x(a);
    Boolean y(b);

    return (&amp;x)-&gt;equals(&amp;y);
}

bool Arrays::equalsB(int8_t a, int8_t b) {
    Byte x(a);
    Byte y(b);

    return (&amp;x)-&gt;equals(&amp;y);
}

bool Arrays::equalsC(char a, char b) {
    Character x(a);
    Character y(b);

    return (&amp;x)-&gt;equals(&amp;y);
}

bool Arrays::equalsD(double a, double b) {
    Double x(a);
    Double y(b);

    return (&amp;x)-&gt;equals(&amp;y);
}

bool Arrays::equalsF(float a, float b) {
    Float x(a);
    Float y(b);

    return (&amp;x)-&gt;equals(&amp;y);
}

bool Arrays::equalsI(int32_t a, int32_t b) {
    Integer x(a);
    Integer y(b);

    return (&amp;x)-&gt;equals(&amp;y);
}

bool Arrays::equalsL(int64_t a, int64_t b) {
    Long x(a);
    Long y(b);

    return (&amp;x)-&gt;equals(&amp;y);
}

bool Arrays::equalsS(int16_t a, int16_t b) {
    Short x(a);
    Short y(b);

    return (&amp;x)-&gt;equals(&amp;y);
}

bool Arrays::equalsObj(Object *a, Object *b) {
    return a-&gt;equals(b);
}

String *Arrays::toStringObj(Object *a) {
    return a-&gt;toString();
}

bool Arrays::compareB(int8_t a, int8_t b) {
    return compareBI(a, b) &lt; 0;
}

bool Arrays::compareC(char a, char b) {
    return compareCI(a, b) &lt; 0;
}

bool Arrays::compareD(double a, double b) {
    return compareDI(a, b) &lt; 0;
}

bool Arrays::compareF(float a, float b) {
    return compareFI(a, b) &lt; 0;
}

bool Arrays::compareI(int32_t a, int32_t b) {
    return compareII(a, b) &lt; 0;
}

bool Arrays::compareL(int64_t a, int64_t b) {
    return compareLI(a, b) &lt; 0;
}

bool Arrays::compareS(int16_t a, int16_t b) {
    return compareSI(a, b) &lt; 0;
}

bool Arrays::compareObj(Object *a, Object *b) {
    return compareObjI(a, b) &lt; 0;
}

bool Arrays::compareObjComp(Object *a, Object *b) {
    return compareObjCompI(a, b) &lt; 0;
}

int32_t Arrays::compareBI(int8_t a, int8_t b) {
    return Byte::compare(a, b);
}

int32_t Arrays::compareCI(char a, char b) {
    return Character::compare(a, b);
}

int32_t Arrays::compareDI(double a, double b) {
    return Double::compare(a, b);
}

int32_t Arrays::compareFI(float a, float b) {
    return Float::compare(a, b);
}

int32_t Arrays::compareII(int32_t a, int32_t b) {
    return Integer::compare(a, b);
}

int32_t Arrays::compareLI(int64_t a, int64_t b) {
    return Long::compare(a, b);
}

int32_t Arrays::compareSI(int16_t a, int16_t b) {
    return Short::compare(a, b);
}

int32_t Arrays::compareObjI(Object *a, Object *b) {
    Comparable *x = (Comparable *) a;
    Comparable *y = (Comparable *) b;
    
    return x-&gt;compareTo(y);
}

int32_t Arrays::compareObjCompI(Object *a, Object *b) {
    return ((Comparator *) currentComparator)-&gt;compare(a, b);
}

/**
 * Searches the specified array of bytes for the specified value using the
 * binary search algorithm
 *
 * @param a the array to be searched
 * @param length The array length
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 */
int32_t Arrays::binarySearch(int8_t *a, int32_t length, int8_t key) {
    return binarySearchGeneric(a, 0, length, key, compareBI);
}

/**
 * Searches a range of the specified array of bytes for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 */
int32_t Arrays::binarySearch(int8_t *a, int32_t fromIndex, int32_t toIndex, int8_t key) {
    return binarySearchGeneric(a, fromIndex, toIndex, key, compareBI);
}

/**
 * Searches the specified array of chars for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param length The array length
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 */
int32_t Arrays::binarySearch(char *a, int32_t length, char key) {
    return binarySearchGeneric(a, 0, length, key, compareCI);
}

/**
 * Searches a range of the specified array of chars for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 */
int32_t Arrays::binarySearch(char *a, int32_t fromIndex, int32_t toIndex, char key) {
    return binarySearchGeneric(a, fromIndex, toIndex, key, compareCI);
}

/**
 * Searches the specified array of doubles for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param length The array length
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 */
int32_t Arrays::binarySearch(double *a, int32_t length, double key) {
    return binarySearchGeneric(a, 0, length, key, compareDI);
}

/**
 * Searches a range of the specified array of doubles for the specified
 * value using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 */
int32_t Arrays::binarySearch(double *a, int32_t fromIndex, int32_t toIndex, double key) {
    return binarySearchGeneric(a, fromIndex, toIndex, key, compareDI);
}

/**
 * Searches the specified array of floats for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param length The array length
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 */
int32_t Arrays::binarySearch(float *a, int32_t length, float key) {
    return binarySearchGeneric(a, 0, length, key, compareFI);
}

/**
 * Searches a range of the specified array of floats for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 */
int32_t Arrays::binarySearch(float *a, int32_t fromIndex, int32_t toIndex, float key) {
    return binarySearchGeneric(a, fromIndex, toIndex, key, compareFI);
}

/**
 * Searches the specified array of ints for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param length The array length
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 */
int32_t Arrays::binarySearch(int32_t *a, int32_t length, int32_t key) {
    return binarySearchGeneric(a, 0, length, key, compareII);
}

/**
 * Searches a range of the specified array of ints for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 */
int32_t Arrays::binarySearch(int32_t *a, int32_t fromIndex, int32_t toIndex, int32_t key) {
    return binarySearchGeneric(a, fromIndex, toIndex, key, compareII);
}

/**
 * Searches the specified array of longs for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param length The array length
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 */
int32_t Arrays::binarySearch(int64_t *a, int32_t length, int64_t key) {
    return binarySearchGeneric(a, 0, length, key, compareLI);
}

/**
 * Searches a range of the specified array of longs for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 */
int32_t Arrays::binarySearch(int64_t *a, int32_t fromIndex, int32_t toIndex, int64_t key) {
    return binarySearchGeneric(a, fromIndex, toIndex, key, compareLI);
}

/**
 * Searches the specified array for the specified object using the binary
 * search algorithm.
 *
 * @param a the array to be searched
 * @param length The array length
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 */
int32_t Arrays::binarySearch(Object **a, int32_t length, Object *key) {
    return binarySearchGeneric(a, 0, length, key, compareObjI);
}

/**
 * Searches a range of the specified array for the specified object using
 * the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 */
int32_t Arrays::binarySearch(Object **a, int32_t fromIndex, int32_t toIndex, Object *key) {
    return binarySearchGeneric(a, fromIndex, toIndex, key, compareObjI);
}

/**
 * Searches the specified array of shorts for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param length The array length
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 */
int32_t Arrays::binarySearch(int16_t *a, int32_t length, int16_t key) {
    return binarySearchGeneric(a, 0, length, key, compareSI);
}

/**
 * Searches a range of the specified array of shorts for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 */
int32_t Arrays::binarySearch(int16_t *a, int32_t fromIndex, int32_t toIndex, int16_t key) {
    return binarySearchGeneric(a, fromIndex, toIndex, key, compareSI);
}

/**
 * Searches the specified array for the specified object using the binary
 * search algorithm.
 *
 * @param a the array to be searched
 * @param length The array length
 * @param key the value to be searched for
 * @param c the comparator by which the array is ordered. A null value
 * indicates that the elements' natural ordering should be used.
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 */
int32_t Arrays::binarySearch(Object **a, int32_t length, Object *key, Comparator *c) {
    currentComparator = c;
    return binarySearchGeneric(a, 0, length, key, compareObjCompI);
}

/**
 * Searches a range of the specified array for the specified object using
 * the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @param c the comparator by which the array is ordered. A null value
 * indicates that the elements' natural ordering should be used.
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 */
int32_t Arrays::binarySearch(Object **a, int32_t fromIndex, int32_t toIndex, Object *key, Comparator *c) {
    currentComparator = c;
    return binarySearchGeneric(a, fromIndex, toIndex, key, compareObjCompI);
}

/**
 * Copies the specified array, truncating or padding with false (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param length The array length
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with false
 * elements to obtain the specified length
 */
bool *Arrays::copyOf(bool *original, int32_t length, int32_t newLength) {
    return copyOfRangeGeneric(original, length, 0, newLength, defaultBool);
}

/**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param length The array length
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 */
int8_t *Arrays::copyOf(int8_t *original, int32_t length, int32_t newLength) {
    return copyOfRangeGeneric(original, length, 0, newLength, defaultByte);
}

/**
 * Copies the specified array, truncating or padding with null characters
 * (if necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param length The array length
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with null
 * characters to obtain the specified length
 */
char *Arrays::copyOf(char *original, int32_t length, int32_t newLength) {
    return copyOfRangeGeneric(original, length, 0, newLength, defaultChar);
}

/**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param length The array length
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 */
double *Arrays::copyOf(double *original, int32_t length, int32_t newLength) {
    return copyOfRangeGeneric(original, length, 0, newLength, defaultDouble);
}

/**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param length The array length
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 */
float *Arrays::copyOf(float *original, int32_t length, int32_t newLength) {
    return copyOfRangeGeneric(original, length, 0, newLength, defaultFloat);
}

/**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param length The array length
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 */
int32_t *Arrays::copyOf(int32_t *original, int32_t length, int32_t newLength) {
    return copyOfRangeGeneric(original, length, 0, newLength, defaultInt);
}

/**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param length The array length
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 */
int64_t *Arrays::copyOf(int64_t *original, int32_t length, int32_t newLength) {
    return copyOfRangeGeneric(original, length, 0, newLength, defaultLong);
}

/**
 * Copies the specified array, truncating or padding with nulls (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param length The array length
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with nulls to
 * obtain the specified length
 */
Object **Arrays::copyOf(Object **original, int32_t length, int32_t newLength) {
    return copyOfRangeGeneric(original, length, 0, newLength, defaultPointer);
}

/**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param length The array length
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 */
int16_t *Arrays::copyOf(int16_t *original, int32_t length, int32_t newLength) {
    return copyOfRangeGeneric(original, length, 0, newLength, defaultShort);
}

/**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param length The array length
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with false elements to obtain the required
 * length
 */
bool *Arrays::copyOfRange(bool *original, int32_t length, int32_t from, int32_t to) {
    return copyOfRangeGeneric(original, length, from, to, defaultBool);
}

/**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param length The array length
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 */
int8_t *Arrays::copyOfRange(int8_t *original, int32_t length, int32_t from, int32_t to) {
    return copyOfRangeGeneric(original, length, from, to, defaultByte);
}

/**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param length The array length
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with null characters to obtain the required
 * length
 */
char *Arrays::copyOfRange(char *original, int32_t length, int32_t from, int32_t to) {
    return copyOfRangeGeneric(original, length, from, to, defaultChar);
}

/**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param length The array length
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 */
double *Arrays::copyOfRange(double *original, int32_t length, int32_t from, int32_t to) {
    return copyOfRangeGeneric(original, length, from, to, defaultDouble);
}

/**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param length The array length
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 */
float *Arrays::copyOfRange(float *original, int32_t length, int32_t from, int32_t to) {
    return copyOfRangeGeneric(original, length, from, to, defaultFloat);
}

/**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param length The array length
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 */
int32_t *Arrays::copyOfRange(int32_t *original, int32_t length, int32_t from, int32_t to) {
    return copyOfRangeGeneric(original, length, from, to, defaultInt);
}

/**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param length The array length
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 */
int64_t *Arrays::copyOfRange(int64_t *original, int32_t length, int32_t from, int32_t to) {
    return copyOfRangeGeneric(original, length, from, to, defaultLong);
}

/**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param length The array length
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with nulls to obtain the required length
 */
Object **Arrays::copyOfRange(Object **original, int32_t length, int32_t from, int32_t to) {
    return copyOfRangeGeneric(original, length, from, to, defaultPointer);
}

/**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param length The array length
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 */
int16_t *Arrays::copyOfRange(int16_t *original, int32_t length, int32_t from, int32_t to) {
    return copyOfRangeGeneric(original, length, from, to, defaultShort);
}

/**
 * Returns true if the two specified arrays of booleans are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param length The array length
 * @param a2 the other array to be tested for equality
 * @param length2 The other array length
 * @return true if the two arrays are equal
 */
bool Arrays::equals(bool *a, int32_t length, bool *a2, int32_t length2) {
    return equalsGeneric(a, length, a2, length2, equalsBool, false);
}

/**
 * Returns true if the two specified arrays of bytes are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param length The array length
 * @param a2 the other array to be tested for equality
 * @param length2 The other array length
 * @return true if the two arrays are equal
 */
bool Arrays::equals(int8_t *a, int32_t length, int8_t *a2, int32_t length2) {
    return equalsGeneric(a, length, a2, length2, equalsB, false);
}

/**
 * Returns true if the two specified arrays of chars are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param length The array length
 * @param a2 the other array to be tested for equality
 * @param length2 The other array length
 * @return true if the two arrays are equal
 */
bool Arrays::equals(char *a, int32_t length, char *a2, int32_t length2) {
    return equalsGeneric(a, length, a2, length2, equalsC, false);
}

/**
 * Returns true if the two specified arrays of doubles are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param length The array length
 * @param a2 the other array to be tested for equality
 * @param length2 The other array length
 * @return true if the two arrays are equal
 */
bool Arrays::equals(double *a, int32_t length, double *a2, int32_t length2) {
    return equalsGeneric(a, length, a2, length2, equalsD, false);
}

/**
 * Returns true if the two specified arrays of floats are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param length The array length
 * @param a2 the other array to be tested for equality
 * @param length2 The other array length
 * @return true if the two arrays are equal
 */
bool Arrays::equals(float *a, int32_t length, float *a2, int32_t length2) {
    return equalsGeneric(a, length, a2, length2, equalsF, false);
}

/**
 * Returns true if the two specified arrays of ints are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param length The array length
 * @param a2 the other array to be tested for equality
 * @param length2 The other array length
 * @return true if the two arrays are equal
 */
bool Arrays::equals(int32_t *a, int32_t length, int32_t *a2, int32_t length2) {
    return equalsGeneric(a, length, a2, length2, equalsI, false);
}

/**
 * Returns true if the two specified arrays of longs are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param length The array length
 * @param a2 the other array to be tested for equality
 * @param length2 The other array length
 * @return true if the two arrays are equal
 */
bool Arrays::equals(int64_t *a, int32_t length, int64_t *a2, int32_t length2) {
    return equalsGeneric(a, length, a2, length2, equalsL, false);
}

/**
 * Returns true if the two specified arrays of Objects are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param length The array length
 * @param a2 the other array to be tested for equality
 * @param length2 The other array length
 * @return true if the two arrays are equal
 */
bool Arrays::equals(Object **a, int32_t length, Object **a2, int32_t length2) {
    return equalsGeneric(a, length, a2, length2, equalsObj, true);
}

/**
 * Returns true if the two specified arrays of shorts are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param length The array length
 * @param a2 the other array to be tested for equality
 * @param length2 The other array length
 * @return true if the two arrays are equal
 */
bool Arrays::equals(int16_t *a, int32_t length, int16_t *a2, int32_t length2) {
    return equalsGeneric(a, length, a2, length2, equalsS, false);
}

/**
 * Assigns the specified boolean value to each element of the specified
 * array of booleans.
 *
 * @param a the array to be filled
 * @param length The array length
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(bool *a, int32_t length, bool val) {
    fillGeneric(a, 0, length, val);
}

/**
 * Assigns the specified boolean value to each element of the specified
 * range of the specified array of booleans.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(bool *a, int32_t fromIndex, int32_t toIndex, bool val) {
    fillGeneric(a, fromIndex, toIndex, val);
}

/**
 * Assigns the specified byte value to each element of the specified array
 * of bytes.
 *
 * @param a the array to be filled
 * @param length The array length
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(int8_t *a, int32_t length, int8_t val) {
    fillGeneric(a, 0, length, val);
}

/**
 * Assigns the specified byte value to each element of the specified range
 * of the specified array of bytes.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(int8_t *a, int32_t fromIndex, int32_t toIndex, int8_t val) {
    fillGeneric(a, fromIndex, toIndex, val);
}

/**
 * Assigns the specified char value to each element of the specified array
 * of chars.
 *
 * @param a the array to be filled
 * @param length The array length
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(char *a, int32_t length, char val) {
    fillGeneric(a, 0, length, val);
}

/**
 * Assigns the specified char value to each element of the specified range
 * of the specified array of chars.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(char *a, int32_t fromIndex, int32_t toIndex, char val) {
    fillGeneric(a, fromIndex, toIndex, val);
}

/**
 * Assigns the specified double value to each element of the specified array
 * of doubles.
 *
 * @param a the array to be filled
 * @param length The array length
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(double *a, int32_t length, double val) {
    fillGeneric(a, 0, length, val);
}

/**
 * Assigns the specified double value to each element of the specified range
 * of the specified array of doubles.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(double *a, int32_t fromIndex, int32_t toIndex, double val) {
    fillGeneric(a, fromIndex, toIndex, val);
}

/**
 * Assigns the specified float value to each element of the specified array
 * of floats.
 *
 * @param a the array to be filled
 * @param length The array length
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(float *a, int32_t length, float val) {
    fillGeneric(a, 0, length, val);
}

/**
 * Assigns the specified float value to each element of the specified range
 * of the specified array of floats.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(float *a, int32_t fromIndex, int32_t toIndex, float val) {
    fillGeneric(a, fromIndex, toIndex, val);
}

/**
 * Assigns the specified int value to each element of the specified array of
 * ints.
 *
 * @param a the array to be filled
 * @param length The array length
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(int32_t *a, int32_t length, int32_t val) {
    fillGeneric(a, 0, length, val);
}

/**
 * Assigns the specified int value to each element of the specified range of
 * the specified array of ints.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(int32_t *a, int32_t fromIndex, int32_t toIndex, int32_t val) {
    fillGeneric(a, fromIndex, toIndex, val);
}

/**
 * Assigns the specified long value to each element of the specified array
 * of longs.
 *
 * @param a the array to be filled
 * @param length The array length
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(int64_t *a, int32_t length, int64_t val) {
    fillGeneric(a, 0, length, val);
}

/**
 * Assigns the specified long value to each element of the specified range
 * of the specified array of longs.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(int64_t *a, int32_t fromIndex, int32_t toIndex, int64_t val) {
    fillGeneric(a, fromIndex, toIndex, val);
}

/**
 * Assigns the specified Object pointer to each element of the specified
 * array of Objects.
 *
 * @param a the array to be filled
 * @param length The array length
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(Object **a, int32_t length, Object *val) {
    fillGeneric(a, 0, length, val);
}

/**
 * Assigns the specified Object pointer to each element of the specified
 * range of the specified array of Objects.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(Object **a, int32_t fromIndex, int32_t toIndex, Object *val) {
    fillGeneric(a, fromIndex, toIndex, val);
}

/**
 * Assigns the specified short value to each element of the specified array
 * of shorts.
 *
 * @param a the array to be filled
 * @param length The array length
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(int16_t *a, int32_t length, int16_t val) {
    fillGeneric(a, 0, length, val);
}

/**
 * Assigns the specified short value to each element of the specified range
 * of the specified array of shorts.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 */
void Arrays::fill(int16_t *a, int32_t fromIndex, int32_t toIndex, int16_t val) {
    fillGeneric(a, fromIndex, toIndex, val);
}

/**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 * @param length The array length
 */
void Arrays::sort(int8_t *a, int32_t length) {
    sortGeneric(a, 0, length, compareB);
}

/**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 */
void Arrays::sort(int8_t *a, int32_t fromIndex, int32_t toIndex) {
    sortGeneric(a, fromIndex, toIndex, compareB);
}

/**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 * @param length The array length
 */
void Arrays::sort(char *a, int32_t length) {
    sortGeneric(a, 0, length, compareC);
}

/**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 */
void Arrays::sort(char *a, int32_t fromIndex, int32_t toIndex) {
    sortGeneric(a, fromIndex, toIndex, compareC);
}

/**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 * @param length The array length
 */
void Arrays::sort(double *a, int32_t length) {
    sortGeneric(a, 0, length, compareD);
}

/**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 */
void Arrays::sort(double *a, int32_t fromIndex, int32_t toIndex) {
    sortGeneric(a, fromIndex, toIndex, compareD);
}

/**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 * @param length The array length
 */
void Arrays::sort(float *a, int32_t length) {
    sortGeneric(a, 0, length, compareF);
}

/**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 */
void Arrays::sort(float *a, int32_t fromIndex, int32_t toIndex) {
    sortGeneric(a, fromIndex, toIndex, compareF);
}

/**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 * @param length The array length
 */
void Arrays::sort(int32_t *a, int32_t length) {
    sortGeneric(a, 0, length, compareI);
}

/**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 */
void Arrays::sort(int32_t *a, int32_t fromIndex, int32_t toIndex) {
    sortGeneric(a, fromIndex, toIndex, compareI);
}

/**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 * @param length The array length
 */
void Arrays::sort(int64_t *a, int32_t length) {
    sortGeneric(a, 0, length, compareL);
}

/**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 */
void Arrays::sort(int64_t *a, int32_t fromIndex, int32_t toIndex) {
    sortGeneric(a, fromIndex, toIndex, compareL);
}

/**
 * Sorts the specified array of objects into ascending order, according to
 * the natural ordering of its elements.
 *
 * @param a the array to be sorted
 * @param length The array length
 */
void Arrays::sort(Object **a, int32_t length) {
    sortGeneric(a, 0, length, compareObj);
}

/**
 * Sorts the specified range of the specified array of objects into
 * ascending order, according to the natural ordering of its elements.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 */
void Arrays::sort(Object **a, int32_t fromIndex, int32_t toIndex) {
    sortGeneric(a, fromIndex, toIndex, compareObj);
}

/**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 * @param length The array length
 */
void Arrays::sort(int16_t *a, int32_t length) {
    sortGeneric(a, 0, length, compareS);
}

/**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 */
void Arrays::sort(int16_t *a, int32_t fromIndex, int32_t toIndex) {
    sortGeneric(a, fromIndex, toIndex, compareS);
}

/**
 * Sorts the specified array of objects according to the order induced by
 * the specified comparator.
 *
 * @param a the array to be sorted
 * @param length The array length
 * @param c the comparator to determine the order of the array. A null value
 * indicates that the elements' natural ordering should be used.
 */
void Arrays::sort(Object **a, int32_t length, Comparator *c) {
    currentComparator = c;
    sortGeneric(a, 0, length, compareObjComp, true);
}

/**
 * Sorts the specified range of the specified array of objects according to
 * the order induced by the specified comparator.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 * @param c the comparator to determine the order of the array. A null value
 * indicates that the elements' natural ordering should be used.
 */
void Arrays::sort(Object **a, int32_t fromIndex, int32_t toIndex, Comparator *c) {
    currentComparator = c;
    sortGeneric(a, fromIndex, toIndex, compareObjComp, true);
}

/**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @param length The array length
 * @return a string representation of a
 */
String *Arrays::toString(bool *a, int32_t length) {
    return toStringGeneric(a, length, Boolean::toString, false);
}

/**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @param length The array length
 * @return a string representation of a
 */
String *Arrays::toString(int8_t *a, int32_t length) {
    return toStringGeneric(a, length, Byte::toString, false);
}

/**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @param length The array length
 * @return a string representation of a
 */
String *Arrays::toString(char *a, int32_t length) {
    return toStringGeneric(a, length, Character::toString, false);
}

/**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @param length The array length
 * @return a string representation of a
 */
String *Arrays::toString(double *a, int32_t length) {
    return toStringGeneric(a, length, Double::toString, false);
}

/**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @param length The array length
 * @return a string representation of a
 */
String *Arrays::toString(float *a, int32_t length) {
    return toStringGeneric(a, length, Float::toString, false);
}

/**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @param length The array length
 * @return a string representation of a
 */
String *Arrays::toString(int32_t *a, int32_t length) {
    return toStringGeneric(a, length, Integer::toString, false);
}

/**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @param length The array length
 * @return a string representation of a
 */
String *Arrays::toString(int64_t *a, int32_t length) {
    return toStringGeneric(a, length, Long::toString, false);
}

/**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @param length The array length
 * @return a string representation of a
 */
String *Arrays::toString(Object **a, int32_t length) {
    return toStringGeneric(a, length, toStringObj, true);
}

/**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @param length The array length
 * @return a string representation of a
 */
String *Arrays::toString(int16_t *a, int32_t length) {
    return toStringGeneric(a, length, Short::toString, false);
}
</code>
<code lang="C#">using System;&#13;
using System.Collections.Generic;&#13;
&#13;
namespace JavaClasses&#13;
{&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// This class contains various methods for manipulating arrays (such as sorting and searching).&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;author&gt;Petr Kozler (A13B0359P)&lt;/author&gt;&#13;
    public static class Arrays&#13;
    {&#13;
&#13;
        // delegate for testing if two values are equal&#13;
        private delegate bool EqualsMethod&lt;T&gt;(T o1, T o2);&#13;
&#13;
        // comparator for 8-bit signed integer values&#13;
        private class ByteComparer : IComparer&lt;sbyte&gt;&#13;
        {&#13;
            public int Compare(sbyte x, sbyte y)&#13;
            {&#13;
                return Byte.compare(x, y);&#13;
            }&#13;
        }&#13;
&#13;
        // comparator for characters&#13;
        private class CharacterComparer : IComparer&lt;char&gt;&#13;
        {&#13;
            public int Compare(char x, char y)&#13;
            {&#13;
                return Character.compare(x, y);&#13;
            }&#13;
        }&#13;
&#13;
        // comparator for double-precision decimal values&#13;
        private class DoubleComparer : IComparer&lt;double&gt;&#13;
        {&#13;
            public int Compare(double x, double y)&#13;
            {&#13;
                return Double.compare(x, y);&#13;
            }&#13;
        }&#13;
&#13;
        // comparator for single-precision decimal values&#13;
        private class FloatComparer : IComparer&lt;float&gt;&#13;
        {&#13;
            public int Compare(float x, float y)&#13;
            {&#13;
                return Float.compare(x, y);&#13;
            }&#13;
        }&#13;
&#13;
        // comparator for 32-bit signed integer values&#13;
        private class IntegerComparer : IComparer&lt;int&gt;&#13;
        {&#13;
            public int Compare(int x, int y)&#13;
            {&#13;
                return Integer.compare(x, y);&#13;
            }&#13;
        }&#13;
&#13;
        // comparator for 64-bit signed integer values&#13;
        private class LongComparer : IComparer&lt;long&gt;&#13;
        {&#13;
            public int Compare(long x, long y)&#13;
            {&#13;
                return Long.compare(x, y);&#13;
            }&#13;
        }&#13;
&#13;
        // comparator for 16-bit signed integer values&#13;
        private class ObjectComparer : IComparer&lt;Object&gt;&#13;
        {&#13;
            public int Compare(Object x, Object y)&#13;
            {&#13;
                return (x as Comparable).compareTo(y as Comparable);&#13;
            }&#13;
        }&#13;
&#13;
        // comparator for 16-bit signed integer values&#13;
        private class ShortComparer : IComparer&lt;short&gt;&#13;
        {&#13;
            public int Compare(short x, short y)&#13;
            {&#13;
                return Short.compare(x, y);&#13;
            }&#13;
        }&#13;
&#13;
        /*&#13;
            Represents the type-agnostic method for binary searching&#13;
            in the specified sorted part of any array according to a specified comparator.&#13;
         */&#13;
        private static int binarySearchGeneric&lt;T&gt;(T[] a, int? fromIndex, int? toIndex, T key, IComparer&lt;T&gt; c)&#13;
        {&#13;
            int fromIndexValue = fromIndex ?? 0;&#13;
            int toIndexValue = toIndex ?? a.Length;&#13;
            &#13;
            return Array.BinarySearch(a, fromIndexValue, toIndexValue - fromIndexValue, key, c);&#13;
        }&#13;
&#13;
        /*&#13;
            Represents the type-agnostic method for copying&#13;
            the specified part of any array.&#13;
         */&#13;
        private static T[] copyOfRangeGeneric&lt;T&gt;(T[] original, int? from, int to)&#13;
        {&#13;
            int fromValue = from ?? 0;&#13;
&#13;
            // a new array with the length equal to the difference of boundaries of the original array&#13;
            T[] a = new T[to - fromValue];&#13;
&#13;
            // the specified upper boundary if greater than the original array length&#13;
            if (to &gt; original.Length)&#13;
            {&#13;
                // copying the values from the original array to its last element&#13;
                for (int i = fromValue; i &lt; original.Length; i++)&#13;
                {&#13;
                    a[i - fromValue] = original[i];&#13;
                }&#13;
&#13;
                // filling the rest of the new array with the default value of the given type&#13;
                for (int i = original.Length; i &lt; to; i++)&#13;
                {&#13;
                    a[i - fromValue] = default(T);&#13;
                }&#13;
            }&#13;
            // the specified upper boundary is less then the original array length&#13;
            else&#13;
            {&#13;
                // copying the values from the original array to the element on the specified upper boundary&#13;
                for (int i = fromValue; i &lt; to; i++)&#13;
                {&#13;
                    a[i - fromValue] = original[i];&#13;
                }&#13;
            }&#13;
&#13;
            return a;&#13;
        }&#13;
&#13;
        /*&#13;
            Represents the type-agnostic method for testing if two&#13;
            specified arrays are equal.&#13;
         */&#13;
        private static bool equalsGeneric&lt;T&gt;(T[] a, T[] a2, EqualsMethod&lt;T&gt; equals)&#13;
        {&#13;
            // comparing references&#13;
            if (a == a2)&#13;
            {&#13;
                return true;&#13;
            }&#13;
&#13;
            // testing the references for a NULL value&#13;
            if (a == null || a2 == null)&#13;
            {&#13;
                return false;&#13;
            }&#13;
&#13;
            int length = a.Length;&#13;
&#13;
            // compring the array lengths&#13;
            if (a2.Length != length)&#13;
            {&#13;
                return false;&#13;
            }&#13;
&#13;
            // comparing corresponding elements of arrays&#13;
            for (int i = 0; i &lt; length; i++)&#13;
            {&#13;
                if (!equals(a[i], a2[i]))&#13;
                {&#13;
                    return false;&#13;
                }&#13;
            }&#13;
&#13;
            return true;&#13;
        }&#13;
&#13;
        /*&#13;
            Represents the type-agnostic method for filling&#13;
            the specified part of any array with the specified value.&#13;
         */&#13;
        private static void fillGeneric&lt;T&gt;(T[] a, int? fromIndex, int? toIndex, T val)&#13;
        {&#13;
            int fromIndexValue = fromIndex ?? 0;&#13;
            int toIndexValue = toIndex ?? a.Length;&#13;
&#13;
            // setting each element with the value&#13;
            for (int i = fromIndexValue; i &lt; toIndexValue; i++)&#13;
            {&#13;
                a[i] = val;&#13;
            }&#13;
        }&#13;
&#13;
        /*&#13;
            Represents the type-agnostic method for sorting&#13;
            the specified part of any array according to a specified comparator.&#13;
         */&#13;
        private static void sortGeneric&lt;T&gt;(T[] a, int? fromIndex, int? toIndex, IComparer&lt;T&gt; c)&#13;
        {&#13;
            int fromIndexValue = fromIndex ?? 0;&#13;
            int toIndexValue = toIndex ?? a.Length;&#13;
&#13;
            Array.Sort(a, fromIndexValue, toIndexValue - fromIndexValue, c);&#13;
        }&#13;
&#13;
        /*&#13;
            Represents the type-agnostic method for creating&#13;
            the string representation of any array.&#13;
         */&#13;
        private static String toStringGeneric&lt;T&gt;(T[] a)&#13;
        {&#13;
            StringBuilder sb = new StringBuilder();&#13;
            sb.append(new String("["));&#13;
&#13;
            if (a.Length &gt; 0)&#13;
            {&#13;
                sb.append(a[0] == null ? "null" : a[0].ToString());&#13;
            }&#13;
&#13;
            for (int i = 1; i &lt; a.Length; i++)&#13;
            {&#13;
                sb.append(new String(", ")).append(a[i] == null ? "null" : a[i].ToString());&#13;
            }&#13;
&#13;
            return sb.append(new String("]")).toString();&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches the specified array of bytes for the specified value using the&#13;
        /// binary search algorithm&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array;&#13;
        /// otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
        /// the point at which the key would be inserted into the array: the index of&#13;
        /// the first element greater than the key, or a.length if all elements in&#13;
        /// the array are less than the specified key. Note that this guarantees that&#13;
        /// the return value will be &gt;= 0 if and only if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(sbyte[] a, sbyte key)&#13;
        {&#13;
            return binarySearchGeneric(a, null, null, key, new ByteComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches a range of the specified array of bytes for the specified value&#13;
        /// using the binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be&#13;
        /// searched&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array within&#13;
        /// the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
        /// point is defined as the point at which the key would be inserted into the&#13;
        /// array: the index of the first element in the range greater than the key,&#13;
        /// or toIndex if all elements in the range are less than the specified key.&#13;
        /// Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
        /// if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(sbyte[] a, int fromIndex, int toIndex, sbyte key)&#13;
        {&#13;
            return binarySearchGeneric(a, fromIndex, toIndex, key, new ByteComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches the specified array of chars for the specified value using the&#13;
        /// binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array;&#13;
        /// otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
        /// the point at which the key would be inserted into the array: the index of&#13;
        /// the first element greater than the key, or a.length if all elements in&#13;
        /// the array are less than the specified key. Note that this guarantees that&#13;
        /// the return value will be &gt;= 0 if and only if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(char[] a, char key)&#13;
        {&#13;
            return binarySearchGeneric(a, null, null, key, new CharacterComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches a range of the specified array of chars for the specified value&#13;
        /// using the binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be&#13;
        /// searched&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array within&#13;
        /// the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
        /// point is defined as the point at which the key would be inserted into the&#13;
        /// array: the index of the first element in the range greater than the key,&#13;
        /// or toIndex if all elements in the range are less than the specified key.&#13;
        /// Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
        /// if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(char[] a, int fromIndex, int toIndex, char key)&#13;
        {&#13;
            return binarySearchGeneric(a, fromIndex, toIndex, key, new CharacterComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches the specified array of doubles for the specified value using the&#13;
        /// binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array;&#13;
        /// otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
        /// the point at which the key would be inserted into the array: the index of&#13;
        /// the first element greater than the key, or a.length if all elements in&#13;
        /// the array are less than the specified key. Note that this guarantees that&#13;
        /// the return value will be &gt;= 0 if and only if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(double[] a, double key)&#13;
        {&#13;
            return binarySearchGeneric(a, null, null, key, new DoubleComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches a range of the specified array of doubles for the specified&#13;
        /// value using the binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be&#13;
        /// searched&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array within&#13;
        /// the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
        /// point is defined as the point at which the key would be inserted into the&#13;
        /// array: the index of the first element in the range greater than the key,&#13;
        /// or toIndex if all elements in the range are less than the specified key.&#13;
        /// Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
        /// if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(double[] a, int fromIndex, int toIndex, double key)&#13;
        {&#13;
            return binarySearchGeneric(a, fromIndex, toIndex, key, new DoubleComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches the specified array of floats for the specified value using the&#13;
        /// binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array;&#13;
        /// otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
        /// the point at which the key would be inserted into the array: the index of&#13;
        /// the first element greater than the key, or a.length if all elements in&#13;
        /// the array are less than the specified key. Note that this guarantees that&#13;
        /// the return value will be &gt;= 0 if and only if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(float[] a, float key)&#13;
        {&#13;
            return binarySearchGeneric(a, null, null, key, new FloatComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches a range of the specified array of floats for the specified value&#13;
        /// using the binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be&#13;
        /// searched&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array within&#13;
        /// the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
        /// point is defined as the point at which the key would be inserted into the&#13;
        /// array: the index of the first element in the range greater than the key,&#13;
        /// or toIndex if all elements in the range are less than the specified key.&#13;
        /// Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
        /// if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(float[] a, int fromIndex, int toIndex, float key)&#13;
        {&#13;
            return binarySearchGeneric(a, fromIndex, toIndex, key, new FloatComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches the specified array of ints for the specified value using the&#13;
        /// binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array;&#13;
        /// otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
        /// the point at which the key would be inserted into the array: the index of&#13;
        /// the first element greater than the key, or a.length if all elements in&#13;
        /// the array are less than the specified key. Note that this guarantees that&#13;
        /// the return value will be &gt;= 0 if and only if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(int[] a, int key)&#13;
        {&#13;
            return binarySearchGeneric(a, null, null, key, new IntegerComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches a range of the specified array of ints for the specified value&#13;
        /// using the binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be&#13;
        /// searched&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array within&#13;
        /// the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
        /// point is defined as the point at which the key would be inserted into the&#13;
        /// array: the index of the first element in the range greater than the key,&#13;
        /// or toIndex if all elements in the range are less than the specified key.&#13;
        /// Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
        /// if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(int[] a, int fromIndex, int toIndex, int key)&#13;
        {&#13;
            return binarySearchGeneric(a, fromIndex, toIndex, key, new IntegerComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches the specified array of longs for the specified value using the&#13;
        /// binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array;&#13;
        /// otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
        /// the point at which the key would be inserted into the array: the index of&#13;
        /// the first element greater than the key, or a.length if all elements in&#13;
        /// the array are less than the specified key. Note that this guarantees that&#13;
        /// the return value will be &gt;= 0 if and only if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(long[] a, long key)&#13;
        {&#13;
            return binarySearchGeneric(a, null, null, key, new LongComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches a range of the specified array of longs for the specified value&#13;
        /// using the binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be&#13;
        /// searched&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array within&#13;
        /// the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
        /// point is defined as the point at which the key would be inserted into the&#13;
        /// array: the index of the first element in the range greater than the key,&#13;
        /// or toIndex if all elements in the range are less than the specified key.&#13;
        /// Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
        /// if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(long[] a, int fromIndex, int toIndex, long key)&#13;
        {&#13;
            return binarySearchGeneric(a, fromIndex, toIndex, key, new LongComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches the specified array for the specified object using the binary&#13;
        /// search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array;&#13;
        /// otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
        /// the point at which the key would be inserted into the array: the index of&#13;
        /// the first element greater than the key, or a.length if all elements in&#13;
        /// the array are less than the specified key. Note that this guarantees that&#13;
        /// the return value will be &gt;= 0 if and only if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(Object[] a, Object key)&#13;
        {&#13;
            return binarySearchGeneric(a, null, null, key, new ObjectComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches a range of the specified array for the specified object using&#13;
        /// the binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be&#13;
        /// searched&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array within&#13;
        /// the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
        /// point is defined as the point at which the key would be inserted into the&#13;
        /// array: the index of the first element in the range greater than the key,&#13;
        /// or toIndex if all elements in the range are less than the specified key.&#13;
        /// Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
        /// if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(Object[] a, int fromIndex, int toIndex, Object key)&#13;
        {&#13;
            return binarySearchGeneric(a, fromIndex, toIndex, key, new ObjectComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches the specified array of shorts for the specified value using the&#13;
        /// binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array;&#13;
        /// otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
        /// the point at which the key would be inserted into the array: the index of&#13;
        /// the first element greater than the key, or a.length if all elements in&#13;
        /// the array are less than the specified key. Note that this guarantees that&#13;
        /// the return value will be &gt;= 0 if and only if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(short[] a, short key)&#13;
        {&#13;
            return binarySearchGeneric(a, null, null, key, new ShortComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches a range of the specified array of shorts for the specified value&#13;
        /// using the binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be&#13;
        /// searched&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array within&#13;
        /// the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
        /// point is defined as the point at which the key would be inserted into the&#13;
        /// array: the index of the first element in the range greater than the key,&#13;
        /// or toIndex if all elements in the range are less than the specified key.&#13;
        /// Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
        /// if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch(short[] a, int fromIndex, int toIndex, short key)&#13;
        {&#13;
            return binarySearchGeneric(a, fromIndex, toIndex, key, new ShortComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches the specified array for the specified object using the binary&#13;
        /// search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;param name="c"&gt;the comparator by which the array is ordered. A null value&#13;
        /// indicates that the elements' natural ordering should be used.&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array;&#13;
        /// otherwise, (-(insertion point) - 1). The insertion point is defined as&#13;
        /// the point at which the key would be inserted into the array: the index of&#13;
        /// the first element greater than the key, or a.length if all elements in&#13;
        /// the array are less than the specified key. Note that this guarantees that&#13;
        /// the return value will be &gt;= 0 if and only if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch&lt;T&gt;(T[] a, T key, Comparator c) where T : Object&#13;
        {&#13;
            return binarySearchGeneric(a, null, null, key, c);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Searches a range of the specified array for the specified object using&#13;
        /// the binary search algorithm.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be searched&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be&#13;
        /// searched&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be searched&#13;
        /// &lt;/param&gt;&lt;param name="key"&gt;the value to be searched for&#13;
        /// &lt;/param&gt;&lt;param name="c"&gt;the comparator by which the array is ordered. A null value&#13;
        /// indicates that the elements' natural ordering should be used.&#13;
        /// &lt;/param&gt;&lt;returns&gt;index of the search key, if it is contained in the array within&#13;
        /// the specified range; otherwise, (-(insertion point) - 1). The insertion&#13;
        /// point is defined as the point at which the key would be inserted into the&#13;
        /// array: the index of the first element in the range greater than the key,&#13;
        /// or toIndex if all elements in the range are less than the specified key.&#13;
        /// Note that this guarantees that the return value will be &gt;= 0 if and only&#13;
        /// if the key is found.&#13;
        /// &lt;/returns&gt;&#13;
        public static int binarySearch&lt;T&gt;(T[] a, int fromIndex, int toIndex, T key, Comparator c) where T : Object&#13;
        {&#13;
            return binarySearchGeneric(a, fromIndex, toIndex, key, c);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified array, truncating or padding with false (if&#13;
        /// necessary) so the copy has the specified length.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array to be copied&#13;
        /// &lt;/param&gt;&lt;param name="newLength"&gt;the length of the copy to be returned&#13;
        /// &lt;/param&gt;&lt;returns&gt;a copy of the original array, truncated or padded with false&#13;
        /// elements to obtain the specified length&#13;
        /// &lt;/returns&gt;&#13;
        public static bool[] copyOf(bool[] original, int newLength)&#13;
        {&#13;
            return copyOfRangeGeneric(original, null, newLength);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified array, truncating or padding with zeros (if&#13;
        /// necessary) so the copy has the specified length.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array to be copied&#13;
        /// &lt;/param&gt;&lt;param name="newLength"&gt;the length of the copy to be returned&#13;
        /// &lt;/param&gt;&lt;returns&gt;a copy of the original array, truncated or padded with zeros to&#13;
        /// obtain the specified length&#13;
        /// &lt;/returns&gt;&#13;
        public static sbyte[] copyOf(sbyte[] original, int newLength)&#13;
        {&#13;
            return copyOfRangeGeneric(original, null, newLength);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified array, truncating or padding with null characters&#13;
        /// (if necessary) so the copy has the specified length.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array to be copied&#13;
        /// &lt;/param&gt;&lt;param name="newLength"&gt;the length of the copy to be returned&#13;
        /// &lt;/param&gt;&lt;returns&gt;a copy of the original array, truncated or padded with null&#13;
        /// characters to obtain the specified length&#13;
        /// &lt;/returns&gt;&#13;
        public static char[] copyOf(char[] original, int newLength)&#13;
        {&#13;
            return copyOfRangeGeneric(original, null, newLength);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified array, truncating or padding with zeros (if&#13;
        /// necessary) so the copy has the specified length.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array to be copied&#13;
        /// &lt;/param&gt;&lt;param name="newLength"&gt;the length of the copy to be returned&#13;
        /// &lt;/param&gt;&lt;returns&gt;a copy of the original array, truncated or padded with zeros to&#13;
        /// obtain the specified length&#13;
        /// &lt;/returns&gt;&#13;
        public static double[] copyOf(double[] original, int newLength)&#13;
        {&#13;
            return copyOfRangeGeneric(original, null, newLength);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified array, truncating or padding with zeros (if&#13;
        /// necessary) so the copy has the specified length.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array to be copied&#13;
        /// &lt;/param&gt;&lt;param name="newLength"&gt;the length of the copy to be returned&#13;
        /// &lt;/param&gt;&lt;returns&gt;a copy of the original array, truncated or padded with zeros to&#13;
        /// obtain the specified length&#13;
        /// &lt;/returns&gt;&#13;
        public static float[] copyOf(float[] original, int newLength)&#13;
        {&#13;
            return copyOfRangeGeneric(original, null, newLength);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified array, truncating or padding with zeros (if&#13;
        /// necessary) so the copy has the specified length.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array to be copied&#13;
        /// &lt;/param&gt;&lt;param name="newLength"&gt;the length of the copy to be returned&#13;
        /// &lt;/param&gt;&lt;returns&gt;a copy of the original array, truncated or padded with zeros to&#13;
        /// obtain the specified length&#13;
        /// &lt;/returns&gt;&#13;
        public static int[] copyOf(int[] original, int newLength)&#13;
        {&#13;
            return copyOfRangeGeneric(original, null, newLength);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified array, truncating or padding with zeros (if&#13;
        /// necessary) so the copy has the specified length.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array to be copied&#13;
        /// &lt;/param&gt;&lt;param name="newLength"&gt;the length of the copy to be returned&#13;
        /// &lt;/param&gt;&lt;returns&gt;a copy of the original array, truncated or padded with zeros to&#13;
        /// obtain the specified length&#13;
        /// &lt;/returns&gt;&#13;
        public static long[] copyOf(long[] original, int newLength)&#13;
        {&#13;
            return copyOfRangeGeneric(original, null, newLength);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified array, truncating or padding with zeros (if&#13;
        /// necessary) so the copy has the specified length.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array to be copied&#13;
        /// &lt;/param&gt;&lt;param name="newLength"&gt;the length of the copy to be returned&#13;
        /// &lt;/param&gt;&lt;returns&gt;a copy of the original array, truncated or padded with zeros to&#13;
        /// obtain the specified length&#13;
        /// &lt;/returns&gt;&#13;
        public static short[] copyOf(short[] original, int newLength)&#13;
        {&#13;
            return copyOfRangeGeneric(original, null, newLength);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified array, truncating or padding with nulls (if&#13;
        /// necessary) so the copy has the specified length.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array to be copied&#13;
        /// &lt;/param&gt;&lt;param name="newLength"&gt;the length of the copy to be returned&#13;
        /// &lt;/param&gt;&lt;returns&gt;a copy of the original array, truncated or padded with nulls to&#13;
        /// obtain the specified length&#13;
        /// &lt;/returns&gt;&#13;
        public static T[] copyOf&lt;T&gt;(T[] original, int newLength)&#13;
        {&#13;
            return copyOfRangeGeneric(original, null, newLength);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified range of the specified array into a new array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array from which a range is to be copied&#13;
        /// &lt;/param&gt;&lt;param name="from"&gt;the initial index of the range to be copied, inclusive&#13;
        /// &lt;/param&gt;&lt;param name="to"&gt;the final index of the range to be copied, exclusive. (This&#13;
        /// index may lie outside the array.)&#13;
        /// &lt;/param&gt;&lt;returns&gt;a new array containing the specified range from the original&#13;
        /// array, truncated or padded with false elements to obtain the required&#13;
        /// length&#13;
        /// &lt;/returns&gt;&#13;
        public static bool[] copyOfRange(bool[] original, int from, int to)&#13;
        {&#13;
            return copyOfRangeGeneric(original, from, to);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified range of the specified array into a new array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array from which a range is to be copied&#13;
        /// &lt;/param&gt;&lt;param name="from"&gt;the initial index of the range to be copied, inclusive&#13;
        /// &lt;/param&gt;&lt;param name="to"&gt;the final index of the range to be copied, exclusive. (This&#13;
        /// index may lie outside the array.)&#13;
        /// &lt;/param&gt;&lt;returns&gt;a new array containing the specified range from the original&#13;
        /// array, truncated or padded with zeros to obtain the required length&#13;
        /// &lt;/returns&gt;&#13;
        public static sbyte[] copyOfRange(sbyte[] original, int from, int to)&#13;
        {&#13;
            return copyOfRangeGeneric(original, from, to);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified range of the specified array into a new array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array from which a range is to be copied&#13;
        /// &lt;/param&gt;&lt;param name="from"&gt;the initial index of the range to be copied, inclusive&#13;
        /// &lt;/param&gt;&lt;param name="to"&gt;the final index of the range to be copied, exclusive. (This&#13;
        /// index may lie outside the array.)&#13;
        /// &lt;/param&gt;&lt;returns&gt;a new array containing the specified range from the original&#13;
        /// array, truncated or padded with null characters to obtain the required&#13;
        /// length&#13;
        /// &lt;/returns&gt;&#13;
        public static char[] copyOfRange(char[] original, int from, int to)&#13;
        {&#13;
            return copyOfRangeGeneric(original, from, to);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified range of the specified array into a new array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array from which a range is to be copied&#13;
        /// &lt;/param&gt;&lt;param name="from"&gt;the initial index of the range to be copied, inclusive&#13;
        /// &lt;/param&gt;&lt;param name="to"&gt;the final index of the range to be copied, exclusive. (This&#13;
        /// index may lie outside the array.)&#13;
        /// &lt;/param&gt;&lt;returns&gt;a new array containing the specified range from the original&#13;
        /// array, truncated or padded with zeros to obtain the required length&#13;
        /// &lt;/returns&gt;&#13;
        public static double[] copyOfRange(double[] original, int from, int to)&#13;
        {&#13;
            return copyOfRangeGeneric(original, from, to);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified range of the specified array into a new array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array from which a range is to be copied&#13;
        /// &lt;/param&gt;&lt;param name="from"&gt;the initial index of the range to be copied, inclusive&#13;
        /// &lt;/param&gt;&lt;param name="to"&gt;the final index of the range to be copied, exclusive. (This&#13;
        /// index may lie outside the array.)&#13;
        /// &lt;/param&gt;&lt;returns&gt;a new array containing the specified range from the original&#13;
        /// array, truncated or padded with zeros to obtain the required length&#13;
        /// &lt;/returns&gt;&#13;
        public static float[] copyOfRange(float[] original, int from, int to)&#13;
        {&#13;
            return copyOfRangeGeneric(original, from, to);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified range of the specified array into a new array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array from which a range is to be copied&#13;
        /// &lt;/param&gt;&lt;param name="from"&gt;the initial index of the range to be copied, inclusive&#13;
        /// &lt;/param&gt;&lt;param name="to"&gt;the final index of the range to be copied, exclusive. (This&#13;
        /// index may lie outside the array.)&#13;
        /// &lt;/param&gt;&lt;returns&gt;a new array containing the specified range from the original&#13;
        /// array, truncated or padded with zeros to obtain the required length&#13;
        /// &lt;/returns&gt;&#13;
        public static int[] copyOfRange(int[] original, int from, int to)&#13;
        {&#13;
            return copyOfRangeGeneric(original, from, to);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified range of the specified array into a new array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array from which a range is to be copied&#13;
        /// &lt;/param&gt;&lt;param name="from"&gt;the initial index of the range to be copied, inclusive&#13;
        /// &lt;/param&gt;&lt;param name="to"&gt;the final index of the range to be copied, exclusive. (This&#13;
        /// index may lie outside the array.)&#13;
        /// &lt;/param&gt;&lt;returns&gt;a new array containing the specified range from the original&#13;
        /// array, truncated or padded with zeros to obtain the required length&#13;
        /// &lt;/returns&gt;&#13;
        public static long[] copyOfRange(long[] original, int from, int to)&#13;
        {&#13;
            return copyOfRangeGeneric(original, from, to);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified range of the specified array into a new array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array from which a range is to be copied&#13;
        /// &lt;/param&gt;&lt;param name="from"&gt;the initial index of the range to be copied, inclusive&#13;
        /// &lt;/param&gt;&lt;param name="to"&gt;the final index of the range to be copied, exclusive. (This&#13;
        /// index may lie outside the array.)&#13;
        /// &lt;/param&gt;&lt;returns&gt;a new array containing the specified range from the original&#13;
        /// array, truncated or padded with zeros to obtain the required length&#13;
        /// &lt;/returns&gt;&#13;
        public static short[] copyOfRange(short[] original, int from, int to)&#13;
        {&#13;
            return copyOfRangeGeneric(original, from, to);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Copies the specified range of the specified array into a new array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="original"&gt;the array from which a range is to be copied&#13;
        /// &lt;/param&gt;&lt;param name="from"&gt;the initial index of the range to be copied, inclusive&#13;
        /// &lt;/param&gt;&lt;param name="to"&gt;the final index of the range to be copied, exclusive. (This&#13;
        /// index may lie outside the array.)&#13;
        /// &lt;/param&gt;&lt;returns&gt;a new array containing the specified range from the original&#13;
        /// array, truncated or padded with nulls to obtain the required length&#13;
        /// &lt;/returns&gt;&#13;
        public static T[] copyOfRange&lt;T&gt;(T[] original, int from, int to)&#13;
        {&#13;
            return copyOfRangeGeneric(original, from, to);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if the two specified arrays of booleans are equal to one&#13;
        /// another.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;one array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;param name="a2"&gt;the other array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the two arrays are equal&#13;
        /// &lt;/returns&gt;&#13;
        public static bool equals(bool[] a, bool[] a2)&#13;
        {&#13;
            return equalsGeneric(a, a2, (x, y) =&gt;&#13;
            {&#13;
                return new Boolean(x).equals(new Boolean(y));&#13;
            });&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if the two specified arrays of bytes are equal to one&#13;
        /// another.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;one array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;param name="a2"&gt;the other array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the two arrays are equal&#13;
        /// &lt;/returns&gt;&#13;
        public static bool equals(sbyte[] a, sbyte[] a2)&#13;
        {&#13;
            return equalsGeneric(a, a2, (x, y) =&gt;&#13;
            {&#13;
                return new Byte(x).equals(new Byte(y));&#13;
            });&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if the two specified arrays of chars are equal to one&#13;
        /// another.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;one array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;param name="a2"&gt;the other array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the two arrays are equal&#13;
        /// &lt;/returns&gt;&#13;
        public static bool equals(char[] a, char[] a2)&#13;
        {&#13;
            return equalsGeneric(a, a2, (x, y) =&gt;&#13;
            {&#13;
                return new Character(x).equals(new Character(y));&#13;
            });&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if the two specified arrays of doubles are equal to one&#13;
        /// another.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;one array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;param name="a2"&gt;the other array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the two arrays are equal&#13;
        /// &lt;/returns&gt;&#13;
        public static bool equals(double[] a, double[] a2)&#13;
        {&#13;
            return equalsGeneric(a, a2, (x, y) =&gt;&#13;
            {&#13;
                return new Double(x).equals(new Double(y));&#13;
            });&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if the two specified arrays of floats are equal to one&#13;
        /// another.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;one array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;param name="a2"&gt;the other array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the two arrays are equal&#13;
        /// &lt;/returns&gt;&#13;
        public static bool equals(float[] a, float[] a2)&#13;
        {&#13;
            return equalsGeneric(a, a2, (x, y) =&gt;&#13;
            {&#13;
                return new Float(x).equals(new Float(y));&#13;
            });&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if the two specified arrays of ints are equal to one&#13;
        /// another.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;one array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;param name="a2"&gt;the other array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the two arrays are equal&#13;
        /// &lt;/returns&gt;&#13;
        public static bool equals(int[] a, int[] a2)&#13;
        {&#13;
            return equalsGeneric(a, a2, (x, y) =&gt;&#13;
            {&#13;
                return new Integer(x).equals(new Integer(y));&#13;
            });&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if the two specified arrays of longs are equal to one&#13;
        /// another.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;one array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;param name="a2"&gt;the other array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the two arrays are equal&#13;
        /// &lt;/returns&gt;&#13;
        public static bool equals(long[] a, long[] a2)&#13;
        {&#13;
            return equalsGeneric(a, a2, (x, y) =&gt;&#13;
            {&#13;
                return new Long(x).equals(new Long(y));&#13;
            });&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if the two specified arrays of Objects are equal to one&#13;
        /// another.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;one array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;param name="a2"&gt;the other array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the two arrays are equal&#13;
        /// &lt;/returns&gt;&#13;
        public static bool equals(Object[] a, Object[] a2)&#13;
        {&#13;
            return equalsGeneric(a, a2, (o1, o2) =&gt;&#13;
            {&#13;
                return (o1 == null ? o2 == null : o1.Equals(o2));&#13;
            });&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns true if the two specified arrays of shorts are equal to one&#13;
        /// another.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;one array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;param name="a2"&gt;the other array to be tested for equality&#13;
        /// &lt;/param&gt;&lt;returns&gt;true if the two arrays are equal&#13;
        /// &lt;/returns&gt;&#13;
        public static bool equals(short[] a, short[] a2)&#13;
        {&#13;
            return equalsGeneric(a, a2, (x, y) =&gt;&#13;
            {&#13;
                return new Short(x).equals(new Short(y));&#13;
            });&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified boolean value to each element of the specified&#13;
        /// array of booleans.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(bool[] a, bool val)&#13;
        {&#13;
            fillGeneric(a, null, null, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified boolean value to each element of the specified&#13;
        /// range of the specified array of booleans.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(bool[] a, int fromIndex, int toIndex, bool val)&#13;
        {&#13;
            fillGeneric(a, fromIndex, toIndex, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified byte value to each element of the specified array&#13;
        /// of bytes.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(sbyte[] a, sbyte val)&#13;
        {&#13;
            fillGeneric(a, null, null, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified byte value to each element of the specified range&#13;
        /// of the specified array of bytes.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(sbyte[] a, int fromIndex, int toIndex, sbyte val)&#13;
        {&#13;
            fillGeneric(a, fromIndex, toIndex, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified char value to each element of the specified array&#13;
        /// of chars.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(char[] a, char val)&#13;
        {&#13;
            fillGeneric(a, null, null, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified char value to each element of the specified range&#13;
        /// of the specified array of chars.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(char[] a, int fromIndex, int toIndex, char val)&#13;
        {&#13;
            fillGeneric(a, fromIndex, toIndex, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified double value to each element of the specified array&#13;
        /// of doubles.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(double[] a, double val)&#13;
        {&#13;
            fillGeneric(a, null, null, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified double value to each element of the specified range&#13;
        /// of the specified array of doubles.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(double[] a, int fromIndex, int toIndex, double val)&#13;
        {&#13;
            fillGeneric(a, fromIndex, toIndex, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified float value to each element of the specified array&#13;
        /// of floats.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(float[] a, float val)&#13;
        {&#13;
            fillGeneric(a, null, null, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified float value to each element of the specified range&#13;
        /// of the specified array of floats.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(float[] a, int fromIndex, int toIndex, float val)&#13;
        {&#13;
            fillGeneric(a, fromIndex, toIndex, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified int value to each element of the specified array of&#13;
        /// ints.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(int[] a, int val)&#13;
        {&#13;
            fillGeneric(a, null, null, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified int value to each element of the specified range of&#13;
        /// the specified array of ints.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(int[] a, int fromIndex, int toIndex, int val)&#13;
        {&#13;
            fillGeneric(a, fromIndex, toIndex, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified long value to each element of the specified array&#13;
        /// of longs.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(long[] a, long val)&#13;
        {&#13;
            fillGeneric(a, null, null, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified long value to each element of the specified range&#13;
        /// of the specified array of longs.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(long[] a, int fromIndex, int toIndex, long val)&#13;
        {&#13;
            fillGeneric(a, fromIndex, toIndex, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified Object reference to each element of the specified&#13;
        /// array of Objects.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(Object[] a, Object val)&#13;
        {&#13;
            fillGeneric(a, null, null, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified Object reference to each element of the specified&#13;
        /// range of the specified array of Objects.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(Object[] a, int fromIndex, int toIndex, Object val)&#13;
        {&#13;
            fillGeneric(a, fromIndex, toIndex, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified short value to each element of the specified array&#13;
        /// of shorts.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(short[] a, short val)&#13;
        {&#13;
            fillGeneric(a, null, null, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Assigns the specified short value to each element of the specified range&#13;
        /// of the specified array of shorts.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be filled&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be filled&#13;
        /// with the specified value&#13;
        /// &lt;/param&gt;&lt;param name="val"&gt;the value to be stored in all elements of the array&#13;
        /// &lt;/param&gt;&#13;
        public static void fill(short[] a, int fromIndex, int toIndex, short val)&#13;
        {&#13;
            fillGeneric(a, fromIndex, toIndex, val);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified array into ascending numerical order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(sbyte[] a)&#13;
        {&#13;
            sortGeneric(a, null, null, new ByteComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified range of the array into ascending order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(sbyte[] a, int fromIndex, int toIndex)&#13;
        {&#13;
            sortGeneric(a, fromIndex, toIndex, new ByteComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified array into ascending numerical order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(char[] a)&#13;
        {&#13;
            sortGeneric(a, null, null, new CharacterComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified range of the array into ascending order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(char[] a, int fromIndex, int toIndex)&#13;
        {&#13;
            sortGeneric(a, fromIndex, toIndex, new CharacterComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified array into ascending numerical order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(double[] a)&#13;
        {&#13;
            sortGeneric(a, null, null, new DoubleComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified range of the array into ascending order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(double[] a, int fromIndex, int toIndex)&#13;
        {&#13;
            sortGeneric(a, fromIndex, toIndex, new DoubleComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified array into ascending numerical order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(float[] a)&#13;
        {&#13;
            sortGeneric(a, null, null, new FloatComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified range of the array into ascending order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(float[] a, int fromIndex, int toIndex)&#13;
        {&#13;
            sortGeneric(a, fromIndex, toIndex, new FloatComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified array into ascending numerical order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(int[] a)&#13;
        {&#13;
            sortGeneric(a, null, null, new IntegerComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified range of the array into ascending order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(int[] a, int fromIndex, int toIndex)&#13;
        {&#13;
            sortGeneric(a, fromIndex, toIndex, new IntegerComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified array into ascending numerical order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(long[] a)&#13;
        {&#13;
            sortGeneric(a, null, null, new LongComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified range of the array into ascending order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(long[] a, int fromIndex, int toIndex)&#13;
        {&#13;
            sortGeneric(a, fromIndex, toIndex, new LongComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified array of objects into ascending order, according to&#13;
        /// the natural ordering of its elements.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(Object[] a)&#13;
        {&#13;
            sortGeneric(a, null, null, new ObjectComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified range of the specified array of objects into&#13;
        /// ascending order, according to the natural ordering of its elements.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(Object[] a, int fromIndex, int toIndex)&#13;
        {&#13;
            sortGeneric(a, fromIndex, toIndex, new ObjectComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified array into ascending numerical order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(short[] a)&#13;
        {&#13;
            sortGeneric(a, null, null, new ShortComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified range of the array into ascending order.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be sorted&#13;
        /// &lt;/param&gt;&#13;
        public static void sort(short[] a, int fromIndex, int toIndex)&#13;
        {&#13;
            sortGeneric(a, fromIndex, toIndex, new ShortComparer());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified array of objects according to the order induced by&#13;
        /// the specified comparator.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="c"&gt;the comparator to determine the order of the array. A null value&#13;
        /// indicates that the elements' natural ordering should be used.&#13;
        /// &lt;/param&gt;&#13;
        public static void sort&lt;T&gt;(T[] a, Comparator c) where T : Object&#13;
        {&#13;
            sortGeneric(a, null, null, c);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Sorts the specified range of the specified array of objects according to&#13;
        /// the order induced by the specified comparator.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index of the first element (inclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="toIndex"&gt;the index of the last element (exclusive) to be sorted&#13;
        /// &lt;/param&gt;&lt;param name="c"&gt;the comparator to determine the order of the array. A null value&#13;
        /// indicates that the elements' natural ordering should be used.&#13;
        /// &lt;/param&gt;&#13;
        public static void sort&lt;T&gt;(T[] a, int fromIndex, int toIndex, Comparator c) where T : Object&#13;
        {&#13;
            sortGeneric(a, fromIndex, toIndex, c);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the contents of the specified array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array whose string representation to return&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string representation of a&#13;
        /// &lt;/returns&gt;&#13;
        public static String toString(bool[] a)&#13;
        {&#13;
            return toStringGeneric(a).toLowerCase();&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the contents of the specified array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array whose string representation to return&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string representation of a&#13;
        /// &lt;/returns&gt;&#13;
        public static String toString(sbyte[] a)&#13;
        {&#13;
            return toStringGeneric(a);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the contents of the specified array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array whose string representation to return&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string representation of a&#13;
        /// &lt;/returns&gt;&#13;
        public static String toString(char[] a)&#13;
        {&#13;
            return toStringGeneric(a);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the contents of the specified array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array whose string representation to return&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string representation of a&#13;
        /// &lt;/returns&gt;&#13;
        public static String toString(double[] a)&#13;
        {&#13;
            return toStringGeneric(a);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the contents of the specified array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array whose string representation to return&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string representation of a&#13;
        /// &lt;/returns&gt;&#13;
        public static String toString(float[] a)&#13;
        {&#13;
            return toStringGeneric(a);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the contents of the specified array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array whose string representation to return&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string representation of a&#13;
        /// &lt;/returns&gt;&#13;
        public static String toString(int[] a)&#13;
        {&#13;
            return toStringGeneric(a);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the contents of the specified array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array whose string representation to return&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string representation of a&#13;
        /// &lt;/returns&gt;&#13;
        public static String toString(long[] a)&#13;
        {&#13;
            return toStringGeneric(a);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the contents of the specified array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array whose string representation to return&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string representation of a&#13;
        /// &lt;/returns&gt;&#13;
        public static String toString(Object[] a)&#13;
        {&#13;
            return toStringGeneric(a);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns a string representation of the contents of the specified array.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="a"&gt;the array whose string representation to return&#13;
        /// &lt;/param&gt;&lt;returns&gt;a string representation of a&#13;
        /// &lt;/returns&gt;&#13;
        public static String toString(short[] a)&#13;
        {&#13;
            return toStringGeneric(a);&#13;
        }&#13;
&#13;
    }&#13;
&#13;
}</code>
<code lang="Free Pascal">unit ArraysUnit;

{$mode objfpc}{$H+}

interface

uses
  SystemUnit, StringUnit;

type
  PBoolean = ^boolean;
  PShortInt = ^shortInt;
  PAnsiChar = ^ansiChar;
  PDouble = ^double;
  PSingle = ^single;
  PLongInt = ^longInt;
  PInt64 = ^int64;
  PSmallInt = ^smallInt;

  BooleanArray = array of boolean;
  ShortIntArray = array of shortInt;
  AnsiCharArray = array of ansiChar;
  DoubleArray = array of double;
  SingleArray = array of single;
  LongIntArray = array of longInt;
  Int64Array = array of int64;
  SmallIntArray = array of smallInt;
  ObjectArray = array of Object_;

  EqualsFunction = function(a, b: pointer): boolean;
  ToStringFunction = function(a: pointer): String_;

  (**
   * This class contains various methods for manipulating arrays (such as sorting and searching).
   *
   * @author Petr Kozler (A13B0359P)
   *)
  Arrays = class
    private
      class function binarySearchPointer(a: pointer; fromIndex, toIndex, size: longInt; key: pointer; c: CompareFunction) : longInt;
      class function binarySearchObject(var a: array of Object_; fromIndex, toIndex: longInt; key: Object_; c: Comparator) : longInt;
      class function copyOfRangePointer(original, copyArray: pointer; length, size, from, to_: longInt; defaultValue: pointer) : pointer;
      class function copyOfRangeObject(var original: array of Object_; from, to_: longInt) : ObjectArray;
      class function equalsPointer(a: pointer; length: longInt; a2: pointer; length2, size: longInt; e: EqualsFunction) : boolean;
      class function equalsObject(var a: array of Object_; a2: array of Object_) : boolean;
      class procedure fillPointer(a: pointer; fromIndex, toIndex, size: longInt; val: pointer);
      class procedure fillObject(var a: array of Object_; fromIndex, toIndex: longInt; val: Object_);
      class procedure sortPointer(a: pointer; fromIndex, toIndex, size: longInt; c: CompareFunction);
      class procedure sortObject(var a: array of Object_; fromIndex, toIndex: longInt; c: Comparator);
      class function toStringPointer(a: pointer; length, size: longInt; ts: ToStringFunction) : String_;
      class function toStringObject(var a: array of Object_) : String_;
    public
      class function binarySearch(var a: array of shortInt; key: shortInt) : longInt;
      class function binarySearch(var a: array of shortInt; fromIndex: longInt; toIndex: longInt; key: shortInt) : longInt;
      class function binarySearch(var a: array of ansiChar; key: ansiChar) : longInt;
      class function binarySearch(var a: array of ansiChar; fromIndex: longInt; toIndex: longInt; key: ansiChar) : longInt;
      class function binarySearch(var a: array of double; key: double) : longInt;
      class function binarySearch(var a: array of double; fromIndex: longInt; toIndex: longInt; key: double) : longInt;
      class function binarySearch(var a: array of single; key: single) : longInt;
      class function binarySearch(var a: array of single; fromIndex: longInt; toIndex: longInt; key: single) : longInt;
      class function binarySearch(var a: array of longInt; key: longInt) : longInt;
      class function binarySearch(var a: array of longInt; fromIndex: longInt; toIndex: longInt; key: longInt) : longInt;
      class function binarySearch(var a: array of int64; key: int64) : longInt;
      class function binarySearch(var a: array of int64; fromIndex: longInt; toIndex: longInt; key: int64) : longInt;
      class function binarySearch(var a: array of Object_; key: Object_) : longInt;
      class function binarySearch(var a: array of Object_; fromIndex: longInt; toIndex: longInt; key: Object_) : longInt;
      class function binarySearch(var a: array of smallInt; key: smallInt) : longInt;
      class function binarySearch(var a: array of smallInt; fromIndex: longInt; toIndex: longInt; key: smallInt) : longInt;
      class function binarySearch(var a: array of Object_; key: Object_; c: Comparator) : longInt;
      class function binarySearch(var a: array of Object_; fromIndex: longInt; toIndex: longInt; key: Object_; c: Comparator) : longInt;
      class function copyOf(var original: array of boolean; newLength: longInt) : BooleanArray;
      class function copyOf(var original: array of shortInt; newLength: longInt) : ShortIntArray;
      class function copyOf(var original: array of ansiChar; newLength: longInt) : AnsiCharArray;
      class function copyOf(var original: array of double; newLength: longInt) : DoubleArray;
      class function copyOf(var original: array of single; newLength: longInt) : SingleArray;
      class function copyOf(var original: array of longInt; newLength: longInt) : LongIntArray;
      class function copyOf(var original: array of int64; newLength: longInt) : Int64Array;
      class function copyOf(var original: array of smallInt; newLength: longInt) : SmallIntArray;
      class function copyOf(var original: array of Object_; newLength: longInt) : ObjectArray;
      class function copyOfRange(var original: array of boolean; from: longInt; to_: longInt) : BooleanArray;
      class function copyOfRange(var original: array of shortInt; from: longInt; to_: longInt) : ShortIntArray;
      class function copyOfRange(var original: array of ansiChar; from: longInt; to_: longInt) : AnsiCharArray;
      class function copyOfRange(var original: array of double; from: longInt; to_: longInt) : DoubleArray;
      class function copyOfRange(var original: array of single; from: longInt; to_: longInt) : SingleArray;
      class function copyOfRange(var original: array of longInt; from: longInt; to_: longInt) : LongIntArray;
      class function copyOfRange(var original: array of int64; from: longInt; to_: longInt) : Int64Array;
      class function copyOfRange(var original: array of smallInt; from: longInt; to_: longInt) : SmallIntArray;
      class function copyOfRange(var original: array of Object_; from: longInt; to_: longInt) : ObjectArray;
      class function equals(a: array of boolean; a2: array of boolean) : boolean;
      class function equals(a: array of shortInt; a2: array of shortInt) : boolean;
      class function equals(a: array of ansiChar; a2: array of ansiChar) : boolean;
      class function equals(a: array of double; a2: array of double) : boolean;
      class function equals(a: array of single; a2: array of single) : boolean;
      class function equals(a: array of longInt; a2: array of longInt) : boolean;
      class function equals(a: array of int64; a2: array of int64) : boolean;
      class function equals(a: array of Object_; a2: array of Object_) : boolean;
      class function equals(a: array of smallInt; a2: array of smallInt) : boolean;
      class procedure fill(var a: array of boolean; val: boolean);
      class procedure fill(var a: array of boolean; fromIndex: longInt; toIndex: longInt; val: boolean);
      class procedure fill(var a: array of shortInt; val: shortInt);
      class procedure fill(var a: array of shortInt; fromIndex: longInt; toIndex: longInt; val: shortInt);
      class procedure fill(var a: array of ansiChar; val: ansiChar);
      class procedure fill(var a: array of ansiChar; fromIndex: longInt; toIndex: longInt; val: ansiChar);
      class procedure fill(var a: array of double; val: double);
      class procedure fill(var a: array of double; fromIndex: longInt; toIndex: longInt; val: double);
      class procedure fill(var a: array of single; val: single);
      class procedure fill(var a: array of single; fromIndex: longInt; toIndex: longInt; val: single);
      class procedure fill(var a: array of longInt; val: longInt);
      class procedure fill(var a: array of longInt; fromIndex: longInt; toIndex: longInt; val: longInt);
      class procedure fill(var a: array of int64; val: int64);
      class procedure fill(var a: array of int64; fromIndex: longInt; toIndex: longInt; val: int64);
      class procedure fill(var a: array of Object_; val: Object_);
      class procedure fill(var a: array of Object_; fromIndex: longInt; toIndex: longInt; val: Object_);
      class procedure fill(var a: array of smallInt; val: smallInt);
      class procedure fill(var a: array of smallInt; fromIndex: longInt; toIndex: longInt; val: smallInt);
      class procedure sort(var a: array of shortInt);
      class procedure sort(var a: array of shortInt; fromIndex: longInt; toIndex: longInt);
      class procedure sort(var a: array of ansiChar);
      class procedure sort(var a: array of ansiChar; fromIndex: longInt; toIndex: longInt);
      class procedure sort(var a: array of double);
      class procedure sort(var a: array of double; fromIndex: longInt; toIndex: longInt);
      class procedure sort(var a: array of single);
      class procedure sort(var a: array of single; fromIndex: longInt; toIndex: longInt);
      class procedure sort(var a: array of longInt);
      class procedure sort(var a: array of longInt; fromIndex: longInt; toIndex: longInt);
      class procedure sort(var a: array of int64);
      class procedure sort(var a: array of int64; fromIndex: longInt; toIndex: longInt);
      class procedure sort(var a: array of Object_);
      class procedure sort(var a: array of Object_; fromIndex: longInt; toIndex: longInt);
      class procedure sort(var a: array of smallInt);
      class procedure sort(var a: array of smallInt; fromIndex: longInt; toIndex: longInt);
      class procedure sort(var a: array of Object_; c: Comparator);
      class procedure sort(var a: array of Object_; fromIndex: longInt; toIndex: longInt; c: Comparator);
      class function toString(var a: array of boolean) : String_;
      class function toString(var a: array of shortInt) : String_;
      class function toString(var a: array of ansiChar) : String_;
      class function toString(var a: array of double) : String_;
      class function toString(var a: array of single) : String_;
      class function toString(var a: array of longInt) : String_;
      class function toString(var a: array of int64) : String_;
      class function toString(var a: array of Object_) : String_;
      class function toString(var a: array of smallInt) : String_;
  end;

implementation

uses
  BooleanUnit, ByteUnit, DoubleUnit, FloatUnit, CharacterUnit, IntegerUnit, LongUnit, ShortUnit, StringBuilderUnit, SysUtils, Classes;

var
  defaultBoolean: boolean = false;
  defaultByte: shortInt = 0;
  defaultShort: smallInt = 0;
  defaultInt: longInt = 0;
  defaultLong: int64 = 0;
  defaultFloat: single = 0;
  defaultDouble: double = 0;
  defaultChar: ansiChar = #0;

function _compareB(a, b: pointer) : longInt;
begin
  _compareB := Byte_.compare(PShortInt(a)^, PShortInt(b)^);
end;

function _compareC(a, b: pointer) : longInt;
begin
  _compareC := Character.compare(PAnsiChar(a)^, PAnsiChar(b)^);
end;

function _compareD(a, b: pointer) : longInt;
begin
  _compareD := Double_.compare(PDouble(a)^, PDouble(b)^);
end;

function _compareF(a, b: pointer) : longInt;
begin
  _compareF := Float.compare(PSingle(a)^, PSingle(b)^);
end;

function _compareI(a, b: pointer) : longInt;
begin
  _compareI := Integer_.compare(PLongInt(a)^, PLongInt(b)^);
end;

function _compareL(a, b: pointer) : longInt;
begin
  _compareL := Long.compare(PInt64(a)^, PInt64(b)^);
end;

function _compareS(a, b: pointer) : longInt;
begin
  _compareS := Short.compare(PSmallInt(a)^, PSmallInt(b)^);
end;

function _equalsBool(a, b: pointer) : boolean;
var
  x, y: Boolean_;
begin
  x := Boolean_.create(PBoolean(a)^);
  y := Boolean_.create(PBoolean(b)^);
  _equalsBool := x.equals(y);
  freeAndNil(x);
  freeAndNil(y);
end;

function _equalsB(a, b: pointer) : boolean;
var
  x, y: Byte_;
begin
  x := Byte_.create(PShortInt(a)^);
  y := Byte_.create(PShortInt(b)^);
  _equalsB := x.equals(y);
  freeAndNil(x);
  freeAndNil(y);
end;

function _equalsC(a, b: pointer) : boolean;
var
  x, y: Character;
begin
  x := Character.create(PAnsiChar(a)^);
  y := Character.create(PAnsiChar(b)^);
  _equalsC := x.equals(y);
  freeAndNil(x);
  freeAndNil(y);
end;

function _equalsD(a, b: pointer) : boolean;
var
  x, y: Double_;
begin
  x := Double_.create(PDouble(a)^);
  y := Double_.create(PDouble(b)^);
  _equalsD := x.equals(y);
  freeAndNil(x);
  freeAndNil(y);
end;

function _equalsF(a, b: pointer) : boolean;
var
  x, y: Float;
begin
  x := Float.create(PSingle(a)^);
  y := Float.create(PSingle(b)^);
  _equalsF := x.equals(y);
  freeAndNil(x);
  freeAndNil(y);
end;

function _equalsI(a, b: pointer) : boolean;
var
  x, y: Integer_;
begin
  x := Integer_.create(PLongInt(a)^);
  y := Integer_.create(PLongInt(b)^);
  _equalsI := x.equals(y);
  freeAndNil(x);
  freeAndNil(y);
end;

function _equalsL(a, b: pointer) : boolean;
var
  x, y: Long;
begin
  x := Long.create(PInt64(a)^);
  y := Long.create(PInt64(b)^);
  _equalsL := x.equals(y);
  freeAndNil(x);
  freeAndNil(y);
end;

function _equalsS(a, b: pointer) : boolean;
var
  x, y: Short;
begin
  x := Short.create(PSmallInt(a)^);
  y := Short.create(PSmallInt(b)^);
  _equalsS := x.equals(y);
  freeAndNil(x);
  freeAndNil(y);
end;

function _equalsObj(o1, o2: Object_) : boolean;
begin
  if o1 = nil then begin
    _equalsObj := (o2 = nil);
  end
  else begin
    _equalsObj := o1.Equals(o2);
  end;
end;

function _toStringBool(a: pointer) : String_;
begin
  _toStringBool := Boolean_.toString_(PBoolean(a)^);
end;

function _toStringB(a: pointer) : String_;
begin
  _toStringB := Byte_.toString_(PShortInt(a)^);
end;

function _toStringC(a: pointer) : String_;
begin
  _toStringC := Character.toString_(PAnsiChar(a)^);
end;

function _toStringD(a: pointer) : String_;
begin
  _toStringD := Double_.toString_(PDouble(a)^);
end;

function _toStringF(a: pointer) : String_;
begin
  _toStringF := Float.toString_(PSingle(a)^);
end;

function _toStringI(a: pointer) : String_;
begin
  _toStringI := Integer_.toString_(PLongInt(a)^);
end;

function _toStringL(a: pointer) : String_;
begin
  _toStringL := Long.toString_(PInt64(a)^);
end;

function _toStringS(a: pointer) : String_;
begin
  _toStringS := Short.toString_(PSmallInt(a)^);
end;

class function Arrays.binarySearchPointer(a: pointer; fromIndex, toIndex, size: longInt; key: pointer; c: CompareFunction) : longInt;
var
  lower, upper, middle : longInt;
  middleValue : pointer;
begin
  lower := fromIndex;
  upper := toIndex - 1;

  while lower &lt;= upper do begin
    middle := lower + ((upper - lower) div 2);
    middleValue := a + middle * size;

    if c(middleValue, key) &lt; 0 then begin
      lower := middle + 1;
    end
    else if c(middleValue, key) &gt; 0 then begin
      upper := middle - 1;
    end
    else begin
      exit(middle);
    end;
  end;

  binarySearchPointer := -(lower + 1);
end;

class function Arrays.binarySearchObject(var a: array of Object_; fromIndex, toIndex: longInt; key: Object_; c: Comparator) : longInt;
var
  lower, upper, middle : longInt;
  middleValue : Object_;
begin
  lower := fromIndex;
  upper := toIndex - 1;

  while lower &lt;= upper do begin
    middle := lower + ((upper - lower) div 2);
    middleValue := a[middle];

    if c.compare(middleValue, key) &lt; 0 then begin
      lower := middle + 1;
    end
    else if c.compare(middleValue, key) &gt; 0 then begin
      upper := middle - 1;
    end
    else begin
      exit(middle);
    end;
  end;

  binarySearchObject := -(lower + 1);
end;

class function Arrays.copyOfRangePointer(original, copyArray: pointer; length, size, from, to_: longInt; defaultValue: pointer) : pointer;
var
  src, dest: pointer;
  i: longInt;
begin
  if to_ &gt; length then begin
    for i := from to length - 1 do begin
      src := original + i * size;
      dest := copyArray + (i - from) * size;
      move(src^, dest^, size);
    end;

    for i := length to to_ - 1 do begin
      src := defaultValue;
      dest := copyArray + (i - from) * size;
      move(src^, dest^, size);
    end;
  end
  else begin
    for i := from to to_ - 1 do begin
      src := original + i * size;
      dest := copyArray + (i - from) * size;
      move(src^, dest^, size);
    end;
  end;

  copyOfRangePointer := copyArray;
end;

class function Arrays.copyOfRangeObject(var original: array of Object_; from, to_: longInt) : ObjectArray;
var
  a: array of Object_;
  len, i: longInt;
begin
  setLength(a, to_ - from);
  len := length(original);

  if to_ &gt; len then begin
    for i := from to len - 1 do begin
      a[i - from] := original[i];
    end;

    for i := len to to_ - 1 do begin
      a[i - from] := nil;
    end;
  end
  else begin
    for i := from to to_ - 1 do begin
      a[i - from] := original[i];
    end;
  end;

  copyOfRangeObject := a;
end;

class function Arrays.equalsPointer(a: pointer; length: longInt; a2: pointer; length2, size: longInt; e: EqualsFunction) : boolean;
var
  i: longInt;
begin
  if a = a2 then begin
    exit(true);
  end;

  if length2 &lt;&gt; length then begin
    exit(false);
  end;

  for i := 0 to length - 1 do begin
    if not e(a + i * size, a2 + i * size) then begin
      exit(false);
    end;
  end;

  equalsPointer := true;
end;

class function Arrays.equalsObject(var a: array of Object_; a2: array of Object_) : boolean;
var
  len, i: longInt;
  e: boolean;
begin
  len := length(a);

  if length(a2) &lt;&gt; len then begin
    exit(false);
  end;

  for i := 0 to len - 1 do begin
    if a[i] = nil then begin
      e := a2[i] = nil;
    end
    else begin
      e := a[i].equals_(a2[i]);
    end;

    if not e then begin
      exit(false);
    end;
  end;

  equalsObject := true;
end;

class procedure Arrays.fillPointer(a: pointer; fromIndex, toIndex, size: longInt; val: pointer);
var
  i: longInt;
  dest: pointer;
begin

  for i := fromIndex to toIndex - 1 do begin
    dest := a + i * size;
    move(val^, dest^, size);
  end;
end;

class procedure Arrays.fillObject(var a: array of Object_; fromIndex, toIndex: longInt; val: Object_);
var
  i: longInt;
begin
  for i := fromIndex to toIndex - 1 do begin
    a[i] := val;
  end;
end;

class procedure Arrays.sortPointer(a: pointer; fromIndex, toIndex, size: longInt; c: CompareFunction);
begin
  _java.quickSort(a, fromIndex, toIndex - 1, size, c);
end;

class procedure Arrays.sortObject(var a: array of Object_; fromIndex, toIndex: longInt; c: Comparator);
var
  aux: array of Object_;
begin
  setLength(aux, toIndex - fromIndex);
  _java.mergeSort(a, aux, fromIndex, toIndex - 1, c);
end;

class function Arrays.toStringPointer(a: pointer; length, size: longInt; ts: ToStringFunction) : String_;
var
  sb: StringBuilder;
  str: String_;
  i: longInt;
begin
  sb := StringBuilder.create();
  str := String_.create('[');
  sb.append(str);
  freeAndNil(str);

  if length &gt; 0 then begin
    str := ts(a);
    sb.append(str);
    freeAndNil(str);
  end;

  for i := 1 to length - 1 do begin
    str := String_.create(', ');
    sb.append(str);
    freeAndNil(str);
    str := ts(a + i * size);
    sb.append(str);
    freeAndNil(str);
  end;

  str := String_.create(']');
  sb.append(str);
  freeAndNil(str);
  str := sb.toString_();
  freeAndNil(sb);
  toStringPointer := str;
end;

class function Arrays.toStringObject(var a: array of Object_) : String_;
var
  sb: StringBuilder;
  str: String_;
  len, i: longInt;
begin
  len := length(a);
  sb := StringBuilder.create();
  str := String_.create('[');
  sb.append(str);
  freeAndNil(str);

  if len &gt; 0 then begin
    if a[0] = nil then begin
      str := String_.create('null');
    end
    else begin
      str := a[0].toString_();
    end;

    sb.append(str);
    freeAndNil(str);
  end;

  for i := 1 to len - 1 do begin
    str := String_.create(', ');
    sb.append(str);
    freeAndNil(str);

    if a[i] = nil then begin
      str := String_.create('null');
    end
    else begin
      str := a[i].toString_();
    end;

    sb.append(str);
    freeAndNil(str);
  end;

  str := String_.create(']');
  sb.append(str);
  freeAndNil(str);
  str := sb.toString_();
  freeAndNil(sb);
  toStringObject := str;
end;

(**
 * Searches the specified array of bytes for the specified value using the
 * binary search algorithm
 *
 * @param a the array to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 *)
class function Arrays.binarySearch(var a: array of shortInt; key: shortInt) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], 0, length(a), sizeOf(shortInt), @key, @_compareB);
end;

(**
 * Searches a range of the specified array of bytes for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 *)
class function Arrays.binarySearch(var a: array of shortInt; fromIndex: longInt; toIndex: longInt; key: shortInt) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], fromIndex, toIndex, sizeOf(shortInt), @key, @_compareB);
end;

(**
 * Searches the specified array of chars for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 *)
class function Arrays.binarySearch(var a: array of ansiChar; key: ansiChar) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], 0, length(a), sizeOf(ansiChar), @key, @_compareC);
end;

(**
 * Searches a range of the specified array of chars for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 *)
class function Arrays.binarySearch(var a: array of ansiChar; fromIndex: longInt; toIndex: longInt; key: ansiChar) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], fromIndex, toIndex, sizeOf(ansiChar), @key, @_compareC);
end;

(**
 * Searches the specified array of doubles for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 *)
class function Arrays.binarySearch(var a: array of double; key: double) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], 0, length(a), sizeOf(double), @key, @_compareD);
end;

(**
 * Searches a range of the specified array of doubles for the specified
 * value using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 *)
class function Arrays.binarySearch(var a: array of double; fromIndex: longInt; toIndex: longInt; key: double) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], fromIndex, toIndex, sizeOf(double), @key, @_compareD);
end;

(**
 * Searches the specified array of floats for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 *)
class function Arrays.binarySearch(var a: array of single; key: single) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], 0, length(a), sizeOf(single), @key, @_compareF);
end;

(**
 * Searches a range of the specified array of floats for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 *)
class function Arrays.binarySearch(var a: array of single; fromIndex: longInt; toIndex: longInt; key: single) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], fromIndex, toIndex, sizeOf(single), @key, @_compareF);
end;

(**
 * Searches the specified array of ints for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 *)
class function Arrays.binarySearch(var a: array of longInt; key: longInt) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], 0, length(a), sizeOf(longInt), @key, @_compareI);
end;

(**
 * Searches a range of the specified array of ints for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 *)
class function Arrays.binarySearch(var a: array of longInt; fromIndex: longInt; toIndex: longInt; key: longInt) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], fromIndex, toIndex, sizeOf(longInt), @key, @_compareI);
end;

(**
 * Searches the specified array of longs for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 *)
class function Arrays.binarySearch(var a: array of int64; key: int64) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], 0, length(a), sizeOf(int64), @key, @_compareL);
end;

(**
 * Searches a range of the specified array of longs for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 *)
class function Arrays.binarySearch(var a: array of int64; fromIndex: longInt; toIndex: longInt; key: int64) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], fromIndex, toIndex, sizeOf(int64), @key, @_compareL);
end;

(**
 * Searches the specified array for the specified object using the binary
 * search algorithm.
 *
 * @param a the array to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 *)
class function Arrays.binarySearch(var a: array of Object_; key: Object_) : longInt;
begin
  binarySearch := binarySearchObject(a, 0, length(a), key, ObjectComparator.create());
end;

(**
 * Searches a range of the specified array for the specified object using
 * the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 *)
class function Arrays.binarySearch(var a: array of Object_; fromIndex: longInt; toIndex: longInt; key: Object_) : longInt;
begin
  binarySearch := binarySearchObject(a, fromIndex, toIndex, key, ObjectComparator.create());
end;

(**
 * Searches the specified array of shorts for the specified value using the
 * binary search algorithm.
 *
 * @param a the array to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 *)
class function Arrays.binarySearch(var a: array of smallInt; key: smallInt) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], 0, length(a), sizeOf(smallInt), @key, @_compareS);
end;

(**
 * Searches a range of the specified array of shorts for the specified value
 * using the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 *)
class function Arrays.binarySearch(var a: array of smallInt; fromIndex: longInt; toIndex: longInt; key: smallInt) : longInt;
begin
  binarySearch := binarySearchPointer(@a[0], fromIndex, toIndex, sizeOf(smallInt), @key, @_compareS);
end;

(**
 * Searches the specified array for the specified object using the binary
 * search algorithm.
 *
 * @param a the array to be searched
 * @param key the value to be searched for
 * @param c the comparator by which the array is ordered. A null value
 * indicates that the elements' natural ordering should be used.
 * @return index of the search key, if it is contained in the array;
 * otherwise, (-(insertion point) - 1). The insertion point is defined as
 * the point at which the key would be inserted into the array: the index of
 * the first element greater than the key, or a.length if all elements in
 * the array are less than the specified key. Note that this guarantees that
 * the return value will be &gt;= 0 if and only if the key is found.
 *)
class function Arrays.binarySearch(var a: array of Object_; key: Object_; c: Comparator) : longInt;
begin
  binarySearch := binarySearchObject(a, 0, length(a), key, c);
end;

(**
 * Searches a range of the specified array for the specified object using
 * the binary search algorithm.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 * searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @param c the comparator by which the array is ordered. A null value
 * indicates that the elements' natural ordering should be used.
 * @return index of the search key, if it is contained in the array within
 * the specified range; otherwise, (-(insertion point) - 1). The insertion
 * point is defined as the point at which the key would be inserted into the
 * array: the index of the first element in the range greater than the key,
 * or toIndex if all elements in the range are less than the specified key.
 * Note that this guarantees that the return value will be &gt;= 0 if and only
 * if the key is found.
 *)
class function Arrays.binarySearch(var a: array of Object_; fromIndex: longInt; toIndex: longInt; key: Object_; c: Comparator) : longInt;
begin
  binarySearch := binarySearchObject(a, fromIndex, toIndex, key, c);
end;

(**
 * Copies the specified array, truncating or padding with false (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with false
 * elements to obtain the specified length
 *)
class function Arrays.copyOf(var original: array of boolean; newLength: longInt) : BooleanArray;
var
  copyArray: array of boolean;
begin
  setLength(copyArray, newLength);
  copyOf := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(boolean), 0, newLength, @defaultBoolean);
end;

(**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 *)
class function Arrays.copyOf(var original: array of shortInt; newLength: longInt) : ShortIntArray;
var
  copyArray: array of shortInt;
begin
  setLength(copyArray, newLength);
  copyOf := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(shortInt), 0, newLength, @defaultByte);
end;

(**
 * Copies the specified array, truncating or padding with null characters
 * (if necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with null
 * characters to obtain the specified length
 *)
class function Arrays.copyOf(var original: array of ansiChar; newLength: longInt) : AnsiCharArray;
var
  copyArray: array of ansiChar;
begin
  setLength(copyArray, newLength);
  copyOf := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(ansiChar), 0, newLength, @defaultChar);
end;

(**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 *)
class function Arrays.copyOf(var original: array of double; newLength: longInt) : DoubleArray;
var
  copyArray: array of double;
begin
  setLength(copyArray, newLength);
  copyOf := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(double), 0, newLength, @defaultDouble);
end;

(**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 *)
class function Arrays.copyOf(var original: array of single; newLength: longInt) : SingleArray;
var
  copyArray: array of single;
begin
  setLength(copyArray, newLength);
  copyOf := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(single), 0, newLength, @defaultFloat);
end;

(**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 *)
class function Arrays.copyOf(var original: array of longInt; newLength: longInt) : LongIntArray;
var
  copyArray: array of longInt;
begin
  setLength(copyArray, newLength);
  copyOf := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(longInt), 0, newLength, @defaultInt);
end;

(**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 *)
class function Arrays.copyOf(var original: array of int64; newLength: longInt) : Int64Array;
var
  copyArray: array of int64;
begin
  setLength(copyArray, newLength);
  copyOf := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(int64), 0, newLength, @defaultLong);
end;

(**
 * Copies the specified array, truncating or padding with zeros (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with zeros to
 * obtain the specified length
 *)
class function Arrays.copyOf(var original: array of smallInt; newLength: longInt) : SmallIntArray;
var
  copyArray: array of smallInt;
begin
  setLength(copyArray, newLength);
  copyOf := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(smallInt), 0, newLength, @defaultShort);
end;

(**
 * Copies the specified array, truncating or padding with nulls (if
 * necessary) so the copy has the specified length.
 *
 * @param original the array to be copied
 * @param newLength the length of the copy to be returned
 * @return a copy of the original array, truncated or padded with nulls to
 * obtain the specified length
 *)
class function Arrays.copyOf(var original: array of Object_; newLength: longInt) : ObjectArray;
begin
  copyOf := copyOfRangeObject(original, 0, newLength);
end;

(**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with false elements to obtain the required
 * length
 *)
class function Arrays.copyOfRange(var original: array of boolean; from: longInt; to_: longInt) : BooleanArray;
var
  copyArray: array of boolean;
begin
  setLength(copyArray, to_ - from);
  copyOfRange := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(boolean), from, to_, @defaultBoolean);
end;

(**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 *)
class function Arrays.copyOfRange(var original: array of shortInt; from: longInt; to_: longInt) : ShortIntArray;
var
  copyArray: array of shortInt;
begin
  setLength(copyArray, to_ - from);
  copyOfRange := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(shortInt), from, to_, @defaultByte);
end;

(**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with null characters to obtain the required
 * length
 *)
class function Arrays.copyOfRange(var original: array of ansiChar; from: longInt; to_: longInt) : AnsiCharArray;
var
  copyArray: array of ansiChar;
begin
  setLength(copyArray, to_ - from);
  copyOfRange := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(ansiChar), from, to_, @defaultChar);
end;

(**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 *)
class function Arrays.copyOfRange(var original: array of double; from: longInt; to_: longInt) : DoubleArray;
var
  copyArray: array of double;
begin
  setLength(copyArray, to_ - from);
  copyOfRange := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(double), from, to_, @defaultDouble);
end;

(**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 *)
class function Arrays.copyOfRange(var original: array of single; from: longInt; to_: longInt) : SingleArray;
var
  copyArray: array of single;
begin
  setLength(copyArray, to_ - from);
  copyOfRange := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(single), from, to_, @defaultFloat);
end;

(**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 *)
class function Arrays.copyOfRange(var original: array of longInt; from: longInt; to_: longInt) : LongIntArray;
var
  copyArray: array of longInt;
begin
  setLength(copyArray, to_ - from);
  copyOfRange := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(longInt), from, to_, @defaultInt);
end;

(**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 *)
class function Arrays.copyOfRange(var original: array of int64; from: longInt; to_: longInt) : Int64Array;
var
  copyArray: array of int64;
begin
  setLength(copyArray, to_ - from);
  copyOfRange := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(int64), from, to_, @defaultLong);
end;

(**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with zeros to obtain the required length
 *)
class function Arrays.copyOfRange(var original: array of smallInt; from: longInt; to_: longInt) : SmallIntArray;
var
  copyArray: array of smallInt;
begin
  setLength(copyArray, to_ - from);
  copyOfRange := copyOfRangePointer(@original[0], @copyArray[0], length(original), sizeOf(smallInt), from, to_, @defaultShort);
end;

(**
 * Copies the specified range of the specified array into a new array.
 *
 * @param original the array from which a range is to be copied
 * @param from the initial index of the range to be copied, inclusive
 * @param to the final index of the range to be copied, exclusive. (This
 * index may lie outside the array.)
 * @return a new array containing the specified range from the original
 * array, truncated or padded with nulls to obtain the required length
 *)
class function Arrays.copyOfRange(var original: array of Object_; from: longInt; to_: longInt) : ObjectArray;
begin
  copyOfRange := copyOfRangeObject(original, from, to_);
end;

(**
 * Returns true if the two specified arrays of booleans are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param a2 the other array to be tested for equality
 * @return true if the two arrays are equal
 *)
class function Arrays.equals(a: array of boolean; a2: array of boolean) : boolean;
var
  p, p2: pointer;
  l, l2: longInt;
begin
  l := length(a);
  l2 := length(a2);

  if length(a) = 0 then begin
    p := nil;
  end
  else begin
    p := @a[0];
  end;

  if length(a2) = 0 then begin
    p2 := nil;
  end
  else begin
    p2 := @a2[0];
  end;

  equals := equalsPointer(p, l, p2, l2, sizeOf(boolean), @_equalsBool);
end;

(**
 * Returns true if the two specified arrays of bytes are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param a2 the other array to be tested for equality
 * @return true if the two arrays are equal
 *)
class function Arrays.equals(a: array of shortInt; a2: array of shortInt) : boolean;
var
  p, p2: pointer;
  l, l2: longInt;
begin
  l := length(a);
  l2 := length(a2);

  if length(a) = 0 then begin
    p := nil;
  end
  else begin
    p := @a[0];
  end;

  if length(a2) = 0 then begin
    p2 := nil;
  end
  else begin
    p2 := @a2[0];
  end;

  equals := equalsPointer(p, l, p2, l2, sizeOf(shortInt), @_equalsB);
end;

(**
 * Returns true if the two specified arrays of chars are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param a2 the other array to be tested for equality
 * @return true if the two arrays are equal
 *)
class function Arrays.equals(a: array of ansiChar; a2: array of ansiChar) : boolean;
var
  p, p2: pointer;
  l, l2: longInt;
begin
  l := length(a);
  l2 := length(a2);

  if length(a) = 0 then begin
    p := nil;
  end
  else begin
    p := @a[0];
  end;

  if length(a2) = 0 then begin
    p2 := nil;
  end
  else begin
    p2 := @a2[0];
  end;

  equals := equalsPointer(p, l, p2, l2, sizeOf(ansiChar), @_equalsC);
end;

(**
 * Returns true if the two specified arrays of doubles are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param a2 the other array to be tested for equality
 * @return true if the two arrays are equal
 *)
class function Arrays.equals(a: array of double; a2: array of double) : boolean;
var
  p, p2: pointer;
  l, l2: longInt;
begin
  l := length(a);
  l2 := length(a2);

  if length(a) = 0 then begin
    p := nil;
  end
  else begin
    p := @a[0];
  end;

  if length(a2) = 0 then begin
    p2 := nil;
  end
  else begin
    p2 := @a2[0];
  end;

  equals := equalsPointer(p, l, p2, l2, sizeOf(double), @_equalsD);
end;

(**
 * Returns true if the two specified arrays of floats are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param a2 the other array to be tested for equality
 * @return true if the two arrays are equal
 *)
class function Arrays.equals(a: array of single; a2: array of single) : boolean;
var
  p, p2: pointer;
  l, l2: longInt;
begin
  l := length(a);
  l2 := length(a2);

  if length(a) = 0 then begin
    p := nil;
  end
  else begin
    p := @a[0];
  end;

  if length(a2) = 0 then begin
    p2 := nil;
  end
  else begin
    p2 := @a2[0];
  end;

  equals := equalsPointer(p, l, p2, l2, sizeOf(single), @_equalsF);
end;

(**
 * Returns true if the two specified arrays of ints are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param a2 the other array to be tested for equality
 * @return true if the two arrays are equal
 *)
class function Arrays.equals(a: array of longInt; a2: array of longInt) : boolean;
var
  p, p2: pointer;
  l, l2: longInt;
begin
  l := length(a);
  l2 := length(a2);

  if length(a) = 0 then begin
    p := nil;
  end
  else begin
    p := @a[0];
  end;

  if length(a2) = 0 then begin
    p2 := nil;
  end
  else begin
    p2 := @a2[0];
  end;

  equals := equalsPointer(p, l, p2, l2, sizeOf(longInt), @_equalsI);
end;

(**
 * Returns true if the two specified arrays of longs are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param a2 the other array to be tested for equality
 * @return true if the two arrays are equal
 *)
class function Arrays.equals(a: array of int64; a2: array of int64) : boolean;
var
  p, p2: pointer;
  l, l2: longInt;
begin
  l := length(a);
  l2 := length(a2);

  if length(a) = 0 then begin
    p := nil;
  end
  else begin
    p := @a[0];
  end;

  if length(a2) = 0 then begin
    p2 := nil;
  end
  else begin
    p2 := @a2[0];
  end;

  equals := equalsPointer(p, l, p2, l2, sizeOf(int64), @_equalsL);
end;

(**
 * Returns true if the two specified arrays of Objects are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param a2 the other array to be tested for equality
 * @return true if the two arrays are equal
 *)
class function Arrays.equals(a: array of Object_; a2: array of Object_) : boolean;
begin
  equals := equalsObject(a, a2);
end;

(**
 * Returns true if the two specified arrays of shorts are equal to one
 * another.
 *
 * @param a one array to be tested for equality
 * @param a2 the other array to be tested for equality
 * @return true if the two arrays are equal
 *)
class function Arrays.equals(a: array of smallInt; a2: array of smallInt) : boolean;
var
  p, p2: pointer;
  l, l2: longInt;
begin
  l := length(a);
  l2 := length(a2);

  if length(a) = 0 then begin
    p := nil;
  end
  else begin
    p := @a[0];
  end;

  if length(a2) = 0 then begin
    p2 := nil;
  end
  else begin
    p2 := @a2[0];
  end;

  equals := equalsPointer(p, l, p2, l2, sizeOf(smallInt), @_equalsS);
end;

(**
 * Assigns the specified boolean value to each element of the specified
 * array of booleans.
 *
 * @param a the array to be filled
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of boolean; val: boolean);
begin
  fillPointer(@a[0], 0, length(a), sizeOf(boolean), @val);
end;

(**
 * Assigns the specified boolean value to each element of the specified
 * range of the specified array of booleans.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of boolean; fromIndex: longInt; toIndex: longInt; val: boolean);
begin
  fillPointer(@a[0], fromIndex, toIndex, sizeOf(boolean), @val);
end;

(**
 * Assigns the specified byte value to each element of the specified array
 * of bytes.
 *
 * @param a the array to be filled
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of shortInt; val: shortInt);
begin
  fillPointer(@a[0], 0, length(a), sizeOf(shortInt), @val);
end;

(**
 * Assigns the specified byte value to each element of the specified range
 * of the specified array of bytes.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of shortInt; fromIndex: longInt; toIndex: longInt; val: shortInt);
begin
  fillPointer(@a[0], fromIndex, toIndex, sizeOf(shortInt), @val);
end;

(**
 * Assigns the specified char value to each element of the specified array
 * of chars.
 *
 * @param a the array to be filled
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of ansiChar; val: ansiChar);
begin
  fillPointer(@a[0], 0, length(a), sizeOf(ansiChar), @val);
end;

(**
 * Assigns the specified char value to each element of the specified range
 * of the specified array of chars.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of ansiChar; fromIndex: longInt; toIndex: longInt; val: ansiChar);
begin
  fillPointer(@a[0], fromIndex, toIndex, sizeOf(ansiChar), @val);
end;

(**
 * Assigns the specified double value to each element of the specified array
 * of doubles.
 *
 * @param a the array to be filled
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of double; val: double);
begin
  fillPointer(@a[0], 0, length(a), sizeOf(double), @val);
end;

(**
 * Assigns the specified double value to each element of the specified range
 * of the specified array of doubles.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of double; fromIndex: longInt; toIndex: longInt; val: double);
begin
  fillPointer(@a[0], fromIndex, toIndex, sizeOf(double), @val);
end;

(**
 * Assigns the specified float value to each element of the specified array
 * of floats.
 *
 * @param a the array to be filled
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of single; val: single);
begin
  fillPointer(@a[0], 0, length(a), sizeOf(single), @val);
end;

(**
 * Assigns the specified float value to each element of the specified range
 * of the specified array of floats.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of single; fromIndex: longInt; toIndex: longInt; val: single);
begin
  fillPointer(@a[0], fromIndex, toIndex, sizeOf(single), @val);
end;

(**
 * Assigns the specified int value to each element of the specified array of
 * ints.
 *
 * @param a the array to be filled
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of longInt; val: longInt);
begin
  fillPointer(@a[0], 0, length(a), sizeOf(longInt), @val);
end;

(**
 * Assigns the specified int value to each element of the specified range of
 * the specified array of ints.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of longInt; fromIndex: longInt; toIndex: longInt; val: longInt);
begin
  fillPointer(@a[0], fromIndex, toIndex, sizeOf(longInt), @val);
end;

(**
 * Assigns the specified long value to each element of the specified array
 * of longs.
 *
 * @param a the array to be filled
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of int64; val: int64);
begin
  fillPointer(@a[0], 0, length(a), sizeOf(int64), @val);
end;

(**
 * Assigns the specified long value to each element of the specified range
 * of the specified array of longs.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of int64; fromIndex: longInt; toIndex: longInt; val: int64);
begin
  fillPointer(@a[0], fromIndex, toIndex, sizeOf(int64), @val);
end;

(**
 * Assigns the specified Object reference to each element of the specified
 * array of Objects.
 *
 * @param a the array to be filled
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of Object_; val: Object_);
begin
  fillObject(a, 0, length(a), val);
end;

(**
 * Assigns the specified Object reference to each element of the specified
 * range of the specified array of Objects.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of Object_; fromIndex: longInt; toIndex: longInt; val: Object_);
begin
  fillObject(a, fromIndex, toIndex, val);
end;

(**
 * Assigns the specified short value to each element of the specified array
 * of shorts.
 *
 * @param a the array to be filled
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of smallInt; val: smallInt);
begin
  fillPointer(@a[0], 0, length(a), sizeOf(smallInt), @val);
end;

(**
 * Assigns the specified short value to each element of the specified range
 * of the specified array of shorts.
 *
 * @param a the array to be filled
 * @param fromIndex the index of the first element (inclusive) to be filled
 * with the specified value
 * @param toIndex the index of the last element (exclusive) to be filled
 * with the specified value
 * @param val the value to be stored in all elements of the array
 *)
class procedure Arrays.fill(var a: array of smallInt; fromIndex: longInt; toIndex: longInt; val: smallInt);
begin
  fillPointer(@a[0], fromIndex, toIndex, sizeOf(smallInt), @val);
end;

(**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 *)
class procedure Arrays.sort(var a: array of shortInt);
begin
  sortPointer(@a[0], 0, length(a), sizeOf(shortInt), @_compareB);
end;

(**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 *)
class procedure Arrays.sort(var a: array of shortInt; fromIndex: longInt; toIndex: longInt);
begin
  sortPointer(@a[0], fromIndex, toIndex, sizeOf(shortInt), @_compareB);
end;

(**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 *)
class procedure Arrays.sort(var a: array of ansiChar);
begin
  sortPointer(@a[0], 0, length(a), sizeOf(ansiChar), @_compareC);
end;

(**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 *)
class procedure Arrays.sort(var a: array of ansiChar; fromIndex: longInt; toIndex: longInt);
begin
  sortPointer(@a[0], fromIndex, toIndex, sizeOf(ansiChar), @_compareC);
end;

(**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 *)
class procedure Arrays.sort(var a: array of double);
begin
  sortPointer(@a[0], 0, length(a), sizeOf(double), @_compareD);
end;

(**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 *)
class procedure Arrays.sort(var a: array of double; fromIndex: longInt; toIndex: longInt);
begin
  sortPointer(@a[0], fromIndex, toIndex, sizeOf(double), @_compareD);
end;

(**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 *)
class procedure Arrays.sort(var a: array of single);
begin
  sortPointer(@a[0], 0, length(a), sizeOf(single), @_compareF);
end;

(**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 *)
class procedure Arrays.sort(var a: array of single; fromIndex: longInt; toIndex: longInt);
begin
  sortPointer(@a[0], fromIndex, toIndex, sizeOf(single), @_compareF);
end;

(**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 *)
class procedure Arrays.sort(var a: array of longInt);
begin
  sortPointer(@a[0], 0, length(a), sizeOf(longInt), @_compareI);
end;

(**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 *)
class procedure Arrays.sort(var a: array of longInt; fromIndex: longInt; toIndex: longInt);
begin
  sortPointer(@a[0], fromIndex, toIndex, sizeOf(longInt), @_compareI);
end;

(**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 *)
class procedure Arrays.sort(var a: array of int64);
begin
  sortPointer(@a[0], 0, length(a), sizeOf(int64), @_compareL);
end;

(**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 *)
class procedure Arrays.sort(var a: array of int64; fromIndex: longInt; toIndex: longInt);
begin
  sortPointer(@a[0], fromIndex, toIndex, sizeOf(int64), @_compareL);
end;

(**
 * Sorts the specified array of objects into ascending order, according to
 * the natural ordering of its elements.
 *
 * @param a the array to be sorted
 *)
class procedure Arrays.sort(var a: array of Object_);
begin
  sortObject(a, 0, length(a), ObjectComparator.create());
end;

(**
 * Sorts the specified range of the specified array of objects into
 * ascending order, according to the natural ordering of its elements.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 *)
class procedure Arrays.sort(var a: array of Object_; fromIndex: longInt; toIndex: longInt);
begin
  sortObject(a, fromIndex, toIndex, ObjectComparator.create());
end;

(**
 * Sorts the specified array into ascending numerical order.
 *
 * @param a the array to be sorted
 *)
class procedure Arrays.sort(var a: array of smallInt);
begin
  sortPointer(@a[0], 0, length(a), sizeOf(smallInt), @_compareS);
end;

(**
 * Sorts the specified range of the array into ascending order.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 *)
class procedure Arrays.sort(var a: array of smallInt; fromIndex: longInt; toIndex: longInt);
begin
  sortPointer(@a[0], fromIndex, toIndex, sizeOf(smallInt), @_compareS);
end;

(**
 * Sorts the specified array of objects according to the order induced by
 * the specified comparator.
 *
 * @param a the array to be sorted
 * @param c the comparator to determine the order of the array. A null value
 * indicates that the elements' natural ordering should be used.
 *)
class procedure Arrays.sort(var a: array of Object_; c: Comparator);
begin
  sortObject(a, 0, length(a), c);
end;

(**
 * Sorts the specified range of the specified array of objects according to
 * the order induced by the specified comparator.
 *
 * @param a the array to be sorted
 * @param fromIndex the index of the first element (inclusive) to be sorted
 * @param toIndex the index of the last element (exclusive) to be sorted
 * @param c the comparator to determine the order of the array. A null value
 * indicates that the elements' natural ordering should be used.
 *)
class procedure Arrays.sort(var a: array of Object_; fromIndex: longInt; toIndex: longInt; c: Comparator);
begin
  sortObject(a, fromIndex, toIndex, c);
end;

(**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @return a string representation of a
 *)
class function Arrays.toString(var a: array of boolean) : String_;
begin
  toString := toStringPointer(@a[0], length(a), sizeOf(boolean), @_toStringBool);
end;

(**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @return a string representation of a
 *)
class function Arrays.toString(var a: array of shortInt) : String_;
begin
  toString := toStringPointer(@a[0], length(a), sizeOf(shortInt), @_toStringB);
end;

(**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @return a string representation of a
 *)
class function Arrays.toString(var a: array of ansiChar) : String_;
begin
  toString := toStringPointer(@a[0], length(a), sizeOf(ansiChar), @_toStringC);
end;

(**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @return a string representation of a
 *)
class function Arrays.toString(var a: array of double) : String_;
begin
  toString := toStringPointer(@a[0], length(a), sizeOf(double), @_toStringD);
end;

(**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @return a string representation of a
 *)
class function Arrays.toString(var a: array of single) : String_;
begin
  toString := toStringPointer(@a[0], length(a), sizeOf(single), @_toStringF);
end;

(**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @return a string representation of a
 *)
class function Arrays.toString(var a: array of longInt) : String_;
begin
  toString := toStringPointer(@a[0], length(a), sizeOf(longInt), @_toStringI);
end;

(**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @return a string representation of a
 *)
class function Arrays.toString(var a: array of int64) : String_;
begin
  toString := toStringPointer(@a[0], length(a), sizeOf(int64), @_toStringL);
end;

(**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @return a string representation of a
 *)
class function Arrays.toString(var a: array of Object_) : String_;
begin
  toString := toStringObject(a);
end;

(**
 * Returns a string representation of the contents of the specified array.
 *
 * @param a the array whose string representation to return
 * @return a string representation of a
 *)
class function Arrays.toString(var a: array of smallInt) : String_;
begin
  toString := toStringPointer(@a[0], length(a), sizeOf(smallInt), @_toStringS);
end;

end.
</code>

</codes>
