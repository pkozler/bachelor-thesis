<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<codes>
<code lang="C">#ifndef STRINGTOKENIZER_INCLUDED&#13;
#define	STRINGTOKENIZER_INCLUDED&#13;
&#13;
#include "String.h"&#13;
#include &lt;stdbool.h&gt;&#13;
#include &lt;stdint.h&gt;&#13;
&#13;
/**&#13;
 * The string tokenizer module allows an application to break a string into tokens.&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
&#13;
typedef struct {&#13;
    char **tokens;&#13;
    int32_t tokensLength;&#13;
    int32_t tokenCounter;&#13;
} StringTokenizer;&#13;
&#13;
StringTokenizer *new_StringTokenizer(String *str);&#13;
StringTokenizer *new_StringTokenizerDelim(String *str, String *delim);&#13;
void delete_StringTokenizer(StringTokenizer *ptr);&#13;
int32_t countTokens(StringTokenizer *ptr);&#13;
bool hasMoreTokens(StringTokenizer *ptr);&#13;
String *nextToken(StringTokenizer *ptr);&#13;
&#13;
#endif	/* STRINGTOKENIZER_INCLUDED */&#13;
&#13;
&#13;
#include "StringTokenizer.h"&#13;
#include "ArrayList.h"&#13;
#include "System.h"&#13;
&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;wchar.h&gt;&#13;
&#13;
/**&#13;
 * Constructs a string tokenizer for the specified string.&#13;
 *&#13;
 * @param str a string to be parsed.&#13;
 */&#13;
StringTokenizer *new_StringTokenizer(String *str) {&#13;
    return new_StringTokenizerDelim(str, new_String(" \t\n\r\f"));&#13;
}&#13;
&#13;
/**&#13;
 * Constructs a string tokenizer for the specified string.&#13;
 *&#13;
 * @param str a string to be parsed.&#13;
 * @param delim the delimiters.&#13;
 */&#13;
StringTokenizer *new_StringTokenizerDelim(String *str, String *delim) {&#13;
    StringTokenizer *strTok = malloc(sizeof(StringTokenizer));&#13;
    char *ch = strpbrk(str-&gt;s, delim-&gt;s);&#13;
    &#13;
    for (strTok-&gt;tokensLength = 1; ch != NULL; strTok-&gt;tokensLength++) {&#13;
        ch = strpbrk(ch + 1, delim-&gt;s);&#13;
    }&#13;
    &#13;
    strTok-&gt;tokenCounter = 0;&#13;
    strTok-&gt;tokens = (char **) malloc(strTok-&gt;tokensLength * sizeof(char *));&#13;
    &#13;
    char *s = strtok(str-&gt;s, delim-&gt;s);&#13;
    int32_t i = 0;&#13;
    &#13;
    while (s != NULL) {&#13;
        strTok-&gt;tokens[i] = s;&#13;
        i++;&#13;
        s = strtok(NULL, delim-&gt;s);&#13;
    }&#13;
&#13;
    strTok-&gt;tokensLength = i;&#13;
    strTok-&gt;tokens = realloc(strTok-&gt;tokens, strTok-&gt;tokensLength * sizeof(char *));&#13;
    &#13;
    return strTok;&#13;
}&#13;
&#13;
void delete_StringTokenizer(StringTokenizer *ptr) {&#13;
    int32_t i;&#13;
    for (i = 0; i &lt; ptr-&gt;tokensLength; i++) {&#13;
        free(ptr-&gt;tokens[i]);&#13;
    }&#13;
    &#13;
    free(ptr-&gt;tokens);&#13;
    free(ptr);&#13;
}&#13;
&#13;
/**&#13;
 * Calculates the number of times that the specified tokenizer's nextToken function can&#13;
 * be called before it results in undefined behavior.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @return the number of tokens remaining in the string using the current&#13;
 * delimiter set.&#13;
 */&#13;
int32_t countTokens(StringTokenizer *ptr) {&#13;
    return ptr-&gt;tokensLength - ptr-&gt;tokenCounter;&#13;
}&#13;
&#13;
/**&#13;
 * Tests if there are more tokens available from the specified tokenizer's string.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @return true if and only if there is at least one token in the string&#13;
 * after the current position; false otherwise.&#13;
 */&#13;
bool hasMoreTokens(StringTokenizer *ptr) {&#13;
    return (countTokens(ptr) &gt; 0);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the next token from the specified string tokenizer.&#13;
 *&#13;
 * @param ptr The allocated structure&#13;
 * @return the next token from the specified string tokenizer.&#13;
 */&#13;
String *nextToken(StringTokenizer *ptr) {&#13;
    String *str = new_String(ptr-&gt;tokens[ptr-&gt;tokenCounter]);&#13;
    ptr-&gt;tokenCounter++;&#13;
    &#13;
    return str;&#13;
}&#13;
</code>
<code lang="C++">#ifndef STRINGTOKENIZER_INCLUDED&#13;
#define	STRINGTOKENIZER_INCLUDED&#13;
&#13;
#include "String_.h"&#13;
#include &lt;cstdint&gt;&#13;
&#13;
/**&#13;
 * The string tokenizer class allows an application to break a string into tokens.&#13;
 *&#13;
 * @author Petr Kozler (A13B0359P)&#13;
 */&#13;
class StringTokenizer : public Object {&#13;
    std::string *tokens;&#13;
    int32_t tokensLength;&#13;
    int32_t tokenCounter;&#13;
    void init(std::string str, std::string delim);&#13;
public:&#13;
    StringTokenizer(String *str);&#13;
    StringTokenizer(String *str, String *delim);&#13;
    ~StringTokenizer();&#13;
    int32_t countTokens();&#13;
    bool hasMoreTokens();&#13;
    String *nextToken();&#13;
};&#13;
&#13;
#endif	// STRINGTOKENIZER_INCLUDED&#13;
&#13;
&#13;
&#13;
#include "StringTokenizer.h"&#13;
#include "System.h"&#13;
&#13;
#include &lt;iostream&gt;&#13;
#include &lt;cstring&gt;&#13;
#include &lt;string.h&gt;&#13;
&#13;
void StringTokenizer::init(std::string str, std::string delim) {&#13;
    size_t pos = str.find_first_of(delim, 0);&#13;
    &#13;
    for (tokensLength = 1; pos != str.npos; tokensLength++) {&#13;
        pos = str.find_first_of(delim, pos + 1);&#13;
    }&#13;
    &#13;
    tokenCounter = 0;&#13;
    tokens = new std::string[tokensLength];&#13;
    &#13;
    char* tmpS = strdup(str.c_str());&#13;
    &#13;
    char *s = strtok(tmpS, delim.c_str());&#13;
    int32_t i = 0;&#13;
    &#13;
    while (s != 0) {&#13;
        tokens[i] = s;&#13;
        i++;&#13;
        s = strtok(NULL, delim.c_str());&#13;
    }&#13;
    &#13;
    tokensLength = i;&#13;
    std::string *tempTokens = new std::string[tokensLength];&#13;
    &#13;
    for (int32_t j = 0; j &lt; tokensLength; j++) {&#13;
        tempTokens[j] = tokens[j];&#13;
    }&#13;
    &#13;
    delete[] tokens;&#13;
    tokens = tempTokens;&#13;
}&#13;
&#13;
/**&#13;
 * Constructs a string tokenizer for the specified string.&#13;
 *&#13;
 * @param str a string to be parsed.&#13;
 */&#13;
StringTokenizer::StringTokenizer(String *str) {&#13;
    init(str-&gt;_s(), " \t\n\r\f");&#13;
}&#13;
&#13;
/**&#13;
 * Constructs a string tokenizer for the specified string.&#13;
 *&#13;
 * @param str a string to be parsed.&#13;
 * @param delim the delimiters.&#13;
 */&#13;
StringTokenizer::StringTokenizer(String *str, String *delim) {&#13;
    init(str-&gt;_s(), delim-&gt;_s());&#13;
}&#13;
&#13;
StringTokenizer::~StringTokenizer() {&#13;
    delete[] tokens;&#13;
}&#13;
&#13;
/**&#13;
 * Calculates the number of times that this tokenizer's nextToken method can&#13;
 * be called before it results in undefined behavior.&#13;
 *&#13;
 * @return the number of tokens remaining in the string using the current&#13;
 * delimiter set.&#13;
 */&#13;
int32_t StringTokenizer::countTokens() {&#13;
    return tokensLength - tokenCounter;&#13;
}&#13;
&#13;
/**&#13;
 * Tests if there are more tokens available from this tokenizer's string.&#13;
 *&#13;
 * @return true if and only if there is at least one token in the string&#13;
 * after the current position; false otherwise.&#13;
 */&#13;
bool StringTokenizer::hasMoreTokens() {&#13;
    return (countTokens() &gt; 0);&#13;
}&#13;
&#13;
/**&#13;
 * Returns the next token from this string tokenizer.&#13;
 *&#13;
 * @return the next token from this string tokenizer.&#13;
 */&#13;
String *StringTokenizer::nextToken() {&#13;
    String *str = new String(tokens[tokenCounter]);&#13;
    tokenCounter++;&#13;
    &#13;
    return str;&#13;
}&#13;
</code>
<code lang="C#">ï»¿using System;&#13;
&#13;
namespace JavaClasses&#13;
{&#13;
&#13;
    /// &lt;summary&gt;&#13;
    /// The string tokenizer class allows an application to break a string into tokens.&#13;
    /// &lt;/summary&gt;&#13;
    /// &lt;author&gt;Petr Kozler (A13B0359P)&lt;/author&gt;&#13;
    public class StringTokenizer : Object&#13;
    {&#13;
&#13;
        // current string array containing tokens&#13;
        private string[] tokens;&#13;
        // current position in the array&#13;
        private int tokenCounter = 0;&#13;
&#13;
        /*&#13;
            Performs the string splitting.&#13;
         */&#13;
        private void initialize(string str, string delim = " \t\n\r\f")&#13;
        {&#13;
            // splitting the string to the array by the specified set of delimiters&#13;
            tokens = str.Split(delim.ToCharArray(), StringSplitOptions.RemoveEmptyEntries);&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Constructs a string tokenizer for the specified string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="str"&gt;a string to be parsed.&#13;
        /// &lt;/param&gt;&#13;
        public StringTokenizer(String str)&#13;
        {&#13;
            initialize(str.ToString());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Constructs a string tokenizer for the specified string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;param name="str"&gt;a string to be parsed.&#13;
        /// &lt;/param&gt;&lt;param name="delim"&gt;the delimiters.&#13;
        /// &lt;/param&gt;&#13;
        public StringTokenizer(String str, String delim)&#13;
        {&#13;
            initialize(str.ToString(), delim.ToString());&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Calculates the number of times that this tokenizer's nextToken method can&#13;
        /// be called before it generates an exception.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the number of tokens remaining in the string using the current&#13;
        /// delimiter set.&#13;
        /// &lt;/returns&gt;&#13;
        public int countTokens()&#13;
        {&#13;
            return tokens.Length - tokenCounter;&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Tests if there are more tokens available from this tokenizer's string.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;true if and only if there is at least one token in the string&#13;
        /// after the current position; false otherwise.&#13;
        /// &lt;/returns&gt;&#13;
        public bool hasMoreTokens()&#13;
        {&#13;
            return countTokens() &gt; 0;&#13;
        }&#13;
&#13;
        /// &lt;summary&gt;&#13;
        /// Returns the next token from this string tokenizer.&#13;
        /// &lt;/summary&gt;&#13;
        /// &lt;returns&gt;the next token from this string tokenizer.&#13;
        /// &lt;/returns&gt;&#13;
        public String nextToken()&#13;
        {&#13;
            return tokens[tokenCounter++];&#13;
        }&#13;
&#13;
    }&#13;
&#13;
}&#13;
</code>
<code lang="Free Pascal">unit StringTokenizerUnit;

{$mode objfpc}{$H+}

interface

uses
  Classes, StrUtils, StringUnit;

type
  (**
   * The string tokenizer class allows an application to break a string into tokens.
   *
   * @author Petr Kozler (A13B0359P)
   *)
  StringTokenizer = class(Object_)
    private
      var
        tokens: array of ansiString;
        tokenCounter: longInt;
    public
      constructor create(str: String_);
      constructor create(str: String_; delim: String_);
      function countTokens() : longInt;
      function hasMoreTokens() : boolean;
      function nextToken() : String_;
  end;

implementation

uses
  SysUtils;

(**
 * Constructs a string tokenizer for the specified string.
 *
 * @param str a string to be parsed.
 *)
constructor StringTokenizer.create(str: String_);
begin
  self.create(str, #32#9#10#11#12#13);
end;

(**
 * Constructs a string tokenizer for the specified string.
 *
 * @param str a string to be parsed.
 * @param delim the delimiters.
 *)
constructor StringTokenizer.create(str: String_; delim: String_);
var
  strStr, delimStr, tmpStr: ansiString;
  count, len, i, tmp, index: longInt;
begin
  tokenCounter := 0;
  count := 1;
  strStr := str.strProperty;
  delimStr := delim.strProperty;
  len := length(strStr);

  for i := 1 to len do begin
    if ansiContainsStr(delimStr, strStr[i]) then begin
      inc(count);
    end;
  end;

  setLength(tokens, count);
  index := 0;
  tmp := 1;

  for i := 1 to len do begin
    if ansiContainsStr(delimStr, strStr[i]) then begin
       tmpStr := copy(strStr, tmp, i - tmp);

       if length(tmpStr) &gt; 0 then begin
          tokens[index] := tmpStr;
          inc(index);
       end;

       tmp := i + 1;
    end;
  end;

  tmpStr := copy(strStr, tmp, i - tmp + 1);

  if length(tmpStr) &gt; 0 then begin
     tokens[index] := tmpStr;
     inc(index);
  end;

  setLength(tokens, index);
end;

(**
 * Calculates the number of times that this tokenizer's nextToken method can
 * be called before it causes an error.
 *
 * @return the number of tokens remaining in the string using the current
 * delimiter set.
 *)
function StringTokenizer.countTokens() : longInt;
begin
  countTokens := length(tokens) - tokenCounter;
end;

(**
 * Tests if there are more tokens available from this tokenizer's string.
 *
 * @return true if and only if there is at least one token in the string
 * after the current position; false otherwise.
 *)
function StringTokenizer.hasMoreTokens() : boolean;
begin
  hasMoreTokens := (countTokens() &gt; 0);
end;

(**
 * Returns the next token from this string tokenizer.
 *
 * @return the next token from this string tokenizer.
 *)
function StringTokenizer.nextToken() : String_;
var
  i: longInt;
begin
  i := tokenCounter;
  inc(tokenCounter);
  nextToken := tokens[i];
end;

end.

</code>

</codes>
