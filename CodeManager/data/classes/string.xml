<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<codes>
<code lang="C">#ifndef STRING_INCLUDED
#define STRING_INCLUDED

#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

/**
 * The String struct represents character strings.
 *
 * @author Petr Kozler (A13B0359P)
 */

typedef struct {
    // an inner string
    char *s;
    // inner string length
    int32_t len;
} String;

String *new_StringB(int8_t *value, int32_t length);
String *new_StringRangeB(int8_t *value, int32_t offset, int32_t length);
String *new_String(char *original);
void delete_String(String *ptr);
int32_t compareToStr(String *ptr, String *anotherString);
bool equalsStr(String *ptr, String *anObject);
String *substring(String *ptr, int32_t beginIndex);
String *substringTo(String *ptr, int32_t beginIndex, int32_t endIndex);
int32_t indexOfC(String *ptr, int32_t ch);
int32_t indexOfFromC(String *ptr, int32_t ch, int32_t fromIndex);
int32_t indexOfStr(String *ptr, String *str);
int32_t indexOfFromStr(String *ptr, String *str, int32_t fromIndex);
int32_t length(String *ptr);
String *trim(String *ptr);
String *toLowerCase(String *ptr);
String *toUpperCase(String *ptr);
char charAt(String *ptr, int32_t index);
String *replace(String *ptr, char oldChar, char newChar);
bool startsWith(String *ptr, String *prefix);
bool endsWith(String *ptr, String *suffix);
bool isEmptyStr(String *ptr);
String *toStringStr(String *ptr);

#endif	/* STRING_INCLUDED */


#include "String_.h"

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;wchar.h&gt;

/**
 * Constructs a new String by decoding the specified array of bytes using
 * the ANSI charset.
 *
 * @param bytes The bytes to be decoded into characters
 * @param length The array length
 */
String *new_StringB(int8_t *value, int32_t length) {
    return new_StringRangeB(value, 0, length);
}

/**
 * Constructs a new String by decoding the specified subarray of bytes using
 * the ANSI charset.
 *
 * @param bytes The bytes to be decoded into characters
 * @param offset The index of the first byte to decode
 * @param length The number of bytes to decode
 */
String *new_StringRangeB(int8_t *value, int32_t offset, int32_t length) {
    String *str = malloc(sizeof(String));
    str-&gt;s = malloc(sizeof(char) * (length + 1));
    str-&gt;s[0] = '\0';
    // adding the terminator after the byte array to create a string
    strncat(str-&gt;s, (char *) value + offset, length);
    str-&gt;len = strlen(str-&gt;s);

    return str;
}

/**
 * Initializes a newly created String structure so that it represents the same
 * sequence of characters as the argument; in other words, the inner null terminated
 * char array of the newly created String structure instance is a copy of the argument array.
 *
 * @param original A String
 */
String *new_String(char *original) {
    String *str = malloc(sizeof(String));
    // copying the string so the original one will not be affected
    str-&gt;s = strdup(original);
    str-&gt;len = strlen(str-&gt;s);

    return str;
}

/*
    Destructs the String.
 */
void delete_String(String *ptr) {
    free(ptr-&gt;s);
    free(ptr);
}

/**
 * Compares two strings lexicographically.
 *
 * @param ptr The allocated structure
 * @param anotherString the String to be compared.
 * @return the value 0 if the first string is equal to the second string; a
 * value less than 0 if the first string is lexicographically less than the
 * second string; and a value greater than 0 if the first string is
 * lexicographically greater than the second string.
 */
int32_t compareToStr(String *ptr, String *anotherString) {
    return strcmp(ptr-&gt;s, anotherString-&gt;s);
}

/**
 * Compares the one specified string to the other.
 *
 * @param ptr The allocated structure
 * @param anObject The String to compare the first one against
 * @return true if the second given String represents a String equivalent to the first
 * string, false otherwise
 */
bool equalsStr(String *ptr, String *anObject) {
    // testing another object reference for a NULL value
    if (ptr == NULL || anObject == NULL) {
        return false;
    }

    // testing object class equality
    if (sizeof(*ptr) != sizeof(*anObject)) {
        return false;
    }
    
    // testing object fields equality
    return !strcmp(ptr-&gt;s, anObject-&gt;s);
}

/**
 * Returns a new string that is a substring of the specified string.
 *
 * @param ptr The allocated structure
 * @param beginIndex the beginning index, inclusive.
 * @return the specified substring.
 */
String *substring(String *ptr, int32_t beginIndex) {
    return substringTo(ptr, beginIndex, ptr-&gt;len);
}

/**
 * Returns a new string that is a substring of the specified string.
 *
 * @param ptr The allocated structure
 * @param beginIndex the beginning index, inclusive.
 * @param endIndex the ending index, exclusive.
 * @return the specified substring.
 */
String *substringTo(String *ptr, int32_t beginIndex, int32_t endIndex) {
    int32_t len = endIndex - beginIndex;
    char *to = (char*) malloc(len * sizeof(char));
    to[0] = '\0';
    
    // copy the calculated count of characters beginning on the specified offset
    strncat(to, ptr-&gt;s + beginIndex, (size_t) len);

    String *str = new_String(to);
    free(to);

    return str;
}

/**
 * Returns the index within the specified string of the first occurrence of the
 * specified character.
 *
 * @param ptr The allocated structure
 * @param ch a character (Unicode code point).
 * @return the index of the first occurrence of the character in the
 * character sequence represented by the specified string, or -1 if the character
 * does not occur.
 */
int32_t indexOfC(String *ptr, int32_t ch) {
    return indexOfFromC(ptr, ch, 0);
}

/**
 * Returns the index within the specified string of the first occurrence of the
 * specified character, starting the search at the specified index.
 *
 * @param ptr The allocated structure
 * @param ch a character (Unicode code point).
 * @param fromIndex the index to start the search from.
 * @return the index of the first occurrence of the character in the
 * character sequence represented by the specified string that is greater than or
 * equal to fromIndex, or -1 if the character does not occur.
 */
int32_t indexOfFromC(String *ptr, int32_t ch, int32_t fromIndex) {
    char* str = ptr-&gt;s + fromIndex;
    // finding the pointer to char in the char array
    char* c = strchr(str, ch);
    
    if (c == NULL) {
        return -1;
    }
    
    // calculating the array index from the pointer
    size_t index = (size_t)(c - ptr-&gt;s);

    return (int32_t) index;
}

/**
 * Returns the index within the specified string of the first occurrence of the
 * specified substring.
 *
 * @param ptr The allocated structure
 * @param str the substring to search for.
 * @return the index of the first occurrence of the specified substring, or
 * -1 if there is no such occurrence.
 */
int32_t indexOfStr(String *ptr, String *str) {
    return indexOfFromStr(ptr, str, 0);
}

/**
 * Returns the index within the specified string of the first occurrence of the
 * specified substring, starting at the specified index.
 *
 * @param ptr The allocated structure
 * @param str the substring to search for.
 * @param fromIndex the index from which to start the search.
 * @return the index of the first occurrence of the specified substring,
 * starting at the specified index, or -1 if there is no such occurrence.
 */
int32_t indexOfFromStr(String *ptr, String *str, int32_t fromIndex) {
    char* str0 = ptr-&gt;s + fromIndex;
    // finding the pointer to the beginning of substring in the char array
    char* s = strstr(str0, str-&gt;s);

    if (s == NULL) {
        return -1;
    }
    
    // calculating the array index from the pointer
    size_t index = (size_t)(s - ptr-&gt;s);

    return (int32_t) index;
}

/**
 * Returns the length of the specified string.
 *
 * @param ptr The allocated structure
 * @return the length of the sequence of characters represented by the specified
 * string.
 */
int32_t length(String *ptr) {
    return ptr-&gt;len;
}

/**
 * Returns a copy of the string, with leading and trailing whitespace
 * omitted.
 *
 * @param ptr The allocated structure
 * @return A copy of the specified string with leading and trailing white space
 * removed, or the specified string if it has no leading or trailing white space.
 */
String *trim(String *ptr) {
    int32_t i, j;

    // get the index of the first non-white character in the string
    for (i = 0; isspace(ptr-&gt;s[i]); i++);
    // get the index of the last non-white character in the string
    for (j = ptr-&gt;len - 1; isspace(ptr-&gt;s[j]); j--);
    int32_t num = j - i + 1;

    char *str = (char *) malloc(num + 1);
    // copy the non-white substring
    strncpy(str, ptr-&gt;s + i, num);
    str[num] = '\0';

    String *changedStr = new_String(str);
    free(str);

    return changedStr;
}

/**
 * Converts all of the characters in the specified String to lower case using the
 * rules of the default locale.
 *
 * @param ptr The allocated structure
 * @return the String, converted to lowercase.
 */
String *toLowerCase(String *ptr) {
    char *str = (char*) malloc(ptr-&gt;len);

    int32_t i = 0;
    char c;
    // calling the "tolower" function over the each character of the string
    while (ptr-&gt;s[i]) {
        c = ptr-&gt;s[i];
        str[i] = tolower((int32_t)c);
        i++;
    }
    str[i] = '\0';

    String *changedStr = new_String(str);
    free(str);

    return changedStr;
}

/**
 * Converts all of the characters in the specified String to upper case using the
 * rules of the default locale.
 *
 * @param ptr The allocated structure
 * @return the String, converted to uppercase.
 */
String *toUpperCase(String *ptr) {
    char *str = (char*) malloc(ptr-&gt;len);

    int32_t i = 0;
    char c;
    // calling the "toupper" function over the each character of the string
    while (ptr-&gt;s[i]) {
        c = ptr-&gt;s[i];
        str[i] = toupper((int32_t)c);
        i++;
    }
    str[i] = '\0';

    String *changedStr = new_String(str);
    free(str);

    return changedStr;
}

/**
 * Returns the char value at the specified index.
 *
 * @param ptr The allocated structure
 * @param index the index of the char value.
 * @return the char value at the specified index of the specified string. The first
 * char value is at index 0.
 */
char charAt(String *ptr, int32_t index) {
    return ptr-&gt;s[index];
}

/**
 * Returns a new string resulting from replacing all occurrences of oldChar
 * in the specified string with newChar.
 *
 * @param ptr The allocated structure
 * @param oldChar the old character.
 * @param newChar the new character.
 * @return a string derived from the specified string by replacing every occurrence
 * of oldChar with newChar.
 */
String *replace(String *ptr, char oldChar, char newChar) {
    // copying the string
    char *str = strdup(ptr-&gt;s);
    int32_t i;

    // replacing the old char with the new one
    for (i = 0; str[i]; i++) {
        if (str[i] == oldChar) {
            str[i] = newChar;
        }
    }

    String *replacedStr = new_String(str);
    free(str);

    return replacedStr;
}

/**
 * Tests if the specified string starts with the specified prefix.
 *
 * @param ptr The allocated structure
 * @param prefix the prefix.
 * @return true if the character sequence represented by the second string is a
 * prefix of the character sequence represented by the first string; false
 * otherwise. Note also that true will be returned if the second string is an
 * empty string or is equal to the first String structure as determined by the
 * equalsStr(String *, String *) function.
 */
bool startsWith(String *ptr, String *prefix) {
    // test if the string is longer and the prefix index is on the beginning of the string
    return ptr-&gt;len &lt; prefix-&gt;len ? false
            : strncmp(prefix-&gt;s, ptr-&gt;s, prefix-&gt;len) == 0;
}

/**
 * Tests if the specified string ends with the specified suffix.
 *
 * @param ptr The allocated structure
 * @param suffix the suffix.
 * @return true if the character sequence represented by the second string is a
 * suffix of the character sequence represented by the first string; false
 * otherwise. Note that the result will be true if the second string is the empty
 * string or is equal to the first String structure as determined by the
 * equalsStr(String *, String *) function.
 */
bool endsWith(String *ptr, String *suffix) {
    // test if the string is longer and the suffix index is on the end of the string (minus suffix size)
    return ptr-&gt;len &lt; suffix-&gt;len ? false
            : strncmp(suffix-&gt;s, ptr-&gt;s + (ptr-&gt;len - suffix-&gt;len), suffix-&gt;len) == 0;
}

/**
 * Returns true if, and only if, length() is 0.
 *
 * @param ptr The allocated structure
 * @return true if length() is 0, otherwise false
 */
bool isEmptyStr(String *ptr) {
    return ptr-&gt;len == 0;
}

/**
 * The specified structure (which is already a string!) is itself returned.
 *
 * @param ptr The allocated structure
 * @return the string itself.
 */
String *toStringStr(String *ptr) {
    return new_String(ptr-&gt;s);
}
</code>
<code lang="C++">#ifndef STRING_INCLUDED
#define	STRING_INCLUDED

#include &lt;iostream&gt;
#include &lt;cstdint&gt;

class String;

/**
 * Class Object is the root of the class hierarchy.
 */
class Object {
public:
    virtual bool equals(Object *obj);
    virtual String *toString();
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, Object &amp;o);
};

/**
 * This abstract class imposes a total ordering on the objects of each class that implements it.
 */
class Comparable : public Object {
public:
    /**
     * Compares this object with the specified object for order.
     *
     * @param o the object to be compared.
     * @return a negative integer, zero, or a positive integer as this object
     * is less than, equal to, or greater than the specified object.
     */
    virtual int32_t compareTo(Object *o) = 0;
};

/**
 * A comparison function, which imposes a total ordering on some collection of objects.
 */
class Comparator : public Object {
public:
    /**
     * Compares its two arguments for order.
     *
     * @param o1 the first object to be compared.
     * @param o2 the second object to be compared.
     * @return a negative integer, zero, or a positive integer as the
     * first argument is less than, equal to, or greater than the second.
     */
    virtual int32_t compare(Object *o1, Object *o2) = 0;
};

/**
 * The String class represents character strings.
 *
 * @author Petr Kozler (A13B0359P)
 */
class String : public Comparable {
    // an inner string
    std::string s;
    void init(int8_t *value, int32_t offset, int32_t length);
public:
    const std::string _s() const { return s; }
    String(int8_t *value, int32_t length);
    String(int8_t *value, int32_t offset, int32_t length);
    String(std::string original);
    int32_t compareTo(Object *anotherString);
    bool equals(Object *anObject);
    String *substring(int32_t beginIndex);
    String *substring(int32_t beginIndex, int32_t endIndex);
    int32_t indexOf(int32_t ch);
    int32_t indexOf(int32_t ch, int32_t fromIndex);
    int32_t indexOf(String *str);
    int32_t indexOf(String *str, int32_t fromIndex);
    int32_t length();
    String *trim();
    String *toLowerCase();
    String *toUpperCase();
    char charAt(int32_t index);
    String *replace(char oldChar, char newChar);
    bool startsWith(String *prefix);
    bool endsWith(String *suffix);
    bool isEmpty();
    String *toString();
    String *operator=(std::string &amp;s);
};

#endif	// STRING_INCLUDED


#include "String_.h"

#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;

/**
 * Indicates whether some other object is "equal to" this one.
 *
 * @param obj the pointer object with which to compare.
 * @return true if this object is the same as the obj argument; false otherwise.
 */
bool Object::equals(Object *obj) {
    return this == obj;
}

/**
 * Returns a string representation of the object.
 *
 * @return a string representation of the object.
 */
String *Object::toString() {
    std::stringstream stream;
    stream &lt;&lt; std::hex &lt;&lt; this;
    return new String(stream.str());
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, Object &amp;o) {
    return s &lt;&lt; o.toString()-&gt;_s();
}

/*
    Initializes the string with the specified part of the byte array.
*/
void String::init(int8_t *value, int32_t offset, int32_t length) {
    char *s = new char[length + 1];
    
    // copying the bytes as characters
    int32_t i;
    for (i = 0; i &lt; length; i++) {
        s[i] = value[i + offset];
    }
    
    // adding the terminator
    s[i] = '\0';
    this-&gt;s = std::string(s);
    delete[] s;
}

/**
 * Constructs a new String by decoding the specified array of bytes using
 * the ANSI charset.
 *
 * @param bytes The bytes to be decoded into characters
 * @param length The array length
 */
String::String(int8_t *value, int32_t length) {
    init(value, 0, length);
}

/**
 * Constructs a new String by decoding the specified subarray of bytes using
 * the ANSI charset.
 *
 * @param bytes The bytes to be decoded into characters
 * @param offset The index of the first byte to decode
 * @param length The number of bytes to decode
 */
String::String(int8_t *value, int32_t offset, int32_t length) {
    init(value, offset, length);
}

/**
 * Initializes a newly created String object so that it represents the same
 * sequence of characters as the argument; in other words, the inner string of the
 * newly created String object is a copy of the argument string.
 *
 * @param original A String
 */
String::String(std::string original) {
    this-&gt;s = original;
}

/**
 * Compares two strings lexicographically.
 *
 * @param anotherString the String to be compared.
 * @return the value 0 if the argument string is equal to this string; a
 * value less than 0 if this string is lexicographically less than the
 * string argument; and a value greater than 0 if this string is
 * lexicographically greater than the string argument.
 */
int32_t String::compareTo(Object *anotherString) {
    return this-&gt;s.compare(((String *)anotherString)-&gt;s);
}

/**
 * Compares this string to the specified object.
 *
 * @param anObject The object to compare this String against
 * @return true if the given object represents a String equivalent to this
 * string, false otherwise
 */
bool String::equals(Object *anObject) {
    // testing another object reference for a NULL value
    if (anObject == nullptr) {
        return false;
    }

    // testing object class equality
    if (sizeof(this) != sizeof(*anObject)) {
        return false;
    }

    // testing object fields equality
    return !this-&gt;s.compare(((String *)anObject)-&gt;s);
}

/**
 * Returns a new string that is a substring of this string.
 * 
 * @param beginIndex the beginning index, inclusive.
 * @return the specified substring.
 */
String *String::substring(int32_t beginIndex) {
    return new String(this-&gt;s.substr(beginIndex));
}

/**
 * Returns a new string that is a substring of this string.
 *
 * @param beginIndex the beginning index, inclusive.
 * @param endIndex the ending index, exclusive.
 * @return the specified substring.
 */
String *String::substring(int32_t beginIndex, int32_t endIndex) {
    return new String(this-&gt;s.substr(beginIndex, endIndex - beginIndex));
}

/**
 * Returns the index within this string of the first occurrence of the
 * specified character.
 *
 * @param ch a character (Unicode code point).
 * @return the index of the first occurrence of the character in the
 * character sequence represented by this object, or -1 if the character
 * does not occur.
 */
int32_t String::indexOf(int32_t ch) {
    return this-&gt;s.find((char) ch);
}

/**
 * Returns the index within this string of the first occurrence of the
 * specified character, starting the search at the specified index.
 *
 * @param ch a character (Unicode code point).
 * @param fromIndex the index to start the search from.
 * @return the index of the first occurrence of the character in the
 * character sequence represented by this object that is greater than or
 * equal to fromIndex, or -1 if the character does not occur.
 */
int32_t String::indexOf(int32_t ch, int32_t fromIndex) {
    return this-&gt;s.find((char) ch, fromIndex);
}

/**
 * Returns the index within this string of the first occurrence of the
 * specified substring.
 *
 * @param str the substring to search for.
 * @return the index of the first occurrence of the specified substring, or
 * -1 if there is no such occurrence.
 */
int32_t String::indexOf(String *str) {
    return this-&gt;s.find(str-&gt;s);
}

/**
 * Returns the index within this string of the first occurrence of the
 * specified substring, starting at the specified index.
 *
 * @param str the substring to search for.
 * @param fromIndex the index from which to start the search.
 * @return the index of the first occurrence of the specified substring,
 * starting at the specified index, or -1 if there is no such occurrence.
 */
int32_t String::indexOf(String *str, int32_t fromIndex) {
    return this-&gt;s.find(str-&gt;s, fromIndex);
}

/**
 * Returns the length of this string.
 *
 * @return the length of the sequence of characters represented by this
 * object.
 */
int32_t String::length() {
    return this-&gt;s.length();
}

/**
 * Returns a copy of the string, with leading and trailing whitespace
 * omitted.
 *
 * @return A copy of this string with leading and trailing white space
 * removed, or this string if it has no leading or trailing white space.
 */
String *String::trim() {
    const char* white_spaces = " \t\n\x0b\r\f";

    // get the index of the first non-white character in the string
    int32_t first = this-&gt;s.find_first_not_of(white_spaces);

    // return empty string if the original string contains only white-spaces
    if (first == std::string::npos) {
        return new String(std::string(""));
    }

    // get the index of the last non-white character in the string
    int32_t last = this-&gt;s.find_last_not_of(white_spaces);

    // return non-white substring
    return new String(this-&gt;s.substr(first, last - first + 1));
}

/**
 * Converts all of the characters in this String to lower case using the
 * rules of the default locale.
 *
 * @return the String, converted to lowercase.
 */
String *String::toLowerCase() {
    std::string lowerCaseStr = this-&gt;s;
    // calling the "tolower" function over the each character of the string
    std::transform(lowerCaseStr.begin(), lowerCaseStr.end(), lowerCaseStr.begin(), ::tolower);
    return new String(lowerCaseStr);
}

/**
 * Converts all of the characters in this String to upper case using the
 * rules of the default locale.
 *
 * @return the String, converted to uppercase.
 */
String *String::toUpperCase() {
    std::string upperCaseStr = this-&gt;s;
    // calling the "toupper" function over the each character of the string
    std::transform(upperCaseStr.begin(), upperCaseStr.end(), upperCaseStr.begin(), ::toupper);
    return new String(upperCaseStr);
}

/**
 * Returns the char value at the specified index.
 *
 * @param index the index of the char value.
 * @return the char value at the specified index of this string. The first
 * char value is at index 0.
 */
char String::charAt(int32_t index) {
    return this-&gt;s.at(index);
}

/**
 * Returns a new string resulting from replacing all occurrences of oldChar
 * in this string with newChar.
 *
 * @param oldChar the old character.
 * @param newChar the new character.
 * @return a string derived from this string by replacing every occurrence
 * of oldChar with newChar.
 */
String *String::replace(char oldChar, char newChar) {
    std::string str = this-&gt;s;
    std::replace(str.begin(), str.end(), oldChar, newChar);

    return new String(str);
}

/**
 * Tests if this string starts with the specified prefix.
 *
 * @param prefix the prefix.
 * @return true if the character sequence represented by the argument is a
 * prefix of the character sequence represented by this string; false
 * otherwise. Note also that true will be returned if the argument is an
 * empty string or is equal to this String object as determined by the
 * equals(Object) method.
 */
bool String::startsWith(String *prefix) {
    // test if the string is longer and the prefix index is on the beginning of the string
    return (s.size() &gt;= prefix-&gt;_s().size() &amp;&amp; s.find(prefix-&gt;_s()) == 0);
}

/**
 * Tests if this string ends with the specified suffix.
 *
 * @param suffix the suffix.
 * @return true if the character sequence represented by the argument is a
 * suffix of the character sequence represented by this object; false
 * otherwise. Note that the result will be true if the argument is the empty
 * string or is equal to this String object as determined by the
 * equals(Object) method.
 */
bool String::endsWith(String *suffix) {
    // test if the string is longer and the suffix index is on the end of the string (minus suffix size)
    return (s.size() &gt;= suffix-&gt;_s().size() &amp;&amp;
            s.compare(s.size() - suffix-&gt;_s().size(), suffix-&gt;_s().size(), suffix-&gt;_s()) == 0);
}

/**
 * Returns true if, and only if, length() is 0.
 *
 * @return true if length() is 0, otherwise false
 */
bool String::isEmpty() {
    return (this-&gt;s.length() == 0);
}

/**
 * This object (which is already a string!) is itself returned.
 *
 * @return the string itself.
 */
String *String::toString() {
    return new String(s);
}

String *String::operator=(std::string &amp;s) {
    return new String(s);
}
</code>
<code lang="C#">ï»¿using System;
using System.Collections.Generic;
using System.Text;

namespace JavaClasses
{

    /// &lt;summary&gt;
    /// Class Object is the root of the class hierarchy.
    /// &lt;/summary&gt;
    public class Object
    {

        /// &lt;summary&gt;
        /// Indicates whether some other object is "equal to" this one.
        /// &lt;/summary&gt;
        /// &lt;param name="obj"&gt;the reference object with which to compare.&lt;/param&gt;
        /// &lt;returns&gt;true if this object is the same as the obj argument; false otherwise.&lt;/returns&gt;
        public virtual bool equals(Object obj)
        {
            return this == obj;
        }

        /// &lt;summary&gt;
        /// Returns a string representation of the object.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;a string representation of the object.&lt;/returns&gt;
        public virtual String toString()
        {
            return new String(base.ToString());
        }

        public override bool Equals(object obj)
        {
            return equals(obj as Object);
        }

        public override string ToString()
        {
            return toString().s;
        }

    }

    /// &lt;summary&gt;
    /// This abstract class imposes a total ordering on the objects of each class that implements it.
    /// &lt;/summary&gt;
    public abstract class Comparable : Object, IComparable&lt;Object&gt;
    {

        /// &lt;summary&gt;
        /// Compares this object with the specified object for order.
        /// &lt;/summary&gt;
        /// &lt;param name="o"&gt;the object to be compared.&lt;/param&gt;
        /// &lt;returns&gt;a negative integer, zero, or a positive integer as this object
        /// is less than, equal to, or greater than the specified object.&lt;/returns&gt;
        public abstract int compareTo(Object o);

        public int CompareTo(Object o)
        {
            return compareTo(o);
        }

    }

    /// &lt;summary&gt;
    /// A comparison function, which imposes a total ordering on some collection of objects.
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    public abstract class Comparator : Object, IComparer&lt;Object&gt;
    {

        /// &lt;summary&gt;
        /// Compares its two arguments for order.
        /// &lt;/summary&gt;
        /// &lt;param name="o1"&gt;the first object to be compared.&lt;/param&gt;
        /// &lt;param name="o2"&gt;the second object to be compared.&lt;/param&gt;
        /// &lt;returns&gt;negative integer, zero, or a positive integer as the
        /// first argument is less than, equal to, or greater than the second.&lt;/returns&gt;
        public abstract int compare(Object o1, Object o2);

        public int Compare(Object o1, Object o2)
        {
            return compare(o1, o2);
        }

    }

    /// &lt;summary&gt;
    /// The String class represents character strings.
    /// &lt;/summary&gt;
    /// &lt;author&gt;Petr Kozler (A13B0359P)&lt;/author&gt;
    public class String : Comparable
    {

        // an inner string
        public string s { get; private set; }

        /// &lt;summary&gt;
        /// Constructs a new String by decoding the specified array of bytes using
        /// the platform's default charset.
        /// &lt;/summary&gt;
        /// &lt;param name="bytes"&gt;The bytes to be decoded into characters
        /// &lt;/param&gt;
        public String(sbyte[] bytes)
        {
            // parsing to the unsigned byte array
            byte[] unsigned = (byte[])(Array)bytes;
            s = Encoding.Default.GetString(unsigned);
        }

        /// &lt;summary&gt;
        /// Constructs a new String by decoding the specified subarray of bytes using
        /// the platform's default charset.
        /// &lt;/summary&gt;
        /// &lt;param name="bytes"&gt;The bytes to be decoded into characters
        /// &lt;/param&gt;&lt;param name="offset"&gt;The index of the first byte to decode
        /// &lt;/param&gt;&lt;param name="length"&gt;The number of bytes to decode
        /// &lt;/param&gt;
        public String(sbyte[] bytes, int offset, int length)
        {
            // parsing to the unsigned byte array
            byte[] unsigned = (byte[])(Array)bytes;
            s = Encoding.Default.GetString(unsigned, offset, length);
        }

        /// &lt;summary&gt;
        /// Initializes a newly created String object so that it represents the same
        /// sequence of characters as the argument; in other words, the inner string of the
        /// newly created String object is a copy of the argument string.
        /// &lt;/summary&gt;
        /// &lt;param name="original"&gt;A String
        /// &lt;/param&gt;
        public String(string original)
        {
            s = original;
        }

        /// &lt;summary&gt;
        /// Compares two strings lexicographically.
        /// &lt;/summary&gt;
        /// &lt;param name="anotherString"&gt;the String to be compared.
        /// &lt;/param&gt;&lt;returns&gt;the value 0 if the argument string is equal to this string; a
        /// value less than 0 if this string is lexicographically less than the
        /// string argument; and a value greater than 0 if this string is
        /// lexicographically greater than the string argument.
        /// &lt;/returns&gt;
        public override int compareTo(Object anotherString)
        {
            return s.CompareTo((anotherString as String).s);
        }

        /// &lt;summary&gt;
        /// Compares this string to the specified object.
        /// &lt;/summary&gt;
        /// &lt;param name="anObject"&gt;The object to compare this String against
        /// &lt;/param&gt;&lt;returns&gt;true if the given object represents a String equivalent to this
        /// string, false otherwise
        /// &lt;/returns&gt;
        public override bool equals(Object anObject)
        {
            // testing another object reference for a NULL value
            if (anObject == null)
            {
                return false;
            }

            // testing object class equality
            if (GetType() != anObject.GetType())
            {
                return false;
            }

            // testing object fields equality
            return s.Equals((anObject as String).s);
        }

        /// &lt;summary&gt;
        /// Returns a new string that is a substring of this string.
        /// &lt;/summary&gt;
        /// &lt;param name="beginIndex"&gt;the beginning index, inclusive.
        /// &lt;/param&gt;&lt;returns&gt;the specified substring.
        /// &lt;/returns&gt;
        public String substring(int beginIndex)
        {
            return new String(s.Substring(beginIndex));
        }

        /// &lt;summary&gt;
        /// Returns a new string that is a substring of this string.
        /// &lt;/summary&gt;
        /// &lt;param name="beginIndex"&gt;the beginning index, inclusive.
        /// &lt;/param&gt;&lt;param name="endIndex"&gt;the ending index, exclusive.
        /// &lt;/param&gt;&lt;returns&gt;the specified substring.
        /// &lt;/returns&gt;
        public String substring(int beginIndex, int endIndex)
        {
            // calculating the length from the specified end index
            return new String(s.Substring(beginIndex, endIndex - beginIndex));
        }

        /// &lt;summary&gt;
        /// Returns the index within this string of the first occurrence of the
        /// specified character.
        /// &lt;/summary&gt;
        /// &lt;param name="ch"&gt;a character (Unicode code point).
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the character in the
        /// character sequence represented by this object, or -1 if the character
        /// does not occur.
        /// &lt;/returns&gt;
        public int indexOf(int ch)
        {
            return s.IndexOf((char)ch);
        }

        /// &lt;summary&gt;
        /// Returns the index within this string of the first occurrence of the
        /// specified character, starting the search at the specified index.
        /// &lt;/summary&gt;
        /// &lt;param name="ch"&gt;a character (Unicode code point).
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index to start the search from.
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the character in the
        /// character sequence represented by this object that is greater than or
        /// equal to fromIndex, or -1 if the character does not occur.
        /// &lt;/returns&gt;
        public int indexOf(int ch, int fromIndex)
        {
            return s.IndexOf((char)ch, fromIndex);
        }

        /// &lt;summary&gt;
        /// Returns the index within this string of the first occurrence of the
        /// specified substring.
        /// &lt;/summary&gt;
        /// &lt;param name="str"&gt;the substring to search for.
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the specified substring, or
        /// -1 if there is no such occurrence.
        /// &lt;/returns&gt;
        public int indexOf(String str)
        {
            return s.IndexOf(str.s);
        }

        /// &lt;summary&gt;
        /// Returns the index within this string of the first occurrence of the
        /// specified substring, starting at the specified index.
        /// &lt;/summary&gt;
        /// &lt;param name="str"&gt;the substring to search for.
        /// &lt;/param&gt;&lt;param name="fromIndex"&gt;the index from which to start the search.
        /// &lt;/param&gt;&lt;returns&gt;the index of the first occurrence of the specified substring,
        /// starting at the specified index, or -1 if there is no such occurrence.
        /// &lt;/returns&gt;
        public int indexOf(String str, int fromIndex)
        {
            return s.IndexOf(str.s, fromIndex);
        }

        /// &lt;summary&gt;
        /// Returns the length of this string.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;the length of the sequence of characters represented by this
        /// object.
        /// &lt;/returns&gt;
        public int length()
        {
            return s.Length;
        }

        /// &lt;summary&gt;
        /// Returns a copy of the string, with leading and trailing whitespace
        /// omitted.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A copy of this string with leading and trailing white space
        /// removed, or this string if it has no leading or trailing white space.
        /// &lt;/returns&gt;
        public String trim()
        {
            return new String(s.Trim());
        }

        /// &lt;summary&gt;
        /// Converts all of the characters in this String to lower case using the
        /// rules of the default locale.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;the String, converted to lowercase.
        /// &lt;/returns&gt;
        public String toLowerCase()
        {
            return new String(s.ToLower());
        }

        /// &lt;summary&gt;
        /// Converts all of the characters in this String to upper case using the
        /// rules of the default locale.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;the String, converted to uppercase.
        /// &lt;/returns&gt;
        public String toUpperCase()
        {
            return new String(s.ToUpper());
        }

        /// &lt;summary&gt;
        /// Returns the char value at the specified index.
        /// &lt;/summary&gt;
        /// &lt;param name="index"&gt;the index of the char value.
        /// &lt;/param&gt;&lt;returns&gt;the char value at the specified index of this string. The first
        /// char value is at index 0.
        /// &lt;/returns&gt;
        public char charAt(int index)
        {
            return s[index];
        }

        /// &lt;summary&gt;
        /// Returns a new string resulting from replacing all occurrences of oldChar
        /// in this string with newChar.
        /// &lt;/summary&gt;
        /// &lt;param name="oldChar"&gt;the old character.
        /// &lt;/param&gt;&lt;param name="newChar"&gt;the new character.
        /// &lt;/param&gt;&lt;returns&gt;a string derived from this string by replacing every occurrence
        /// of oldChar with newChar.
        /// &lt;/returns&gt;
        public String replace(char oldChar, char newChar)
        {
            return new String(s.Replace(oldChar, newChar));
        }

        /// &lt;summary&gt;
        /// Tests if this string starts with the specified prefix.
        /// &lt;/summary&gt;
        /// &lt;param name="prefix"&gt;the prefix.
        /// &lt;/param&gt;&lt;returns&gt;true if the character sequence represented by the argument is a
        /// prefix of the character sequence represented by this string; false
        /// otherwise. Note also that true will be returned if the argument is an
        /// empty string or is equal to this String object as determined by the
        /// equals(Object) method.
        /// &lt;/returns&gt;
        public bool startsWith(String prefix)
        {
            return s.StartsWith(prefix.s);
        }

        /// &lt;summary&gt;
        /// Tests if this string ends with the specified suffix.
        /// &lt;/summary&gt;
        /// &lt;param name="suffix"&gt;the suffix.
        /// &lt;/param&gt;&lt;returns&gt;true if the character sequence represented by the argument is a
        /// suffix of the character sequence represented by this object; false
        /// otherwise. Note that the result will be true if the argument is the empty
        /// string or is equal to this String object as determined by the
        /// equals(Object) method.
        /// &lt;/returns&gt;
        public bool endsWith(String suffix)
        {
            return s.EndsWith(suffix.s);
        }

        /// &lt;summary&gt;
        /// Returns true if, and only if, length() is 0.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;true if length() is 0, otherwise false
        /// &lt;/returns&gt;
        public bool isEmpty()
        {
            return s.Length == 0;
        }

        /// &lt;summary&gt;
        /// This object (which is already a string!) is itself returned.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;the string itself.&lt;/returns&gt;
        public override String toString()
        {
            return new String(s);
        }
        
        public static implicit operator String(string original)
        {
            return new String(original);
        }
        
    }

}
</code>
<code lang="Free Pascal">unit StringUnit;

{$mode objfpc}{$H+}

interface

type
  String_ = class;

  (**
   * Class Object is the root of the class hierarchy.
   *)
  Object_ = class
    public
      function equals_(obj: Object_) : boolean; virtual;
      function toString_() : String_; virtual;
      function equals(obj: TObject) : boolean; override;
      function toString() : ansiString; override;
  end;

  (**
   * This abstract class imposes a total ordering on the objects of each class that implements it.
   *)
  Comparable = class(Object_)
    public
      (**
       * Compares this object with the specified object for order.
       *
       * @param o the object to be compared.
       * @return a negative integer, zero, or a positive integer as this object
       * is less than, equal to, or greater than the specified object.
       *)
      function compareTo(o: Object_) : longInt; virtual; abstract;
  end;

  (**
   * A comparison function, which imposes a total ordering on some collection of objects.
   *)
  Comparator = class(Object_)
    public
      (**
       * Compares its two arguments for order.
       *
       * @param o1 the first object to be compared.
       * @param o2 the second object to be compared.
       * @return a negative integer, zero, or a positive integer as the
       * first argument is less than, equal to, or greater than the second.
       *)
      function compare(o1, o2: Object_) : longInt; virtual; abstract;
  end;

  (**
   * The String class represents character strings.
   *
   * @author Petr Kozler (A13B0359P)
   *)
  String_ = class(Comparable)
    private
      // an inner string
      var str: ansiString;
    public
      property strProperty: ansiString read str;
      constructor create(bytes: array of shortInt);
      constructor create(bytes: array of shortInt; offset: longInt; length: longInt);
      constructor create(original: ansiString);
      function compareTo(anotherString: Object_) : longInt; override;
      function equals_(anObject: Object_) : boolean; override;
      function substring(beginIndex: longInt) : String_;
      function substring(beginIndex: longInt; endIndex: longInt) : String_;
      function indexOf(ch: longInt) : longInt;
      function indexOf(ch: longInt; fromIndex: longInt) : longInt;
      function indexOf(s: String_) : longInt;
      function indexOf(s: String_; fromIndex: longInt) : longInt;
      function length() : longInt;
      function trim() : String_;
      function toLowerCase() : String_;
      function toUpperCase() : String_;
      function charAt(index: longInt) : ansiChar;
      function replace(oldChar: ansiChar; newChar: ansiChar) : String_;
      function startsWith(prefix: String_) : boolean;
      function endsWith(suffix: String_) : boolean;
      function isEmpty() : boolean;
      function toString_() : String_; override;
  end;

operator := (original: ansiString) s: String_;

implementation

uses
  SysUtils, StrUtils;

(**
 * Indicates whether some other object is "equal to" this one.
 *
 * @param obj the reference object with which to compare.
 * @return true if this object is the same as the obj argument; false otherwise.
 *)
function Object_.equals_(obj: Object_) : boolean;
begin
  equals_ := self = obj;
end;

(**
 * Returns a string representation of the object.
 *
 * @return a string representation of the object.
 *)
function Object_.toString_() : String_;
begin
  toString_ := String_.create(inherited toString());
end;

function Object_.equals(obj: TObject) : boolean;
begin
  equals := self.equals_(Object_(obj));
end;

function Object_.toString() : ansiString;
begin
  toString := toString_().str;
end;

(**
 * Constructs a new String by decoding the specified array of bytes using
 * the ANSI charset.
 *
 * @param bytes The bytes to be decoded into characters
 *)
constructor String_.create(bytes: array of shortInt);
begin
  setString(str, @bytes[0], System.length(bytes));
end;

(**
 * Constructs a new String by decoding the specified subarray of bytes using
 * the ANSI charset.
 *
 * @param bytes The bytes to be decoded into characters
 * @param offset The index of the first byte to decode
 * @param length The number of bytes to decode
 *)
constructor String_.create(bytes: array of shortInt; offset: longInt; length: longInt);
begin
  setString(str, @bytes[offset], length);
end;

(**
 * Initializes a newly created String object so that it represents the same
 * sequence of characters as the argument; in other words, the inner string of the
 * newly created String object is a copy of the argument string.
 *
 * @param original A String
 *)
constructor String_.create(original: ansiString);
begin
  str := original;
end;

(**
 * Compares two strings lexicographically.
 *
 * @param anotherString the String to be compared.
 * @return the value 0 if the argument string is equal to this string; a
 * value less than 0 if this string is lexicographically less than the
 * string argument; and a value greater than 0 if this string is
 * lexicographically greater than the string argument.
 *)
function String_.compareTo(anotherString: Object_) : longInt;
begin
  compareTo := ansiCompareStr(str, (anotherString as String_).str);
end;

(**
 * Compares this string to the specified object.
 *
 * @param anObject The object to compare this String against
 * @return true if the given object represents a String equivalent to this
 * string, false otherwise
 *)
function String_.equals_(anObject: Object_) : boolean;
begin
  // testing another object reference for a NULL value
  if anObject = nil then begin
    exit(false);
  end;

  // testing object class equality
  if typeOf(self) &lt;&gt; typeOf(anObject) then begin
    exit(false);
  end;

  // testing object fields equality
  equals_ := (ansiCompareStr(self.str, (anObject as String_).str) = 0);
end;

(**
 * Returns a new string that is a substring of this string.
 *
 * @param beginIndex the beginning index, inclusive.
 * @return the specified substring.
 *)
function String_.substring(beginIndex: longInt) : String_;
begin
  substring := substring(beginIndex, System.length(str));
end;

(**
 * Returns a new string that is a substring of this string.
 *
 * @param beginIndex the beginning index, inclusive.
 * @param endIndex the ending index, exclusive.
 * @return the specified substring.
 *)
function String_.substring(beginIndex: longInt; endIndex: longInt) : String_;
var
  s: String_;
begin
  // copy the calculated count of characters beginning on the specified offset
  s := String_.create(copy(str, beginIndex + 1, endIndex - beginIndex));
  substring := s;
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified character.
 *
 * @param ch a character (Unicode code point).
 * @return the index of the first occurrence of the character in the
 * character sequence represented by this object, or -1 if the character
 * does not occur.
 *)
function String_.indexOf(ch: longInt) : longInt;
begin
  indexOf := indexOf(ch, 0);
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified character, starting the search at the specified index.
 *
 * @param ch a character (Unicode code point).
 * @param fromIndex the index to start the search from.
 * @return the index of the first occurrence of the character in the
 * character sequence represented by this object that is greater than or
 * equal to fromIndex, or -1 if the character does not occur.
 *)
function String_.indexOf(ch: longInt; fromIndex: longInt) : longInt;
var
  substr: ansiString;
  i: longInt;
begin
  // copying the characters beginning on the specified offset
  substr := copy(str, fromIndex + 1, System.length(str) - fromIndex);
  // finding the position of the specified character in the string
  i := pos(ansiChar(ch), substr) - 1;

  // returning 0
  if i &lt; 0 then begin
    exit(-1);
  end;

  // adding the specified offset
  indexOf := i + fromIndex;
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified substring.
 *
 * @param str the substring to search for.
 * @return the index of the first occurrence of the specified substring, or
 * -1 if there is no such occurrence.
 *)
function String_.indexOf(s: String_) : longInt;
begin
  indexOf := indexOf(s, 0);
end;

(**
 * Returns the index within this string of the first occurrence of the
 * specified substring, starting at the specified index.
 *
 * @param str the substring to search for.
 * @param fromIndex the index from which to start the search.
 * @return the index of the first occurrence of the specified substring,
 * starting at the specified index, or -1 if there is no such occurrence.
 *)
function String_.indexOf(s: String_; fromIndex: longInt) : longInt;
var
  substr: ansiString;
  i: longInt;
begin
  // copying the characters beginning on the specified offset
  substr := copy(str, fromIndex + 1, System.length(str) - fromIndex + 1);
  // finding the position of the specified character in the string
  i := pos(s.str, substr) - 1;

  // returning 0
  if i &lt; 0 then begin
    exit(-1);
  end;

  // adding the specified offset
  indexOf := i + fromIndex;
end;

(**
 * Returns the length of this string.
 *
 * @return the length of the sequence of characters represented by this
 * object.
 *)
function String_.length() : longInt;
begin
  length := System.length(str);
end;

(**
 * Returns a copy of the string, with leading and trailing whitespace
 * omitted.
 *
 * @return A copy of this string with leading and trailing white space
 * removed, or this string if it has no leading or trailing white space.
 *)
function String_.trim() : String_;
var
  s: String_;
begin
  s := String_.create(SysUtils.trim(str));
  trim := s;
end;

(**
 * Converts all of the characters in this String to lower case using the
 * rules of the default locale.
 *
 * @return the String, converted to lowercase.
 *)
function String_.toLowerCase() : String_;
var
  s: String_;
begin
  s := String_.create(lowerCase(str));
  toLowerCase := s;
end;

(**
 * Converts all of the characters in this String to upper case using the
 * rules of the default locale.
 *
 * @return the String, converted to uppercase.
 *)
function String_.toUpperCase() : String_;
var
  s: String_;
begin
  s.create(upperCase(str));
  toUpperCase := s;
end;

(**
 * Returns the char value at the specified index.
 *
 * @param index the index of the char value.
 * @return the char value at the specified index of this string. The first
 * char value is at index 0.
 *)
function String_.charAt(index: longInt) : ansiChar;
begin
  charAt := str[index + 1];
end;

(**
 * Returns a new string resulting from replacing all occurrences of oldChar
 * in this string with newChar.
 *
 * @param oldChar the old character.
 * @param newChar the new character.
 * @return a string derived from this string by replacing every occurrence
 * of oldChar with newChar.
 *)
function String_.replace(oldChar: ansiChar; newChar: ansiChar) : String_;
begin
  replace := replaceStr(str, oldChar, newChar);
end;

(**
 * Tests if this string starts with the specified prefix.
 *
 * @param prefix the prefix.
 * @return true if the character sequence represented by the argument is a
 * prefix of the character sequence represented by this string; false
 * otherwise. Note also that true will be returned if the argument is an
 * empty string or is equal to this String object as determined by the
 * equals(Object) method.
 *)
function String_.startsWith(prefix: String_) : boolean;
begin
  startsWith := ansiStartsStr(prefix.toString(), str);
end;

(**
 * Tests if this string ends with the specified suffix.
 *
 * @param suffix the suffix.
 * @return true if the character sequence represented by the argument is a
 * suffix of the character sequence represented by this object; false
 * otherwise. Note that the result will be true if the argument is the empty
 * string or is equal to this String object as determined by the
 * equals(Object) method.
 *)
function String_.endsWith(suffix: String_) : boolean;
begin
  endsWith := ansiEndsStr(suffix.toString(), str);
end;

(**
 * Returns true if, and only if, length() is 0.
 *
 * @return true if length() is 0, otherwise false
 *)
function String_.isEmpty() : boolean;
begin
  isEmpty := (self.length() = 0);
end;

(**
 * This object (which is already a string!) is itself returned.
 *
 * @return the string itself.
 *)
function String_.toString_() : String_;
begin
  toString_ := String_.create(str);
end;

operator := (original: ansiString) s: String_;
begin
  s := String_.create(original);
end;

end.

</code>

</codes>
